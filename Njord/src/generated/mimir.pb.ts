// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: mimir.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as atoms from "./atoms.pb";

//========================================//
//                 Types                  //
//========================================//

export interface Events_GetRulesets_Payload {}

export interface Events_GetRulesets_Response {
  rulesets: atoms.RulesetGenerated[];
}

export interface Events_GetTimezones_Payload {
  addr: string;
}

export interface Events_GetTimezones_Response {
  preferredByIp: string;
  timezones: string[];
}

export interface Events_GetCountries_Payload {
  addr: string;
}

export interface Events_GetCountries_Response {
  preferredByIp: string;
  countries: atoms.Country[];
}

export interface Events_GetEvents_Payload {
  limit: number;
  offset: number;
  filterUnlisted: boolean;
}

export interface Events_GetEvents_Response {
  total: number;
  events: atoms.Event[];
}

export interface Events_GetEventsById_Payload {
  ids: number[];
}

export interface Events_GetEventsById_Response {
  events: atoms.Event[];
}

export interface Players_GetMyEvents_Payload {}

export interface Players_GetMyEvents_Response {
  events: atoms.MyEvent[];
}

export interface Events_GetRatingTable_Payload {
  eventIdList: number[];
  orderBy: string;
  order: string;
  withPrefinished: boolean;
}

export interface Events_GetRatingTable_Response {
  list: atoms.PlayerInRating[];
}

export interface Events_GetLastGames_Payload {
  eventIdList: number[];
  limit: number;
  offset: number;
  orderBy?: string | null | undefined;
  order?: string | null | undefined;
}

export interface Events_GetLastGames_Response {
  games: atoms.GameResult[];
  players: atoms.Player[];
  totalGames: number;
}

export interface Events_GetGame_Payload {
  sessionHash: string;
}

export interface Events_GetGame_Response {
  game: atoms.GameResult;
  players: atoms.Player[];
}

export interface Events_GetGamesSeries_Response {
  results: atoms.SeriesResult[];
}

export interface Players_GetCurrentSessions_Payload {
  playerId: number;
  eventId: number;
}

export interface Players_GetCurrentSessions_Response {
  sessions: atoms.CurrentSession[];
}

export interface Events_GetAllRegisteredPlayers_Payload {
  eventIds: number[];
}

export interface Events_GetAllRegisteredPlayers_Response {
  players: atoms.RegisteredPlayer[];
}

export interface Events_GetTimerState_Response {
  started: boolean;
  finished: boolean;
  timeRemaining: number;
  waitingForTimer: boolean;
  haveAutostart: boolean;
  autostartTimer: boolean;
}

export interface Games_GetSessionOverview_Payload {
  sessionHash: string;
}

export interface Games_GetSessionOverview_Response {
  id: number;
  eventId: number;
  tableIndex?: number | null | undefined;
  players: atoms.PlayerInSession[];
  state: atoms.SessionState;
}

export interface Players_GetPlayerStats_Payload {
  playerId: number;
  eventIdList: number[];
}

export interface Players_GetPlayerStats_Response {
  ratingHistory: number[];
  scoreHistory: atoms.SessionHistoryResultTable[];
  playersInfo: atoms.Player[];
  placesSummary: atoms.PlacesSummaryItem[];
  totalPlayedGames: number;
  totalPlayedRounds: number;
  winSummary: atoms.PlayerWinSummary;
  handsValueSummary: atoms.HandValueStat[];
  yakuSummary: atoms.YakuStat[];
  riichiSummary: atoms.RiichiSummary;
  doraStat: atoms.DoraSummary;
}

export interface Games_AddRound_Payload {
  sessionHash: string;
  roundData: atoms.Round;
}

export interface Games_AddRound_Response {
  scores: atoms.IntermediateResultOfSession[];
  extraPenaltyLog: atoms.Penalty[];
  round: number;
  honba: number;
  riichiBets: number;
  prematurelyFinished: boolean;
  roundJustChanged: boolean;
  isFinished: boolean;
  yellowZoneAlreadyPlayed: boolean;
  lastOutcome?: atoms.RoundOutcome | null | undefined;
}

export interface Games_PreviewRound_Payload {
  sessionHash: string;
  roundData: atoms.Round;
}

export interface Games_PreviewRound_Response {
  state: atoms.RoundState;
}

export interface Games_AddOnlineReplay_Payload {
  eventId: number;
  link: string;
}

export interface Games_AddOnlineReplay_Response {
  game: atoms.GameResult;
  players: atoms.Player[];
}

export interface Players_GetLastResults_Payload {
  playerId: number;
  eventId: number;
}

export interface Players_GetLastResults_Response {
  results: atoms.SessionHistoryResult[];
}

export interface Players_GetLastRound_Payload {
  playerId: number;
  eventId: number;
}

export interface Players_GetLastRound_Response {
  round: atoms.RoundState;
}

export interface Players_GetAllRounds_Payload {
  sessionHash: string;
}

export interface Players_GetAllRounds_Response {
  round: atoms.RoundState[];
}

export interface Players_GetLastRoundByHash_Payload {
  sessionHash: string;
}

export interface Players_GetLastRoundByHash_Response {
  round: atoms.RoundState;
}

export interface Events_GetEventForEdit_Payload {
  id: number;
}

export interface Events_GetEventForEdit_Response {
  id: number;
  event: atoms.EventData;
}

export interface Events_UpdateEvent_Payload {
  id: number;
  event: atoms.EventData;
}

export interface Events_GetTablesState_Response {
  tables: atoms.TableState[];
}

export interface Events_RegisterPlayer_Payload {
  playerId: number;
  eventId: number;
}

export interface Events_UnregisterPlayer_Payload {
  playerId: number;
  eventId: number;
}

export interface Events_UpdatePlayerSeatingFlag_Payload {
  playerId: number;
  eventId: number;
  ignoreSeating: boolean;
}

export interface Events_GetAchievements_Payload {
  eventIds: number[];
  achievementsList: string[];
}

export interface Events_GetAchievements_Response {
  achievements: atoms.Achievement[];
}

export interface Events_GetAchievementsList_Payload {}

export interface Events_GetAchievementsList_Response {
  list: string[];
}

export interface Events_UpdatePlayersLocalIds_Payload {
  eventId: number;
  idMap: atoms.LocalIdMapping[];
}

export interface Events_UpdatePlayerReplacement_Payload {
  playerId: number;
  eventId: number;
  replacementId: number;
}

export interface Events_UpdatePlayersTeams_Payload {
  eventId: number;
  teamNameMap: atoms.TeamMapping[];
}

export interface Games_StartGame_Payload {
  eventId: number;
  players: number[];
}

export interface Games_StartGame_Response {
  sessionHash: string;
}

export interface Games_EndGame_Payload {
  sessionHash: string;
}

export interface Games_CancelGame_Payload {
  sessionHash: string;
}

export interface Games_DropLastRound_Payload {
  sessionHash: string;
}

export interface Games_DefinalizeGame_Payload {
  sessionHash: string;
}

export interface Games_AddPenalty_Payload {
  eventId: number;
  playerId: number;
  amount: number;
  reason: string;
}

export interface Games_AddPenaltyGame_Payload {
  eventId: number;
  players: number[];
}

export interface Games_AddPenaltyGame_Response {
  hash: string;
}

export interface Players_GetPlayer_Payload {
  id: number;
}

export interface Players_GetPlayer_Response {
  players: atoms.Player;
}

export interface Events_GetCurrentSeating_Response {
  seating: atoms.PlayerSeating[];
}

export interface Seating_MakeShuffledSeating_Payload {
  eventId: number;
  groupsCount: number;
  seed: number;
}

export interface Seating_GenerateSwissSeating_Response {
  tables: atoms.TableItemSwiss[];
}

export interface Seating_MakeIntervalSeating_Payload {
  eventId: number;
  step: number;
}

export interface Seating_MakePrescriptedSeating_Payload {
  eventId: number;
  randomizeAtTables: boolean;
}

export interface Seating_GetNextPrescriptedSeating_Response {
  tables: atoms.PrescriptedTable[];
}

export interface Events_GetPrescriptedEventConfig_Response {
  eventId: number;
  nextSessionIndex: number;
  prescript?: string | null | undefined;
  errors: string[];
}

export interface Events_UpdatePrescriptedEventConfig_Payload {
  eventId: number;
  nextSessionIndex: number;
  prescript: string;
}

export interface Events_GetStartingTimer_Response {
  timer: number;
}

export interface Misc_AddErrorLog_Payload {
  facility: string;
  sessionHash: string;
  playerId: number;
  error: string;
  stack: string;
}

//========================================//
//         Mimir Protobuf Client          //
//========================================//

export async function GetRulesets(
  events_GetRulesets_Payload: Events_GetRulesets_Payload,
  config?: ClientConfiguration
): Promise<Events_GetRulesets_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetRulesets",
    Events_GetRulesets_Payload.encode(events_GetRulesets_Payload),
    config
  );
  return Events_GetRulesets_Response.decode(response);
}

export async function GetTimezones(
  events_GetTimezones_Payload: Events_GetTimezones_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTimezones_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetTimezones",
    Events_GetTimezones_Payload.encode(events_GetTimezones_Payload),
    config
  );
  return Events_GetTimezones_Response.decode(response);
}

export async function GetCountries(
  events_GetCountries_Payload: Events_GetCountries_Payload,
  config?: ClientConfiguration
): Promise<Events_GetCountries_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetCountries",
    Events_GetCountries_Payload.encode(events_GetCountries_Payload),
    config
  );
  return Events_GetCountries_Response.decode(response);
}

export async function GetEvents(
  events_GetEvents_Payload: Events_GetEvents_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEvents_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetEvents",
    Events_GetEvents_Payload.encode(events_GetEvents_Payload),
    config
  );
  return Events_GetEvents_Response.decode(response);
}

export async function GetEventsById(
  events_GetEventsById_Payload: Events_GetEventsById_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEventsById_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetEventsById",
    Events_GetEventsById_Payload.encode(events_GetEventsById_Payload),
    config
  );
  return Events_GetEventsById_Response.decode(response);
}

export async function GetMyEvents(
  players_GetMyEvents_Payload: Players_GetMyEvents_Payload,
  config?: ClientConfiguration
): Promise<Players_GetMyEvents_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetMyEvents",
    Players_GetMyEvents_Payload.encode(players_GetMyEvents_Payload),
    config
  );
  return Players_GetMyEvents_Response.decode(response);
}

export async function GetGameConfig(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.GameConfig> {
  const response = await PBrequest(
    "/Common.Mimir/GetGameConfig",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.GameConfig.decode(response);
}

export async function GetRatingTable(
  events_GetRatingTable_Payload: Events_GetRatingTable_Payload,
  config?: ClientConfiguration
): Promise<Events_GetRatingTable_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetRatingTable",
    Events_GetRatingTable_Payload.encode(events_GetRatingTable_Payload),
    config
  );
  return Events_GetRatingTable_Response.decode(response);
}

export async function GetLastGames(
  events_GetLastGames_Payload: Events_GetLastGames_Payload,
  config?: ClientConfiguration
): Promise<Events_GetLastGames_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetLastGames",
    Events_GetLastGames_Payload.encode(events_GetLastGames_Payload),
    config
  );
  return Events_GetLastGames_Response.decode(response);
}

export async function GetGame(
  events_GetGame_Payload: Events_GetGame_Payload,
  config?: ClientConfiguration
): Promise<Events_GetGame_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetGame",
    Events_GetGame_Payload.encode(events_GetGame_Payload),
    config
  );
  return Events_GetGame_Response.decode(response);
}

export async function GetGamesSeries(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetGamesSeries_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetGamesSeries",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetGamesSeries_Response.decode(response);
}

export async function GetCurrentSessions(
  players_GetCurrentSessions_Payload: Players_GetCurrentSessions_Payload,
  config?: ClientConfiguration
): Promise<Players_GetCurrentSessions_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetCurrentSessions",
    Players_GetCurrentSessions_Payload.encode(
      players_GetCurrentSessions_Payload
    ),
    config
  );
  return Players_GetCurrentSessions_Response.decode(response);
}

export async function GetAllRegisteredPlayers(
  events_GetAllRegisteredPlayers_Payload: Events_GetAllRegisteredPlayers_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAllRegisteredPlayers_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetAllRegisteredPlayers",
    Events_GetAllRegisteredPlayers_Payload.encode(
      events_GetAllRegisteredPlayers_Payload
    ),
    config
  );
  return Events_GetAllRegisteredPlayers_Response.decode(response);
}

export async function GetTimerState(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTimerState_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetTimerState",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetTimerState_Response.decode(response);
}

export async function GetSessionOverview(
  games_GetSessionOverview_Payload: Games_GetSessionOverview_Payload,
  config?: ClientConfiguration
): Promise<Games_GetSessionOverview_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetSessionOverview",
    Games_GetSessionOverview_Payload.encode(games_GetSessionOverview_Payload),
    config
  );
  return Games_GetSessionOverview_Response.decode(response);
}

export async function GetPlayerStats(
  players_GetPlayerStats_Payload: Players_GetPlayerStats_Payload,
  config?: ClientConfiguration
): Promise<Players_GetPlayerStats_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetPlayerStats",
    Players_GetPlayerStats_Payload.encode(players_GetPlayerStats_Payload),
    config
  );
  return Players_GetPlayerStats_Response.decode(response);
}

export async function AddRound(
  games_AddRound_Payload: Games_AddRound_Payload,
  config?: ClientConfiguration
): Promise<Games_AddRound_Response> {
  const response = await PBrequest(
    "/Common.Mimir/AddRound",
    Games_AddRound_Payload.encode(games_AddRound_Payload),
    config
  );
  return Games_AddRound_Response.decode(response);
}

export async function PreviewRound(
  games_PreviewRound_Payload: Games_PreviewRound_Payload,
  config?: ClientConfiguration
): Promise<Games_PreviewRound_Response> {
  const response = await PBrequest(
    "/Common.Mimir/PreviewRound",
    Games_PreviewRound_Payload.encode(games_PreviewRound_Payload),
    config
  );
  return Games_PreviewRound_Response.decode(response);
}

export async function AddOnlineReplay(
  games_AddOnlineReplay_Payload: Games_AddOnlineReplay_Payload,
  config?: ClientConfiguration
): Promise<Games_AddOnlineReplay_Response> {
  const response = await PBrequest(
    "/Common.Mimir/AddOnlineReplay",
    Games_AddOnlineReplay_Payload.encode(games_AddOnlineReplay_Payload),
    config
  );
  return Games_AddOnlineReplay_Response.decode(response);
}

export async function GetLastResults(
  players_GetLastResults_Payload: Players_GetLastResults_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastResults_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetLastResults",
    Players_GetLastResults_Payload.encode(players_GetLastResults_Payload),
    config
  );
  return Players_GetLastResults_Response.decode(response);
}

export async function GetLastRound(
  players_GetLastRound_Payload: Players_GetLastRound_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastRound_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetLastRound",
    Players_GetLastRound_Payload.encode(players_GetLastRound_Payload),
    config
  );
  return Players_GetLastRound_Response.decode(response);
}

export async function GetAllRounds(
  players_GetAllRounds_Payload: Players_GetAllRounds_Payload,
  config?: ClientConfiguration
): Promise<Players_GetAllRounds_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetAllRounds",
    Players_GetAllRounds_Payload.encode(players_GetAllRounds_Payload),
    config
  );
  return Players_GetAllRounds_Response.decode(response);
}

export async function GetLastRoundByHash(
  players_GetLastRoundByHash_Payload: Players_GetLastRoundByHash_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastRoundByHash_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetLastRoundByHash",
    Players_GetLastRoundByHash_Payload.encode(
      players_GetLastRoundByHash_Payload
    ),
    config
  );
  return Players_GetLastRoundByHash_Response.decode(response);
}

export async function GetEventForEdit(
  events_GetEventForEdit_Payload: Events_GetEventForEdit_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEventForEdit_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetEventForEdit",
    Events_GetEventForEdit_Payload.encode(events_GetEventForEdit_Payload),
    config
  );
  return Events_GetEventForEdit_Response.decode(response);
}

export async function RebuildScoring(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/RebuildScoring",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function CreateEvent(
  eventData: atoms.EventData,
  config?: ClientConfiguration
): Promise<atoms.Generic_Event_Payload> {
  const response = await PBrequest(
    "/Common.Mimir/CreateEvent",
    atoms.EventData.encode(eventData),
    config
  );
  return atoms.Generic_Event_Payload.decode(response);
}

export async function UpdateEvent(
  events_UpdateEvent_Payload: Events_UpdateEvent_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdateEvent",
    Events_UpdateEvent_Payload.encode(events_UpdateEvent_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function FinishEvent(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/FinishEvent",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function ToggleListed(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/ToggleListed",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function GetTablesState(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTablesState_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetTablesState",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetTablesState_Response.decode(response);
}

export async function StartTimer(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/StartTimer",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function RegisterPlayer(
  events_RegisterPlayer_Payload: Events_RegisterPlayer_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/RegisterPlayer",
    Events_RegisterPlayer_Payload.encode(events_RegisterPlayer_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function UnregisterPlayer(
  events_UnregisterPlayer_Payload: Events_UnregisterPlayer_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UnregisterPlayer",
    Events_UnregisterPlayer_Payload.encode(events_UnregisterPlayer_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function UpdatePlayerSeatingFlag(
  events_UpdatePlayerSeatingFlag_Payload: Events_UpdatePlayerSeatingFlag_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdatePlayerSeatingFlag",
    Events_UpdatePlayerSeatingFlag_Payload.encode(
      events_UpdatePlayerSeatingFlag_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function GetAchievements(
  events_GetAchievements_Payload: Events_GetAchievements_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAchievements_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetAchievements",
    Events_GetAchievements_Payload.encode(events_GetAchievements_Payload),
    config
  );
  return Events_GetAchievements_Response.decode(response);
}

export async function GetAchievementsList(
  events_GetAchievementsList_Payload: Events_GetAchievementsList_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAchievementsList_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetAchievementsList",
    Events_GetAchievementsList_Payload.encode(
      events_GetAchievementsList_Payload
    ),
    config
  );
  return Events_GetAchievementsList_Response.decode(response);
}

export async function ToggleHideResults(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/ToggleHideResults",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function UpdatePlayersLocalIds(
  events_UpdatePlayersLocalIds_Payload: Events_UpdatePlayersLocalIds_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdatePlayersLocalIds",
    Events_UpdatePlayersLocalIds_Payload.encode(
      events_UpdatePlayersLocalIds_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function UpdatePlayerReplacement(
  events_UpdatePlayerReplacement_Payload: Events_UpdatePlayerReplacement_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdatePlayerReplacement",
    Events_UpdatePlayerReplacement_Payload.encode(
      events_UpdatePlayerReplacement_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function UpdatePlayersTeams(
  events_UpdatePlayersTeams_Payload: Events_UpdatePlayersTeams_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdatePlayersTeams",
    Events_UpdatePlayersTeams_Payload.encode(events_UpdatePlayersTeams_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function StartGame(
  games_StartGame_Payload: Games_StartGame_Payload,
  config?: ClientConfiguration
): Promise<Games_StartGame_Response> {
  const response = await PBrequest(
    "/Common.Mimir/StartGame",
    Games_StartGame_Payload.encode(games_StartGame_Payload),
    config
  );
  return Games_StartGame_Response.decode(response);
}

export async function EndGame(
  games_EndGame_Payload: Games_EndGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/EndGame",
    Games_EndGame_Payload.encode(games_EndGame_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function CancelGame(
  games_CancelGame_Payload: Games_CancelGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/CancelGame",
    Games_CancelGame_Payload.encode(games_CancelGame_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function FinalizeSession(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/FinalizeSession",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function DropLastRound(
  games_DropLastRound_Payload: Games_DropLastRound_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/DropLastRound",
    Games_DropLastRound_Payload.encode(games_DropLastRound_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function DefinalizeGame(
  games_DefinalizeGame_Payload: Games_DefinalizeGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/DefinalizeGame",
    Games_DefinalizeGame_Payload.encode(games_DefinalizeGame_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function AddPenalty(
  games_AddPenalty_Payload: Games_AddPenalty_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/AddPenalty",
    Games_AddPenalty_Payload.encode(games_AddPenalty_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function AddPenaltyGame(
  games_AddPenaltyGame_Payload: Games_AddPenaltyGame_Payload,
  config?: ClientConfiguration
): Promise<Games_AddPenaltyGame_Response> {
  const response = await PBrequest(
    "/Common.Mimir/AddPenaltyGame",
    Games_AddPenaltyGame_Payload.encode(games_AddPenaltyGame_Payload),
    config
  );
  return Games_AddPenaltyGame_Response.decode(response);
}

export async function GetPlayer(
  players_GetPlayer_Payload: Players_GetPlayer_Payload,
  config?: ClientConfiguration
): Promise<Players_GetPlayer_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetPlayer",
    Players_GetPlayer_Payload.encode(players_GetPlayer_Payload),
    config
  );
  return Players_GetPlayer_Response.decode(response);
}

export async function GetCurrentSeating(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetCurrentSeating_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetCurrentSeating",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetCurrentSeating_Response.decode(response);
}

export async function MakeShuffledSeating(
  seating_MakeShuffledSeating_Payload: Seating_MakeShuffledSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/MakeShuffledSeating",
    Seating_MakeShuffledSeating_Payload.encode(
      seating_MakeShuffledSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function MakeSwissSeating(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/MakeSwissSeating",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function ResetSeating(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/ResetSeating",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function GenerateSwissSeating(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Seating_GenerateSwissSeating_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GenerateSwissSeating",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Seating_GenerateSwissSeating_Response.decode(response);
}

export async function MakeIntervalSeating(
  seating_MakeIntervalSeating_Payload: Seating_MakeIntervalSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/MakeIntervalSeating",
    Seating_MakeIntervalSeating_Payload.encode(
      seating_MakeIntervalSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function MakePrescriptedSeating(
  seating_MakePrescriptedSeating_Payload: Seating_MakePrescriptedSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/MakePrescriptedSeating",
    Seating_MakePrescriptedSeating_Payload.encode(
      seating_MakePrescriptedSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function GetNextPrescriptedSeating(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Seating_GetNextPrescriptedSeating_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetNextPrescriptedSeating",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Seating_GetNextPrescriptedSeating_Response.decode(response);
}

export async function GetPrescriptedEventConfig(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetPrescriptedEventConfig_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetPrescriptedEventConfig",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetPrescriptedEventConfig_Response.decode(response);
}

export async function UpdatePrescriptedEventConfig(
  events_UpdatePrescriptedEventConfig_Payload: Events_UpdatePrescriptedEventConfig_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/UpdatePrescriptedEventConfig",
    Events_UpdatePrescriptedEventConfig_Payload.encode(
      events_UpdatePrescriptedEventConfig_Payload
    ),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function InitStartingTimer(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/InitStartingTimer",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

export async function GetStartingTimer(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetStartingTimer_Response> {
  const response = await PBrequest(
    "/Common.Mimir/GetStartingTimer",
    atoms.Generic_Event_Payload.encode(generic_Event_Payload),
    config
  );
  return Events_GetStartingTimer_Response.decode(response);
}

export async function AddErrorLog(
  misc_AddErrorLog_Payload: Misc_AddErrorLog_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await PBrequest(
    "/Common.Mimir/AddErrorLog",
    Misc_AddErrorLog_Payload.encode(misc_AddErrorLog_Payload),
    config
  );
  return atoms.Generic_Success_Response.decode(response);
}

//========================================//
//           Mimir JSON Client            //
//========================================//

export async function GetRulesetsJSON(
  events_GetRulesets_Payload: Events_GetRulesets_Payload,
  config?: ClientConfiguration
): Promise<Events_GetRulesets_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetRulesets",
    Events_GetRulesets_PayloadJSON.encode(events_GetRulesets_Payload),
    config
  );
  return Events_GetRulesets_ResponseJSON.decode(response);
}

export async function GetTimezonesJSON(
  events_GetTimezones_Payload: Events_GetTimezones_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTimezones_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetTimezones",
    Events_GetTimezones_PayloadJSON.encode(events_GetTimezones_Payload),
    config
  );
  return Events_GetTimezones_ResponseJSON.decode(response);
}

export async function GetCountriesJSON(
  events_GetCountries_Payload: Events_GetCountries_Payload,
  config?: ClientConfiguration
): Promise<Events_GetCountries_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetCountries",
    Events_GetCountries_PayloadJSON.encode(events_GetCountries_Payload),
    config
  );
  return Events_GetCountries_ResponseJSON.decode(response);
}

export async function GetEventsJSON(
  events_GetEvents_Payload: Events_GetEvents_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEvents_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetEvents",
    Events_GetEvents_PayloadJSON.encode(events_GetEvents_Payload),
    config
  );
  return Events_GetEvents_ResponseJSON.decode(response);
}

export async function GetEventsByIdJSON(
  events_GetEventsById_Payload: Events_GetEventsById_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEventsById_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetEventsById",
    Events_GetEventsById_PayloadJSON.encode(events_GetEventsById_Payload),
    config
  );
  return Events_GetEventsById_ResponseJSON.decode(response);
}

export async function GetMyEventsJSON(
  players_GetMyEvents_Payload: Players_GetMyEvents_Payload,
  config?: ClientConfiguration
): Promise<Players_GetMyEvents_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetMyEvents",
    Players_GetMyEvents_PayloadJSON.encode(players_GetMyEvents_Payload),
    config
  );
  return Players_GetMyEvents_ResponseJSON.decode(response);
}

export async function GetGameConfigJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.GameConfig> {
  const response = await JSONrequest(
    "/Common.Mimir/GetGameConfig",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.GameConfigJSON.decode(response);
}

export async function GetRatingTableJSON(
  events_GetRatingTable_Payload: Events_GetRatingTable_Payload,
  config?: ClientConfiguration
): Promise<Events_GetRatingTable_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetRatingTable",
    Events_GetRatingTable_PayloadJSON.encode(events_GetRatingTable_Payload),
    config
  );
  return Events_GetRatingTable_ResponseJSON.decode(response);
}

export async function GetLastGamesJSON(
  events_GetLastGames_Payload: Events_GetLastGames_Payload,
  config?: ClientConfiguration
): Promise<Events_GetLastGames_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetLastGames",
    Events_GetLastGames_PayloadJSON.encode(events_GetLastGames_Payload),
    config
  );
  return Events_GetLastGames_ResponseJSON.decode(response);
}

export async function GetGameJSON(
  events_GetGame_Payload: Events_GetGame_Payload,
  config?: ClientConfiguration
): Promise<Events_GetGame_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetGame",
    Events_GetGame_PayloadJSON.encode(events_GetGame_Payload),
    config
  );
  return Events_GetGame_ResponseJSON.decode(response);
}

export async function GetGamesSeriesJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetGamesSeries_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetGamesSeries",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetGamesSeries_ResponseJSON.decode(response);
}

export async function GetCurrentSessionsJSON(
  players_GetCurrentSessions_Payload: Players_GetCurrentSessions_Payload,
  config?: ClientConfiguration
): Promise<Players_GetCurrentSessions_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetCurrentSessions",
    Players_GetCurrentSessions_PayloadJSON.encode(
      players_GetCurrentSessions_Payload
    ),
    config
  );
  return Players_GetCurrentSessions_ResponseJSON.decode(response);
}

export async function GetAllRegisteredPlayersJSON(
  events_GetAllRegisteredPlayers_Payload: Events_GetAllRegisteredPlayers_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAllRegisteredPlayers_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetAllRegisteredPlayers",
    Events_GetAllRegisteredPlayers_PayloadJSON.encode(
      events_GetAllRegisteredPlayers_Payload
    ),
    config
  );
  return Events_GetAllRegisteredPlayers_ResponseJSON.decode(response);
}

export async function GetTimerStateJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTimerState_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetTimerState",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetTimerState_ResponseJSON.decode(response);
}

export async function GetSessionOverviewJSON(
  games_GetSessionOverview_Payload: Games_GetSessionOverview_Payload,
  config?: ClientConfiguration
): Promise<Games_GetSessionOverview_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetSessionOverview",
    Games_GetSessionOverview_PayloadJSON.encode(
      games_GetSessionOverview_Payload
    ),
    config
  );
  return Games_GetSessionOverview_ResponseJSON.decode(response);
}

export async function GetPlayerStatsJSON(
  players_GetPlayerStats_Payload: Players_GetPlayerStats_Payload,
  config?: ClientConfiguration
): Promise<Players_GetPlayerStats_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetPlayerStats",
    Players_GetPlayerStats_PayloadJSON.encode(players_GetPlayerStats_Payload),
    config
  );
  return Players_GetPlayerStats_ResponseJSON.decode(response);
}

export async function AddRoundJSON(
  games_AddRound_Payload: Games_AddRound_Payload,
  config?: ClientConfiguration
): Promise<Games_AddRound_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/AddRound",
    Games_AddRound_PayloadJSON.encode(games_AddRound_Payload),
    config
  );
  return Games_AddRound_ResponseJSON.decode(response);
}

export async function PreviewRoundJSON(
  games_PreviewRound_Payload: Games_PreviewRound_Payload,
  config?: ClientConfiguration
): Promise<Games_PreviewRound_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/PreviewRound",
    Games_PreviewRound_PayloadJSON.encode(games_PreviewRound_Payload),
    config
  );
  return Games_PreviewRound_ResponseJSON.decode(response);
}

export async function AddOnlineReplayJSON(
  games_AddOnlineReplay_Payload: Games_AddOnlineReplay_Payload,
  config?: ClientConfiguration
): Promise<Games_AddOnlineReplay_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/AddOnlineReplay",
    Games_AddOnlineReplay_PayloadJSON.encode(games_AddOnlineReplay_Payload),
    config
  );
  return Games_AddOnlineReplay_ResponseJSON.decode(response);
}

export async function GetLastResultsJSON(
  players_GetLastResults_Payload: Players_GetLastResults_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastResults_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetLastResults",
    Players_GetLastResults_PayloadJSON.encode(players_GetLastResults_Payload),
    config
  );
  return Players_GetLastResults_ResponseJSON.decode(response);
}

export async function GetLastRoundJSON(
  players_GetLastRound_Payload: Players_GetLastRound_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastRound_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetLastRound",
    Players_GetLastRound_PayloadJSON.encode(players_GetLastRound_Payload),
    config
  );
  return Players_GetLastRound_ResponseJSON.decode(response);
}

export async function GetAllRoundsJSON(
  players_GetAllRounds_Payload: Players_GetAllRounds_Payload,
  config?: ClientConfiguration
): Promise<Players_GetAllRounds_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetAllRounds",
    Players_GetAllRounds_PayloadJSON.encode(players_GetAllRounds_Payload),
    config
  );
  return Players_GetAllRounds_ResponseJSON.decode(response);
}

export async function GetLastRoundByHashJSON(
  players_GetLastRoundByHash_Payload: Players_GetLastRoundByHash_Payload,
  config?: ClientConfiguration
): Promise<Players_GetLastRoundByHash_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetLastRoundByHash",
    Players_GetLastRoundByHash_PayloadJSON.encode(
      players_GetLastRoundByHash_Payload
    ),
    config
  );
  return Players_GetLastRoundByHash_ResponseJSON.decode(response);
}

export async function GetEventForEditJSON(
  events_GetEventForEdit_Payload: Events_GetEventForEdit_Payload,
  config?: ClientConfiguration
): Promise<Events_GetEventForEdit_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetEventForEdit",
    Events_GetEventForEdit_PayloadJSON.encode(events_GetEventForEdit_Payload),
    config
  );
  return Events_GetEventForEdit_ResponseJSON.decode(response);
}

export async function RebuildScoringJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/RebuildScoring",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function CreateEventJSON(
  eventData: atoms.EventData,
  config?: ClientConfiguration
): Promise<atoms.Generic_Event_Payload> {
  const response = await JSONrequest(
    "/Common.Mimir/CreateEvent",
    atoms.EventDataJSON.encode(eventData),
    config
  );
  return atoms.Generic_Event_PayloadJSON.decode(response);
}

export async function UpdateEventJSON(
  events_UpdateEvent_Payload: Events_UpdateEvent_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdateEvent",
    Events_UpdateEvent_PayloadJSON.encode(events_UpdateEvent_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function FinishEventJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/FinishEvent",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function ToggleListedJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/ToggleListed",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function GetTablesStateJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetTablesState_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetTablesState",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetTablesState_ResponseJSON.decode(response);
}

export async function StartTimerJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/StartTimer",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function RegisterPlayerJSON(
  events_RegisterPlayer_Payload: Events_RegisterPlayer_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/RegisterPlayer",
    Events_RegisterPlayer_PayloadJSON.encode(events_RegisterPlayer_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function UnregisterPlayerJSON(
  events_UnregisterPlayer_Payload: Events_UnregisterPlayer_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UnregisterPlayer",
    Events_UnregisterPlayer_PayloadJSON.encode(events_UnregisterPlayer_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function UpdatePlayerSeatingFlagJSON(
  events_UpdatePlayerSeatingFlag_Payload: Events_UpdatePlayerSeatingFlag_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdatePlayerSeatingFlag",
    Events_UpdatePlayerSeatingFlag_PayloadJSON.encode(
      events_UpdatePlayerSeatingFlag_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function GetAchievementsJSON(
  events_GetAchievements_Payload: Events_GetAchievements_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAchievements_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetAchievements",
    Events_GetAchievements_PayloadJSON.encode(events_GetAchievements_Payload),
    config
  );
  return Events_GetAchievements_ResponseJSON.decode(response);
}

export async function GetAchievementsListJSON(
  events_GetAchievementsList_Payload: Events_GetAchievementsList_Payload,
  config?: ClientConfiguration
): Promise<Events_GetAchievementsList_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetAchievementsList",
    Events_GetAchievementsList_PayloadJSON.encode(
      events_GetAchievementsList_Payload
    ),
    config
  );
  return Events_GetAchievementsList_ResponseJSON.decode(response);
}

export async function ToggleHideResultsJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/ToggleHideResults",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function UpdatePlayersLocalIdsJSON(
  events_UpdatePlayersLocalIds_Payload: Events_UpdatePlayersLocalIds_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdatePlayersLocalIds",
    Events_UpdatePlayersLocalIds_PayloadJSON.encode(
      events_UpdatePlayersLocalIds_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function UpdatePlayerReplacementJSON(
  events_UpdatePlayerReplacement_Payload: Events_UpdatePlayerReplacement_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdatePlayerReplacement",
    Events_UpdatePlayerReplacement_PayloadJSON.encode(
      events_UpdatePlayerReplacement_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function UpdatePlayersTeamsJSON(
  events_UpdatePlayersTeams_Payload: Events_UpdatePlayersTeams_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdatePlayersTeams",
    Events_UpdatePlayersTeams_PayloadJSON.encode(
      events_UpdatePlayersTeams_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function StartGameJSON(
  games_StartGame_Payload: Games_StartGame_Payload,
  config?: ClientConfiguration
): Promise<Games_StartGame_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/StartGame",
    Games_StartGame_PayloadJSON.encode(games_StartGame_Payload),
    config
  );
  return Games_StartGame_ResponseJSON.decode(response);
}

export async function EndGameJSON(
  games_EndGame_Payload: Games_EndGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/EndGame",
    Games_EndGame_PayloadJSON.encode(games_EndGame_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function CancelGameJSON(
  games_CancelGame_Payload: Games_CancelGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/CancelGame",
    Games_CancelGame_PayloadJSON.encode(games_CancelGame_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function FinalizeSessionJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/FinalizeSession",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function DropLastRoundJSON(
  games_DropLastRound_Payload: Games_DropLastRound_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/DropLastRound",
    Games_DropLastRound_PayloadJSON.encode(games_DropLastRound_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function DefinalizeGameJSON(
  games_DefinalizeGame_Payload: Games_DefinalizeGame_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/DefinalizeGame",
    Games_DefinalizeGame_PayloadJSON.encode(games_DefinalizeGame_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function AddPenaltyJSON(
  games_AddPenalty_Payload: Games_AddPenalty_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/AddPenalty",
    Games_AddPenalty_PayloadJSON.encode(games_AddPenalty_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function AddPenaltyGameJSON(
  games_AddPenaltyGame_Payload: Games_AddPenaltyGame_Payload,
  config?: ClientConfiguration
): Promise<Games_AddPenaltyGame_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/AddPenaltyGame",
    Games_AddPenaltyGame_PayloadJSON.encode(games_AddPenaltyGame_Payload),
    config
  );
  return Games_AddPenaltyGame_ResponseJSON.decode(response);
}

export async function GetPlayerJSON(
  players_GetPlayer_Payload: Players_GetPlayer_Payload,
  config?: ClientConfiguration
): Promise<Players_GetPlayer_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetPlayer",
    Players_GetPlayer_PayloadJSON.encode(players_GetPlayer_Payload),
    config
  );
  return Players_GetPlayer_ResponseJSON.decode(response);
}

export async function GetCurrentSeatingJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetCurrentSeating_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetCurrentSeating",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetCurrentSeating_ResponseJSON.decode(response);
}

export async function MakeShuffledSeatingJSON(
  seating_MakeShuffledSeating_Payload: Seating_MakeShuffledSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/MakeShuffledSeating",
    Seating_MakeShuffledSeating_PayloadJSON.encode(
      seating_MakeShuffledSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function MakeSwissSeatingJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/MakeSwissSeating",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function ResetSeatingJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/ResetSeating",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function GenerateSwissSeatingJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Seating_GenerateSwissSeating_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GenerateSwissSeating",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Seating_GenerateSwissSeating_ResponseJSON.decode(response);
}

export async function MakeIntervalSeatingJSON(
  seating_MakeIntervalSeating_Payload: Seating_MakeIntervalSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/MakeIntervalSeating",
    Seating_MakeIntervalSeating_PayloadJSON.encode(
      seating_MakeIntervalSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function MakePrescriptedSeatingJSON(
  seating_MakePrescriptedSeating_Payload: Seating_MakePrescriptedSeating_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/MakePrescriptedSeating",
    Seating_MakePrescriptedSeating_PayloadJSON.encode(
      seating_MakePrescriptedSeating_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function GetNextPrescriptedSeatingJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Seating_GetNextPrescriptedSeating_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetNextPrescriptedSeating",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Seating_GetNextPrescriptedSeating_ResponseJSON.decode(response);
}

export async function GetPrescriptedEventConfigJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetPrescriptedEventConfig_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetPrescriptedEventConfig",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetPrescriptedEventConfig_ResponseJSON.decode(response);
}

export async function UpdatePrescriptedEventConfigJSON(
  events_UpdatePrescriptedEventConfig_Payload: Events_UpdatePrescriptedEventConfig_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/UpdatePrescriptedEventConfig",
    Events_UpdatePrescriptedEventConfig_PayloadJSON.encode(
      events_UpdatePrescriptedEventConfig_Payload
    ),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function InitStartingTimerJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/InitStartingTimer",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

export async function GetStartingTimerJSON(
  generic_Event_Payload: atoms.Generic_Event_Payload,
  config?: ClientConfiguration
): Promise<Events_GetStartingTimer_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/GetStartingTimer",
    atoms.Generic_Event_PayloadJSON.encode(generic_Event_Payload),
    config
  );
  return Events_GetStartingTimer_ResponseJSON.decode(response);
}

export async function AddErrorLogJSON(
  misc_AddErrorLog_Payload: Misc_AddErrorLog_Payload,
  config?: ClientConfiguration
): Promise<atoms.Generic_Success_Response> {
  const response = await JSONrequest(
    "/Common.Mimir/AddErrorLog",
    Misc_AddErrorLog_PayloadJSON.encode(misc_AddErrorLog_Payload),
    config
  );
  return atoms.Generic_Success_ResponseJSON.decode(response);
}

//========================================//
//                 Mimir                  //
//========================================//

export interface Mimir<Context = unknown> {
  GetRulesets: (
    events_GetRulesets_Payload: Events_GetRulesets_Payload,
    context: Context
  ) => Promise<Events_GetRulesets_Response> | Events_GetRulesets_Response;
  GetTimezones: (
    events_GetTimezones_Payload: Events_GetTimezones_Payload,
    context: Context
  ) => Promise<Events_GetTimezones_Response> | Events_GetTimezones_Response;
  GetCountries: (
    events_GetCountries_Payload: Events_GetCountries_Payload,
    context: Context
  ) => Promise<Events_GetCountries_Response> | Events_GetCountries_Response;
  GetEvents: (
    events_GetEvents_Payload: Events_GetEvents_Payload,
    context: Context
  ) => Promise<Events_GetEvents_Response> | Events_GetEvents_Response;
  GetEventsById: (
    events_GetEventsById_Payload: Events_GetEventsById_Payload,
    context: Context
  ) => Promise<Events_GetEventsById_Response> | Events_GetEventsById_Response;
  GetMyEvents: (
    players_GetMyEvents_Payload: Players_GetMyEvents_Payload,
    context: Context
  ) => Promise<Players_GetMyEvents_Response> | Players_GetMyEvents_Response;
  GetGameConfig: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.GameConfig> | atoms.GameConfig;
  GetRatingTable: (
    events_GetRatingTable_Payload: Events_GetRatingTable_Payload,
    context: Context
  ) => Promise<Events_GetRatingTable_Response> | Events_GetRatingTable_Response;
  GetLastGames: (
    events_GetLastGames_Payload: Events_GetLastGames_Payload,
    context: Context
  ) => Promise<Events_GetLastGames_Response> | Events_GetLastGames_Response;
  GetGame: (
    events_GetGame_Payload: Events_GetGame_Payload,
    context: Context
  ) => Promise<Events_GetGame_Response> | Events_GetGame_Response;
  GetGamesSeries: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<Events_GetGamesSeries_Response> | Events_GetGamesSeries_Response;
  GetCurrentSessions: (
    players_GetCurrentSessions_Payload: Players_GetCurrentSessions_Payload,
    context: Context
  ) =>
    | Promise<Players_GetCurrentSessions_Response>
    | Players_GetCurrentSessions_Response;
  GetAllRegisteredPlayers: (
    events_GetAllRegisteredPlayers_Payload: Events_GetAllRegisteredPlayers_Payload,
    context: Context
  ) =>
    | Promise<Events_GetAllRegisteredPlayers_Response>
    | Events_GetAllRegisteredPlayers_Response;
  GetTimerState: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<Events_GetTimerState_Response> | Events_GetTimerState_Response;
  GetSessionOverview: (
    games_GetSessionOverview_Payload: Games_GetSessionOverview_Payload,
    context: Context
  ) =>
    | Promise<Games_GetSessionOverview_Response>
    | Games_GetSessionOverview_Response;
  GetPlayerStats: (
    players_GetPlayerStats_Payload: Players_GetPlayerStats_Payload,
    context: Context
  ) =>
    | Promise<Players_GetPlayerStats_Response>
    | Players_GetPlayerStats_Response;
  AddRound: (
    games_AddRound_Payload: Games_AddRound_Payload,
    context: Context
  ) => Promise<Games_AddRound_Response> | Games_AddRound_Response;
  PreviewRound: (
    games_PreviewRound_Payload: Games_PreviewRound_Payload,
    context: Context
  ) => Promise<Games_PreviewRound_Response> | Games_PreviewRound_Response;
  AddOnlineReplay: (
    games_AddOnlineReplay_Payload: Games_AddOnlineReplay_Payload,
    context: Context
  ) => Promise<Games_AddOnlineReplay_Response> | Games_AddOnlineReplay_Response;
  GetLastResults: (
    players_GetLastResults_Payload: Players_GetLastResults_Payload,
    context: Context
  ) =>
    | Promise<Players_GetLastResults_Response>
    | Players_GetLastResults_Response;
  GetLastRound: (
    players_GetLastRound_Payload: Players_GetLastRound_Payload,
    context: Context
  ) => Promise<Players_GetLastRound_Response> | Players_GetLastRound_Response;
  GetAllRounds: (
    players_GetAllRounds_Payload: Players_GetAllRounds_Payload,
    context: Context
  ) => Promise<Players_GetAllRounds_Response> | Players_GetAllRounds_Response;
  GetLastRoundByHash: (
    players_GetLastRoundByHash_Payload: Players_GetLastRoundByHash_Payload,
    context: Context
  ) =>
    | Promise<Players_GetLastRoundByHash_Response>
    | Players_GetLastRoundByHash_Response;
  GetEventForEdit: (
    events_GetEventForEdit_Payload: Events_GetEventForEdit_Payload,
    context: Context
  ) =>
    | Promise<Events_GetEventForEdit_Response>
    | Events_GetEventForEdit_Response;
  RebuildScoring: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  CreateEvent: (
    eventData: atoms.EventData,
    context: Context
  ) => Promise<atoms.Generic_Event_Payload> | atoms.Generic_Event_Payload;
  UpdateEvent: (
    events_UpdateEvent_Payload: Events_UpdateEvent_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  FinishEvent: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  ToggleListed: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  GetTablesState: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<Events_GetTablesState_Response> | Events_GetTablesState_Response;
  StartTimer: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  RegisterPlayer: (
    events_RegisterPlayer_Payload: Events_RegisterPlayer_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  UnregisterPlayer: (
    events_UnregisterPlayer_Payload: Events_UnregisterPlayer_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  UpdatePlayerSeatingFlag: (
    events_UpdatePlayerSeatingFlag_Payload: Events_UpdatePlayerSeatingFlag_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  GetAchievements: (
    events_GetAchievements_Payload: Events_GetAchievements_Payload,
    context: Context
  ) =>
    | Promise<Events_GetAchievements_Response>
    | Events_GetAchievements_Response;
  GetAchievementsList: (
    events_GetAchievementsList_Payload: Events_GetAchievementsList_Payload,
    context: Context
  ) =>
    | Promise<Events_GetAchievementsList_Response>
    | Events_GetAchievementsList_Response;
  ToggleHideResults: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  UpdatePlayersLocalIds: (
    events_UpdatePlayersLocalIds_Payload: Events_UpdatePlayersLocalIds_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  UpdatePlayerReplacement: (
    events_UpdatePlayerReplacement_Payload: Events_UpdatePlayerReplacement_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  UpdatePlayersTeams: (
    events_UpdatePlayersTeams_Payload: Events_UpdatePlayersTeams_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  StartGame: (
    games_StartGame_Payload: Games_StartGame_Payload,
    context: Context
  ) => Promise<Games_StartGame_Response> | Games_StartGame_Response;
  EndGame: (
    games_EndGame_Payload: Games_EndGame_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  CancelGame: (
    games_CancelGame_Payload: Games_CancelGame_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  FinalizeSession: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  DropLastRound: (
    games_DropLastRound_Payload: Games_DropLastRound_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  DefinalizeGame: (
    games_DefinalizeGame_Payload: Games_DefinalizeGame_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  AddPenalty: (
    games_AddPenalty_Payload: Games_AddPenalty_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  AddPenaltyGame: (
    games_AddPenaltyGame_Payload: Games_AddPenaltyGame_Payload,
    context: Context
  ) => Promise<Games_AddPenaltyGame_Response> | Games_AddPenaltyGame_Response;
  GetPlayer: (
    players_GetPlayer_Payload: Players_GetPlayer_Payload,
    context: Context
  ) => Promise<Players_GetPlayer_Response> | Players_GetPlayer_Response;
  GetCurrentSeating: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) =>
    | Promise<Events_GetCurrentSeating_Response>
    | Events_GetCurrentSeating_Response;
  MakeShuffledSeating: (
    seating_MakeShuffledSeating_Payload: Seating_MakeShuffledSeating_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  MakeSwissSeating: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  ResetSeating: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  GenerateSwissSeating: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) =>
    | Promise<Seating_GenerateSwissSeating_Response>
    | Seating_GenerateSwissSeating_Response;
  MakeIntervalSeating: (
    seating_MakeIntervalSeating_Payload: Seating_MakeIntervalSeating_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  MakePrescriptedSeating: (
    seating_MakePrescriptedSeating_Payload: Seating_MakePrescriptedSeating_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  GetNextPrescriptedSeating: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) =>
    | Promise<Seating_GetNextPrescriptedSeating_Response>
    | Seating_GetNextPrescriptedSeating_Response;
  GetPrescriptedEventConfig: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) =>
    | Promise<Events_GetPrescriptedEventConfig_Response>
    | Events_GetPrescriptedEventConfig_Response;
  UpdatePrescriptedEventConfig: (
    events_UpdatePrescriptedEventConfig_Payload: Events_UpdatePrescriptedEventConfig_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  InitStartingTimer: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
  GetStartingTimer: (
    generic_Event_Payload: atoms.Generic_Event_Payload,
    context: Context
  ) =>
    | Promise<Events_GetStartingTimer_Response>
    | Events_GetStartingTimer_Response;
  AddErrorLog: (
    misc_AddErrorLog_Payload: Misc_AddErrorLog_Payload,
    context: Context
  ) => Promise<atoms.Generic_Success_Response> | atoms.Generic_Success_Response;
}

export function createMimir<Context>(service: Mimir<Context>) {
  return {
    name: "Common.Mimir",
    methods: {
      GetRulesets: {
        name: "GetRulesets",
        handler: service.GetRulesets,
        input: {
          protobuf: Events_GetRulesets_Payload,
          json: Events_GetRulesets_PayloadJSON,
        },
        output: {
          protobuf: Events_GetRulesets_Response,
          json: Events_GetRulesets_ResponseJSON,
        },
      },
      GetTimezones: {
        name: "GetTimezones",
        handler: service.GetTimezones,
        input: {
          protobuf: Events_GetTimezones_Payload,
          json: Events_GetTimezones_PayloadJSON,
        },
        output: {
          protobuf: Events_GetTimezones_Response,
          json: Events_GetTimezones_ResponseJSON,
        },
      },
      GetCountries: {
        name: "GetCountries",
        handler: service.GetCountries,
        input: {
          protobuf: Events_GetCountries_Payload,
          json: Events_GetCountries_PayloadJSON,
        },
        output: {
          protobuf: Events_GetCountries_Response,
          json: Events_GetCountries_ResponseJSON,
        },
      },
      GetEvents: {
        name: "GetEvents",
        handler: service.GetEvents,
        input: {
          protobuf: Events_GetEvents_Payload,
          json: Events_GetEvents_PayloadJSON,
        },
        output: {
          protobuf: Events_GetEvents_Response,
          json: Events_GetEvents_ResponseJSON,
        },
      },
      GetEventsById: {
        name: "GetEventsById",
        handler: service.GetEventsById,
        input: {
          protobuf: Events_GetEventsById_Payload,
          json: Events_GetEventsById_PayloadJSON,
        },
        output: {
          protobuf: Events_GetEventsById_Response,
          json: Events_GetEventsById_ResponseJSON,
        },
      },
      GetMyEvents: {
        name: "GetMyEvents",
        handler: service.GetMyEvents,
        input: {
          protobuf: Players_GetMyEvents_Payload,
          json: Players_GetMyEvents_PayloadJSON,
        },
        output: {
          protobuf: Players_GetMyEvents_Response,
          json: Players_GetMyEvents_ResponseJSON,
        },
      },
      GetGameConfig: {
        name: "GetGameConfig",
        handler: service.GetGameConfig,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: { protobuf: atoms.GameConfig, json: atoms.GameConfigJSON },
      },
      GetRatingTable: {
        name: "GetRatingTable",
        handler: service.GetRatingTable,
        input: {
          protobuf: Events_GetRatingTable_Payload,
          json: Events_GetRatingTable_PayloadJSON,
        },
        output: {
          protobuf: Events_GetRatingTable_Response,
          json: Events_GetRatingTable_ResponseJSON,
        },
      },
      GetLastGames: {
        name: "GetLastGames",
        handler: service.GetLastGames,
        input: {
          protobuf: Events_GetLastGames_Payload,
          json: Events_GetLastGames_PayloadJSON,
        },
        output: {
          protobuf: Events_GetLastGames_Response,
          json: Events_GetLastGames_ResponseJSON,
        },
      },
      GetGame: {
        name: "GetGame",
        handler: service.GetGame,
        input: {
          protobuf: Events_GetGame_Payload,
          json: Events_GetGame_PayloadJSON,
        },
        output: {
          protobuf: Events_GetGame_Response,
          json: Events_GetGame_ResponseJSON,
        },
      },
      GetGamesSeries: {
        name: "GetGamesSeries",
        handler: service.GetGamesSeries,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetGamesSeries_Response,
          json: Events_GetGamesSeries_ResponseJSON,
        },
      },
      GetCurrentSessions: {
        name: "GetCurrentSessions",
        handler: service.GetCurrentSessions,
        input: {
          protobuf: Players_GetCurrentSessions_Payload,
          json: Players_GetCurrentSessions_PayloadJSON,
        },
        output: {
          protobuf: Players_GetCurrentSessions_Response,
          json: Players_GetCurrentSessions_ResponseJSON,
        },
      },
      GetAllRegisteredPlayers: {
        name: "GetAllRegisteredPlayers",
        handler: service.GetAllRegisteredPlayers,
        input: {
          protobuf: Events_GetAllRegisteredPlayers_Payload,
          json: Events_GetAllRegisteredPlayers_PayloadJSON,
        },
        output: {
          protobuf: Events_GetAllRegisteredPlayers_Response,
          json: Events_GetAllRegisteredPlayers_ResponseJSON,
        },
      },
      GetTimerState: {
        name: "GetTimerState",
        handler: service.GetTimerState,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetTimerState_Response,
          json: Events_GetTimerState_ResponseJSON,
        },
      },
      GetSessionOverview: {
        name: "GetSessionOverview",
        handler: service.GetSessionOverview,
        input: {
          protobuf: Games_GetSessionOverview_Payload,
          json: Games_GetSessionOverview_PayloadJSON,
        },
        output: {
          protobuf: Games_GetSessionOverview_Response,
          json: Games_GetSessionOverview_ResponseJSON,
        },
      },
      GetPlayerStats: {
        name: "GetPlayerStats",
        handler: service.GetPlayerStats,
        input: {
          protobuf: Players_GetPlayerStats_Payload,
          json: Players_GetPlayerStats_PayloadJSON,
        },
        output: {
          protobuf: Players_GetPlayerStats_Response,
          json: Players_GetPlayerStats_ResponseJSON,
        },
      },
      AddRound: {
        name: "AddRound",
        handler: service.AddRound,
        input: {
          protobuf: Games_AddRound_Payload,
          json: Games_AddRound_PayloadJSON,
        },
        output: {
          protobuf: Games_AddRound_Response,
          json: Games_AddRound_ResponseJSON,
        },
      },
      PreviewRound: {
        name: "PreviewRound",
        handler: service.PreviewRound,
        input: {
          protobuf: Games_PreviewRound_Payload,
          json: Games_PreviewRound_PayloadJSON,
        },
        output: {
          protobuf: Games_PreviewRound_Response,
          json: Games_PreviewRound_ResponseJSON,
        },
      },
      AddOnlineReplay: {
        name: "AddOnlineReplay",
        handler: service.AddOnlineReplay,
        input: {
          protobuf: Games_AddOnlineReplay_Payload,
          json: Games_AddOnlineReplay_PayloadJSON,
        },
        output: {
          protobuf: Games_AddOnlineReplay_Response,
          json: Games_AddOnlineReplay_ResponseJSON,
        },
      },
      GetLastResults: {
        name: "GetLastResults",
        handler: service.GetLastResults,
        input: {
          protobuf: Players_GetLastResults_Payload,
          json: Players_GetLastResults_PayloadJSON,
        },
        output: {
          protobuf: Players_GetLastResults_Response,
          json: Players_GetLastResults_ResponseJSON,
        },
      },
      GetLastRound: {
        name: "GetLastRound",
        handler: service.GetLastRound,
        input: {
          protobuf: Players_GetLastRound_Payload,
          json: Players_GetLastRound_PayloadJSON,
        },
        output: {
          protobuf: Players_GetLastRound_Response,
          json: Players_GetLastRound_ResponseJSON,
        },
      },
      GetAllRounds: {
        name: "GetAllRounds",
        handler: service.GetAllRounds,
        input: {
          protobuf: Players_GetAllRounds_Payload,
          json: Players_GetAllRounds_PayloadJSON,
        },
        output: {
          protobuf: Players_GetAllRounds_Response,
          json: Players_GetAllRounds_ResponseJSON,
        },
      },
      GetLastRoundByHash: {
        name: "GetLastRoundByHash",
        handler: service.GetLastRoundByHash,
        input: {
          protobuf: Players_GetLastRoundByHash_Payload,
          json: Players_GetLastRoundByHash_PayloadJSON,
        },
        output: {
          protobuf: Players_GetLastRoundByHash_Response,
          json: Players_GetLastRoundByHash_ResponseJSON,
        },
      },
      GetEventForEdit: {
        name: "GetEventForEdit",
        handler: service.GetEventForEdit,
        input: {
          protobuf: Events_GetEventForEdit_Payload,
          json: Events_GetEventForEdit_PayloadJSON,
        },
        output: {
          protobuf: Events_GetEventForEdit_Response,
          json: Events_GetEventForEdit_ResponseJSON,
        },
      },
      RebuildScoring: {
        name: "RebuildScoring",
        handler: service.RebuildScoring,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      CreateEvent: {
        name: "CreateEvent",
        handler: service.CreateEvent,
        input: { protobuf: atoms.EventData, json: atoms.EventDataJSON },
        output: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
      },
      UpdateEvent: {
        name: "UpdateEvent",
        handler: service.UpdateEvent,
        input: {
          protobuf: Events_UpdateEvent_Payload,
          json: Events_UpdateEvent_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      FinishEvent: {
        name: "FinishEvent",
        handler: service.FinishEvent,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      ToggleListed: {
        name: "ToggleListed",
        handler: service.ToggleListed,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      GetTablesState: {
        name: "GetTablesState",
        handler: service.GetTablesState,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetTablesState_Response,
          json: Events_GetTablesState_ResponseJSON,
        },
      },
      StartTimer: {
        name: "StartTimer",
        handler: service.StartTimer,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      RegisterPlayer: {
        name: "RegisterPlayer",
        handler: service.RegisterPlayer,
        input: {
          protobuf: Events_RegisterPlayer_Payload,
          json: Events_RegisterPlayer_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      UnregisterPlayer: {
        name: "UnregisterPlayer",
        handler: service.UnregisterPlayer,
        input: {
          protobuf: Events_UnregisterPlayer_Payload,
          json: Events_UnregisterPlayer_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      UpdatePlayerSeatingFlag: {
        name: "UpdatePlayerSeatingFlag",
        handler: service.UpdatePlayerSeatingFlag,
        input: {
          protobuf: Events_UpdatePlayerSeatingFlag_Payload,
          json: Events_UpdatePlayerSeatingFlag_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      GetAchievements: {
        name: "GetAchievements",
        handler: service.GetAchievements,
        input: {
          protobuf: Events_GetAchievements_Payload,
          json: Events_GetAchievements_PayloadJSON,
        },
        output: {
          protobuf: Events_GetAchievements_Response,
          json: Events_GetAchievements_ResponseJSON,
        },
      },
      GetAchievementsList: {
        name: "GetAchievementsList",
        handler: service.GetAchievementsList,
        input: {
          protobuf: Events_GetAchievementsList_Payload,
          json: Events_GetAchievementsList_PayloadJSON,
        },
        output: {
          protobuf: Events_GetAchievementsList_Response,
          json: Events_GetAchievementsList_ResponseJSON,
        },
      },
      ToggleHideResults: {
        name: "ToggleHideResults",
        handler: service.ToggleHideResults,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      UpdatePlayersLocalIds: {
        name: "UpdatePlayersLocalIds",
        handler: service.UpdatePlayersLocalIds,
        input: {
          protobuf: Events_UpdatePlayersLocalIds_Payload,
          json: Events_UpdatePlayersLocalIds_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      UpdatePlayerReplacement: {
        name: "UpdatePlayerReplacement",
        handler: service.UpdatePlayerReplacement,
        input: {
          protobuf: Events_UpdatePlayerReplacement_Payload,
          json: Events_UpdatePlayerReplacement_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      UpdatePlayersTeams: {
        name: "UpdatePlayersTeams",
        handler: service.UpdatePlayersTeams,
        input: {
          protobuf: Events_UpdatePlayersTeams_Payload,
          json: Events_UpdatePlayersTeams_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      StartGame: {
        name: "StartGame",
        handler: service.StartGame,
        input: {
          protobuf: Games_StartGame_Payload,
          json: Games_StartGame_PayloadJSON,
        },
        output: {
          protobuf: Games_StartGame_Response,
          json: Games_StartGame_ResponseJSON,
        },
      },
      EndGame: {
        name: "EndGame",
        handler: service.EndGame,
        input: {
          protobuf: Games_EndGame_Payload,
          json: Games_EndGame_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      CancelGame: {
        name: "CancelGame",
        handler: service.CancelGame,
        input: {
          protobuf: Games_CancelGame_Payload,
          json: Games_CancelGame_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      FinalizeSession: {
        name: "FinalizeSession",
        handler: service.FinalizeSession,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      DropLastRound: {
        name: "DropLastRound",
        handler: service.DropLastRound,
        input: {
          protobuf: Games_DropLastRound_Payload,
          json: Games_DropLastRound_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      DefinalizeGame: {
        name: "DefinalizeGame",
        handler: service.DefinalizeGame,
        input: {
          protobuf: Games_DefinalizeGame_Payload,
          json: Games_DefinalizeGame_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      AddPenalty: {
        name: "AddPenalty",
        handler: service.AddPenalty,
        input: {
          protobuf: Games_AddPenalty_Payload,
          json: Games_AddPenalty_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      AddPenaltyGame: {
        name: "AddPenaltyGame",
        handler: service.AddPenaltyGame,
        input: {
          protobuf: Games_AddPenaltyGame_Payload,
          json: Games_AddPenaltyGame_PayloadJSON,
        },
        output: {
          protobuf: Games_AddPenaltyGame_Response,
          json: Games_AddPenaltyGame_ResponseJSON,
        },
      },
      GetPlayer: {
        name: "GetPlayer",
        handler: service.GetPlayer,
        input: {
          protobuf: Players_GetPlayer_Payload,
          json: Players_GetPlayer_PayloadJSON,
        },
        output: {
          protobuf: Players_GetPlayer_Response,
          json: Players_GetPlayer_ResponseJSON,
        },
      },
      GetCurrentSeating: {
        name: "GetCurrentSeating",
        handler: service.GetCurrentSeating,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetCurrentSeating_Response,
          json: Events_GetCurrentSeating_ResponseJSON,
        },
      },
      MakeShuffledSeating: {
        name: "MakeShuffledSeating",
        handler: service.MakeShuffledSeating,
        input: {
          protobuf: Seating_MakeShuffledSeating_Payload,
          json: Seating_MakeShuffledSeating_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      MakeSwissSeating: {
        name: "MakeSwissSeating",
        handler: service.MakeSwissSeating,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      ResetSeating: {
        name: "ResetSeating",
        handler: service.ResetSeating,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      GenerateSwissSeating: {
        name: "GenerateSwissSeating",
        handler: service.GenerateSwissSeating,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Seating_GenerateSwissSeating_Response,
          json: Seating_GenerateSwissSeating_ResponseJSON,
        },
      },
      MakeIntervalSeating: {
        name: "MakeIntervalSeating",
        handler: service.MakeIntervalSeating,
        input: {
          protobuf: Seating_MakeIntervalSeating_Payload,
          json: Seating_MakeIntervalSeating_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      MakePrescriptedSeating: {
        name: "MakePrescriptedSeating",
        handler: service.MakePrescriptedSeating,
        input: {
          protobuf: Seating_MakePrescriptedSeating_Payload,
          json: Seating_MakePrescriptedSeating_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      GetNextPrescriptedSeating: {
        name: "GetNextPrescriptedSeating",
        handler: service.GetNextPrescriptedSeating,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Seating_GetNextPrescriptedSeating_Response,
          json: Seating_GetNextPrescriptedSeating_ResponseJSON,
        },
      },
      GetPrescriptedEventConfig: {
        name: "GetPrescriptedEventConfig",
        handler: service.GetPrescriptedEventConfig,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetPrescriptedEventConfig_Response,
          json: Events_GetPrescriptedEventConfig_ResponseJSON,
        },
      },
      UpdatePrescriptedEventConfig: {
        name: "UpdatePrescriptedEventConfig",
        handler: service.UpdatePrescriptedEventConfig,
        input: {
          protobuf: Events_UpdatePrescriptedEventConfig_Payload,
          json: Events_UpdatePrescriptedEventConfig_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      InitStartingTimer: {
        name: "InitStartingTimer",
        handler: service.InitStartingTimer,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
      GetStartingTimer: {
        name: "GetStartingTimer",
        handler: service.GetStartingTimer,
        input: {
          protobuf: atoms.Generic_Event_Payload,
          json: atoms.Generic_Event_PayloadJSON,
        },
        output: {
          protobuf: Events_GetStartingTimer_Response,
          json: Events_GetStartingTimer_ResponseJSON,
        },
      },
      AddErrorLog: {
        name: "AddErrorLog",
        handler: service.AddErrorLog,
        input: {
          protobuf: Misc_AddErrorLog_Payload,
          json: Misc_AddErrorLog_PayloadJSON,
        },
        output: {
          protobuf: atoms.Generic_Success_Response,
          json: atoms.Generic_Success_ResponseJSON,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Events_GetRulesets_Payload = {
  /**
   * Serializes Events_GetRulesets_Payload to protobuf.
   */
  encode: function (_msg?: Partial<Events_GetRulesets_Payload>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Events_GetRulesets_Payload from protobuf.
   */
  decode: function (_bytes?: ByteSource): Events_GetRulesets_Payload {
    return {};
  },

  /**
   * Initializes Events_GetRulesets_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetRulesets_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Events_GetRulesets_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: Events_GetRulesets_Payload,
    _reader: BinaryReader
  ): Events_GetRulesets_Payload {
    return _msg;
  },
};

export const Events_GetRulesets_Response = {
  /**
   * Serializes Events_GetRulesets_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetRulesets_Response>): Uint8Array {
    return Events_GetRulesets_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetRulesets_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetRulesets_Response {
    return Events_GetRulesets_Response._readMessage(
      Events_GetRulesets_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetRulesets_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetRulesets_Response {
    return {
      rulesets: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRulesets_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.rulesets?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.rulesets as any,
        atoms.RulesetGenerated._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRulesets_Response,
    reader: BinaryReader
  ): Events_GetRulesets_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.RulesetGenerated.initialize();
          reader.readMessage(m, atoms.RulesetGenerated._readMessage);
          msg.rulesets.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetTimezones_Payload = {
  /**
   * Serializes Events_GetTimezones_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetTimezones_Payload>): Uint8Array {
    return Events_GetTimezones_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetTimezones_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetTimezones_Payload {
    return Events_GetTimezones_Payload._readMessage(
      Events_GetTimezones_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetTimezones_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetTimezones_Payload {
    return {
      addr: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimezones_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.addr) {
      writer.writeString(1, msg.addr);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimezones_Payload,
    reader: BinaryReader
  ): Events_GetTimezones_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.addr = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetTimezones_Response = {
  /**
   * Serializes Events_GetTimezones_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetTimezones_Response>): Uint8Array {
    return Events_GetTimezones_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetTimezones_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetTimezones_Response {
    return Events_GetTimezones_Response._readMessage(
      Events_GetTimezones_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetTimezones_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTimezones_Response {
    return {
      preferredByIp: "",
      timezones: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimezones_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.preferredByIp) {
      writer.writeString(1, msg.preferredByIp);
    }
    if (msg.timezones?.length) {
      writer.writeRepeatedString(2, msg.timezones);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimezones_Response,
    reader: BinaryReader
  ): Events_GetTimezones_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.preferredByIp = reader.readString();
          break;
        }
        case 2: {
          msg.timezones.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetCountries_Payload = {
  /**
   * Serializes Events_GetCountries_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetCountries_Payload>): Uint8Array {
    return Events_GetCountries_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetCountries_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetCountries_Payload {
    return Events_GetCountries_Payload._readMessage(
      Events_GetCountries_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetCountries_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetCountries_Payload {
    return {
      addr: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCountries_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.addr) {
      writer.writeString(1, msg.addr);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCountries_Payload,
    reader: BinaryReader
  ): Events_GetCountries_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.addr = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetCountries_Response = {
  /**
   * Serializes Events_GetCountries_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetCountries_Response>): Uint8Array {
    return Events_GetCountries_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetCountries_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetCountries_Response {
    return Events_GetCountries_Response._readMessage(
      Events_GetCountries_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetCountries_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetCountries_Response {
    return {
      preferredByIp: "",
      countries: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCountries_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.preferredByIp) {
      writer.writeString(1, msg.preferredByIp);
    }
    if (msg.countries?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.countries as any,
        atoms.Country._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCountries_Response,
    reader: BinaryReader
  ): Events_GetCountries_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.preferredByIp = reader.readString();
          break;
        }
        case 2: {
          const m = atoms.Country.initialize();
          reader.readMessage(m, atoms.Country._readMessage);
          msg.countries.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEvents_Payload = {
  /**
   * Serializes Events_GetEvents_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetEvents_Payload>): Uint8Array {
    return Events_GetEvents_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEvents_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEvents_Payload {
    return Events_GetEvents_Payload._readMessage(
      Events_GetEvents_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEvents_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEvents_Payload {
    return {
      limit: 0,
      offset: 0,
      filterUnlisted: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEvents_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.limit) {
      writer.writeInt32(1, msg.limit);
    }
    if (msg.offset) {
      writer.writeInt32(2, msg.offset);
    }
    if (msg.filterUnlisted) {
      writer.writeBool(3, msg.filterUnlisted);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEvents_Payload,
    reader: BinaryReader
  ): Events_GetEvents_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.limit = reader.readInt32();
          break;
        }
        case 2: {
          msg.offset = reader.readInt32();
          break;
        }
        case 3: {
          msg.filterUnlisted = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEvents_Response = {
  /**
   * Serializes Events_GetEvents_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetEvents_Response>): Uint8Array {
    return Events_GetEvents_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEvents_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEvents_Response {
    return Events_GetEvents_Response._readMessage(
      Events_GetEvents_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEvents_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEvents_Response {
    return {
      total: 0,
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEvents_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.total) {
      writer.writeInt32(1, msg.total);
    }
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.events as any,
        atoms.Event._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEvents_Response,
    reader: BinaryReader
  ): Events_GetEvents_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.total = reader.readInt32();
          break;
        }
        case 2: {
          const m = atoms.Event.initialize();
          reader.readMessage(m, atoms.Event._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEventsById_Payload = {
  /**
   * Serializes Events_GetEventsById_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetEventsById_Payload>): Uint8Array {
    return Events_GetEventsById_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEventsById_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEventsById_Payload {
    return Events_GetEventsById_Payload._readMessage(
      Events_GetEventsById_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEventsById_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEventsById_Payload {
    return {
      ids: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventsById_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.ids?.length) {
      writer.writePackedInt32(1, msg.ids);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventsById_Payload,
    reader: BinaryReader
  ): Events_GetEventsById_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.ids.push(...reader.readPackedInt32());
          } else {
            msg.ids.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEventsById_Response = {
  /**
   * Serializes Events_GetEventsById_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetEventsById_Response>): Uint8Array {
    return Events_GetEventsById_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEventsById_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEventsById_Response {
    return Events_GetEventsById_Response._readMessage(
      Events_GetEventsById_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEventsById_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEventsById_Response {
    return {
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventsById_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.events as any,
        atoms.Event._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventsById_Response,
    reader: BinaryReader
  ): Events_GetEventsById_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.Event.initialize();
          reader.readMessage(m, atoms.Event._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetMyEvents_Payload = {
  /**
   * Serializes Players_GetMyEvents_Payload to protobuf.
   */
  encode: function (_msg?: Partial<Players_GetMyEvents_Payload>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Players_GetMyEvents_Payload from protobuf.
   */
  decode: function (_bytes?: ByteSource): Players_GetMyEvents_Payload {
    return {};
  },

  /**
   * Initializes Players_GetMyEvents_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetMyEvents_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Players_GetMyEvents_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: Players_GetMyEvents_Payload,
    _reader: BinaryReader
  ): Players_GetMyEvents_Payload {
    return _msg;
  },
};

export const Players_GetMyEvents_Response = {
  /**
   * Serializes Players_GetMyEvents_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetMyEvents_Response>): Uint8Array {
    return Players_GetMyEvents_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetMyEvents_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetMyEvents_Response {
    return Players_GetMyEvents_Response._readMessage(
      Players_GetMyEvents_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetMyEvents_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetMyEvents_Response {
    return {
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetMyEvents_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.events as any,
        atoms.MyEvent._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetMyEvents_Response,
    reader: BinaryReader
  ): Players_GetMyEvents_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.MyEvent.initialize();
          reader.readMessage(m, atoms.MyEvent._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetRatingTable_Payload = {
  /**
   * Serializes Events_GetRatingTable_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetRatingTable_Payload>): Uint8Array {
    return Events_GetRatingTable_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetRatingTable_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetRatingTable_Payload {
    return Events_GetRatingTable_Payload._readMessage(
      Events_GetRatingTable_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetRatingTable_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetRatingTable_Payload {
    return {
      eventIdList: [],
      orderBy: "",
      order: "",
      withPrefinished: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRatingTable_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(1, msg.eventIdList);
    }
    if (msg.orderBy) {
      writer.writeString(2, msg.orderBy);
    }
    if (msg.order) {
      writer.writeString(3, msg.order);
    }
    if (msg.withPrefinished) {
      writer.writeBool(4, msg.withPrefinished);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRatingTable_Payload,
    reader: BinaryReader
  ): Events_GetRatingTable_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          msg.orderBy = reader.readString();
          break;
        }
        case 3: {
          msg.order = reader.readString();
          break;
        }
        case 4: {
          msg.withPrefinished = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetRatingTable_Response = {
  /**
   * Serializes Events_GetRatingTable_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetRatingTable_Response>): Uint8Array {
    return Events_GetRatingTable_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetRatingTable_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetRatingTable_Response {
    return Events_GetRatingTable_Response._readMessage(
      Events_GetRatingTable_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetRatingTable_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetRatingTable_Response {
    return {
      list: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRatingTable_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.list?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.list as any,
        atoms.PlayerInRating._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRatingTable_Response,
    reader: BinaryReader
  ): Events_GetRatingTable_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.PlayerInRating.initialize();
          reader.readMessage(m, atoms.PlayerInRating._readMessage);
          msg.list.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetLastGames_Payload = {
  /**
   * Serializes Events_GetLastGames_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetLastGames_Payload>): Uint8Array {
    return Events_GetLastGames_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetLastGames_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetLastGames_Payload {
    return Events_GetLastGames_Payload._readMessage(
      Events_GetLastGames_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetLastGames_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetLastGames_Payload {
    return {
      eventIdList: [],
      limit: 0,
      offset: 0,
      orderBy: undefined,
      order: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetLastGames_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(1, msg.eventIdList);
    }
    if (msg.limit) {
      writer.writeInt32(2, msg.limit);
    }
    if (msg.offset) {
      writer.writeInt32(3, msg.offset);
    }
    if (msg.orderBy != undefined) {
      writer.writeString(4, msg.orderBy);
    }
    if (msg.order != undefined) {
      writer.writeString(5, msg.order);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetLastGames_Payload,
    reader: BinaryReader
  ): Events_GetLastGames_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          msg.limit = reader.readInt32();
          break;
        }
        case 3: {
          msg.offset = reader.readInt32();
          break;
        }
        case 4: {
          msg.orderBy = reader.readString();
          break;
        }
        case 5: {
          msg.order = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetLastGames_Response = {
  /**
   * Serializes Events_GetLastGames_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetLastGames_Response>): Uint8Array {
    return Events_GetLastGames_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetLastGames_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetLastGames_Response {
    return Events_GetLastGames_Response._readMessage(
      Events_GetLastGames_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetLastGames_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetLastGames_Response {
    return {
      games: [],
      players: [],
      totalGames: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetLastGames_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.games?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.games as any,
        atoms.GameResult._writeMessage
      );
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        atoms.Player._writeMessage
      );
    }
    if (msg.totalGames) {
      writer.writeInt32(3, msg.totalGames);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetLastGames_Response,
    reader: BinaryReader
  ): Events_GetLastGames_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.GameResult.initialize();
          reader.readMessage(m, atoms.GameResult._readMessage);
          msg.games.push(m);
          break;
        }
        case 2: {
          const m = atoms.Player.initialize();
          reader.readMessage(m, atoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        case 3: {
          msg.totalGames = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetGame_Payload = {
  /**
   * Serializes Events_GetGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetGame_Payload>): Uint8Array {
    return Events_GetGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetGame_Payload {
    return Events_GetGame_Payload._readMessage(
      Events_GetGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetGame_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGame_Payload,
    reader: BinaryReader
  ): Events_GetGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetGame_Response = {
  /**
   * Serializes Events_GetGame_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetGame_Response>): Uint8Array {
    return Events_GetGame_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetGame_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetGame_Response {
    return Events_GetGame_Response._readMessage(
      Events_GetGame_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetGame_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetGame_Response {
    return {
      game: atoms.GameResult.initialize(),
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGame_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.game) {
      writer.writeMessage(1, msg.game, atoms.GameResult._writeMessage);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        atoms.Player._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGame_Response,
    reader: BinaryReader
  ): Events_GetGame_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.game, atoms.GameResult._readMessage);
          break;
        }
        case 2: {
          const m = atoms.Player.initialize();
          reader.readMessage(m, atoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetGamesSeries_Response = {
  /**
   * Serializes Events_GetGamesSeries_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetGamesSeries_Response>): Uint8Array {
    return Events_GetGamesSeries_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetGamesSeries_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetGamesSeries_Response {
    return Events_GetGamesSeries_Response._readMessage(
      Events_GetGamesSeries_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetGamesSeries_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetGamesSeries_Response {
    return {
      results: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGamesSeries_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.results?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.results as any,
        atoms.SeriesResult._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGamesSeries_Response,
    reader: BinaryReader
  ): Events_GetGamesSeries_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.SeriesResult.initialize();
          reader.readMessage(m, atoms.SeriesResult._readMessage);
          msg.results.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetCurrentSessions_Payload = {
  /**
   * Serializes Players_GetCurrentSessions_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Players_GetCurrentSessions_Payload>
  ): Uint8Array {
    return Players_GetCurrentSessions_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetCurrentSessions_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetCurrentSessions_Payload {
    return Players_GetCurrentSessions_Payload._readMessage(
      Players_GetCurrentSessions_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetCurrentSessions_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetCurrentSessions_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetCurrentSessions_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetCurrentSessions_Payload,
    reader: BinaryReader
  ): Players_GetCurrentSessions_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetCurrentSessions_Response = {
  /**
   * Serializes Players_GetCurrentSessions_Response to protobuf.
   */
  encode: function (
    msg: Partial<Players_GetCurrentSessions_Response>
  ): Uint8Array {
    return Players_GetCurrentSessions_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetCurrentSessions_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetCurrentSessions_Response {
    return Players_GetCurrentSessions_Response._readMessage(
      Players_GetCurrentSessions_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetCurrentSessions_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetCurrentSessions_Response {
    return {
      sessions: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetCurrentSessions_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessions?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.sessions as any,
        atoms.CurrentSession._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetCurrentSessions_Response,
    reader: BinaryReader
  ): Players_GetCurrentSessions_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.CurrentSession.initialize();
          reader.readMessage(m, atoms.CurrentSession._readMessage);
          msg.sessions.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetAllRegisteredPlayers_Payload = {
  /**
   * Serializes Events_GetAllRegisteredPlayers_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Payload>
  ): Uint8Array {
    return Events_GetAllRegisteredPlayers_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetAllRegisteredPlayers_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetAllRegisteredPlayers_Payload {
    return Events_GetAllRegisteredPlayers_Payload._readMessage(
      Events_GetAllRegisteredPlayers_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetAllRegisteredPlayers_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAllRegisteredPlayers_Payload {
    return {
      eventIds: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventIds?.length) {
      writer.writePackedInt32(1, msg.eventIds);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAllRegisteredPlayers_Payload,
    reader: BinaryReader
  ): Events_GetAllRegisteredPlayers_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIds.push(...reader.readPackedInt32());
          } else {
            msg.eventIds.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetAllRegisteredPlayers_Response = {
  /**
   * Serializes Events_GetAllRegisteredPlayers_Response to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Response>
  ): Uint8Array {
    return Events_GetAllRegisteredPlayers_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetAllRegisteredPlayers_Response from protobuf.
   */
  decode: function (
    bytes: ByteSource
  ): Events_GetAllRegisteredPlayers_Response {
    return Events_GetAllRegisteredPlayers_Response._readMessage(
      Events_GetAllRegisteredPlayers_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetAllRegisteredPlayers_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAllRegisteredPlayers_Response {
    return {
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.players as any,
        atoms.RegisteredPlayer._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAllRegisteredPlayers_Response,
    reader: BinaryReader
  ): Events_GetAllRegisteredPlayers_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.RegisteredPlayer.initialize();
          reader.readMessage(m, atoms.RegisteredPlayer._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetTimerState_Response = {
  /**
   * Serializes Events_GetTimerState_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetTimerState_Response>): Uint8Array {
    return Events_GetTimerState_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetTimerState_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetTimerState_Response {
    return Events_GetTimerState_Response._readMessage(
      Events_GetTimerState_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetTimerState_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTimerState_Response {
    return {
      started: false,
      finished: false,
      timeRemaining: 0,
      waitingForTimer: false,
      haveAutostart: false,
      autostartTimer: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimerState_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.started) {
      writer.writeBool(1, msg.started);
    }
    if (msg.finished) {
      writer.writeBool(2, msg.finished);
    }
    if (msg.timeRemaining) {
      writer.writeInt32(3, msg.timeRemaining);
    }
    if (msg.waitingForTimer) {
      writer.writeBool(4, msg.waitingForTimer);
    }
    if (msg.haveAutostart) {
      writer.writeBool(5, msg.haveAutostart);
    }
    if (msg.autostartTimer) {
      writer.writeBool(6, msg.autostartTimer);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimerState_Response,
    reader: BinaryReader
  ): Events_GetTimerState_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.started = reader.readBool();
          break;
        }
        case 2: {
          msg.finished = reader.readBool();
          break;
        }
        case 3: {
          msg.timeRemaining = reader.readInt32();
          break;
        }
        case 4: {
          msg.waitingForTimer = reader.readBool();
          break;
        }
        case 5: {
          msg.haveAutostart = reader.readBool();
          break;
        }
        case 6: {
          msg.autostartTimer = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_GetSessionOverview_Payload = {
  /**
   * Serializes Games_GetSessionOverview_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Games_GetSessionOverview_Payload>
  ): Uint8Array {
    return Games_GetSessionOverview_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_GetSessionOverview_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_GetSessionOverview_Payload {
    return Games_GetSessionOverview_Payload._readMessage(
      Games_GetSessionOverview_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_GetSessionOverview_Payload with all fields set to their default value.
   */
  initialize: function (): Games_GetSessionOverview_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_GetSessionOverview_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_GetSessionOverview_Payload,
    reader: BinaryReader
  ): Games_GetSessionOverview_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_GetSessionOverview_Response = {
  /**
   * Serializes Games_GetSessionOverview_Response to protobuf.
   */
  encode: function (
    msg: Partial<Games_GetSessionOverview_Response>
  ): Uint8Array {
    return Games_GetSessionOverview_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_GetSessionOverview_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_GetSessionOverview_Response {
    return Games_GetSessionOverview_Response._readMessage(
      Games_GetSessionOverview_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_GetSessionOverview_Response with all fields set to their default value.
   */
  initialize: function (): Games_GetSessionOverview_Response {
    return {
      id: 0,
      eventId: 0,
      tableIndex: undefined,
      players: [],
      state: atoms.SessionState.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_GetSessionOverview_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.tableIndex != undefined) {
      writer.writeInt32(3, msg.tableIndex);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.players as any,
        atoms.PlayerInSession._writeMessage
      );
    }
    if (msg.state) {
      writer.writeMessage(5, msg.state, atoms.SessionState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_GetSessionOverview_Response,
    reader: BinaryReader
  ): Games_GetSessionOverview_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 4: {
          const m = atoms.PlayerInSession.initialize();
          reader.readMessage(m, atoms.PlayerInSession._readMessage);
          msg.players.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.state, atoms.SessionState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetPlayerStats_Payload = {
  /**
   * Serializes Players_GetPlayerStats_Payload to protobuf.
   */
  encode: function (msg: Partial<Players_GetPlayerStats_Payload>): Uint8Array {
    return Players_GetPlayerStats_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetPlayerStats_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetPlayerStats_Payload {
    return Players_GetPlayerStats_Payload._readMessage(
      Players_GetPlayerStats_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetPlayerStats_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayerStats_Payload {
    return {
      playerId: 0,
      eventIdList: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayerStats_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(2, msg.eventIdList);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayerStats_Payload,
    reader: BinaryReader
  ): Players_GetPlayerStats_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetPlayerStats_Response = {
  /**
   * Serializes Players_GetPlayerStats_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetPlayerStats_Response>): Uint8Array {
    return Players_GetPlayerStats_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetPlayerStats_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetPlayerStats_Response {
    return Players_GetPlayerStats_Response._readMessage(
      Players_GetPlayerStats_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetPlayerStats_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayerStats_Response {
    return {
      ratingHistory: [],
      scoreHistory: [],
      playersInfo: [],
      placesSummary: [],
      totalPlayedGames: 0,
      totalPlayedRounds: 0,
      winSummary: atoms.PlayerWinSummary.initialize(),
      handsValueSummary: [],
      yakuSummary: [],
      riichiSummary: atoms.RiichiSummary.initialize(),
      doraStat: atoms.DoraSummary.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayerStats_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.ratingHistory?.length) {
      writer.writePackedInt32(1, msg.ratingHistory);
    }
    if (msg.scoreHistory?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.scoreHistory as any,
        atoms.SessionHistoryResultTable._writeMessage
      );
    }
    if (msg.playersInfo?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.playersInfo as any,
        atoms.Player._writeMessage
      );
    }
    if (msg.placesSummary?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.placesSummary as any,
        atoms.PlacesSummaryItem._writeMessage
      );
    }
    if (msg.totalPlayedGames) {
      writer.writeInt32(5, msg.totalPlayedGames);
    }
    if (msg.totalPlayedRounds) {
      writer.writeInt32(6, msg.totalPlayedRounds);
    }
    if (msg.winSummary) {
      writer.writeMessage(
        7,
        msg.winSummary,
        atoms.PlayerWinSummary._writeMessage
      );
    }
    if (msg.handsValueSummary?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.handsValueSummary as any,
        atoms.HandValueStat._writeMessage
      );
    }
    if (msg.yakuSummary?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.yakuSummary as any,
        atoms.YakuStat._writeMessage
      );
    }
    if (msg.riichiSummary) {
      writer.writeMessage(
        10,
        msg.riichiSummary,
        atoms.RiichiSummary._writeMessage
      );
    }
    if (msg.doraStat) {
      writer.writeMessage(11, msg.doraStat, atoms.DoraSummary._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayerStats_Response,
    reader: BinaryReader
  ): Players_GetPlayerStats_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.ratingHistory.push(...reader.readPackedInt32());
          } else {
            msg.ratingHistory.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          const m = atoms.SessionHistoryResultTable.initialize();
          reader.readMessage(m, atoms.SessionHistoryResultTable._readMessage);
          msg.scoreHistory.push(m);
          break;
        }
        case 3: {
          const m = atoms.Player.initialize();
          reader.readMessage(m, atoms.Player._readMessage);
          msg.playersInfo.push(m);
          break;
        }
        case 4: {
          const m = atoms.PlacesSummaryItem.initialize();
          reader.readMessage(m, atoms.PlacesSummaryItem._readMessage);
          msg.placesSummary.push(m);
          break;
        }
        case 5: {
          msg.totalPlayedGames = reader.readInt32();
          break;
        }
        case 6: {
          msg.totalPlayedRounds = reader.readInt32();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.winSummary,
            atoms.PlayerWinSummary._readMessage
          );
          break;
        }
        case 8: {
          const m = atoms.HandValueStat.initialize();
          reader.readMessage(m, atoms.HandValueStat._readMessage);
          msg.handsValueSummary.push(m);
          break;
        }
        case 9: {
          const m = atoms.YakuStat.initialize();
          reader.readMessage(m, atoms.YakuStat._readMessage);
          msg.yakuSummary.push(m);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.riichiSummary,
            atoms.RiichiSummary._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(msg.doraStat, atoms.DoraSummary._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddRound_Payload = {
  /**
   * Serializes Games_AddRound_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_AddRound_Payload>): Uint8Array {
    return Games_AddRound_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddRound_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddRound_Payload {
    return Games_AddRound_Payload._readMessage(
      Games_AddRound_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddRound_Payload {
    return {
      sessionHash: "",
      roundData: atoms.Round.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddRound_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.roundData) {
      writer.writeMessage(2, msg.roundData, atoms.Round._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddRound_Payload,
    reader: BinaryReader
  ): Games_AddRound_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.roundData, atoms.Round._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddRound_Response = {
  /**
   * Serializes Games_AddRound_Response to protobuf.
   */
  encode: function (msg: Partial<Games_AddRound_Response>): Uint8Array {
    return Games_AddRound_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddRound_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddRound_Response {
    return Games_AddRound_Response._readMessage(
      Games_AddRound_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddRound_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddRound_Response {
    return {
      scores: [],
      extraPenaltyLog: [],
      round: 0,
      honba: 0,
      riichiBets: 0,
      prematurelyFinished: false,
      roundJustChanged: false,
      isFinished: false,
      yellowZoneAlreadyPlayed: false,
      lastOutcome: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddRound_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scores?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.scores as any,
        atoms.IntermediateResultOfSession._writeMessage
      );
    }
    if (msg.extraPenaltyLog?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.extraPenaltyLog as any,
        atoms.Penalty._writeMessage
      );
    }
    if (msg.round) {
      writer.writeInt32(3, msg.round);
    }
    if (msg.honba) {
      writer.writeInt32(4, msg.honba);
    }
    if (msg.riichiBets) {
      writer.writeInt32(5, msg.riichiBets);
    }
    if (msg.prematurelyFinished) {
      writer.writeBool(6, msg.prematurelyFinished);
    }
    if (msg.roundJustChanged) {
      writer.writeBool(7, msg.roundJustChanged);
    }
    if (msg.isFinished) {
      writer.writeBool(8, msg.isFinished);
    }
    if (msg.yellowZoneAlreadyPlayed) {
      writer.writeBool(9, msg.yellowZoneAlreadyPlayed);
    }
    if (msg.lastOutcome != undefined) {
      writer.writeEnum(10, atoms.RoundOutcome._toInt(msg.lastOutcome));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddRound_Response,
    reader: BinaryReader
  ): Games_AddRound_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.IntermediateResultOfSession.initialize();
          reader.readMessage(m, atoms.IntermediateResultOfSession._readMessage);
          msg.scores.push(m);
          break;
        }
        case 2: {
          const m = atoms.Penalty.initialize();
          reader.readMessage(m, atoms.Penalty._readMessage);
          msg.extraPenaltyLog.push(m);
          break;
        }
        case 3: {
          msg.round = reader.readInt32();
          break;
        }
        case 4: {
          msg.honba = reader.readInt32();
          break;
        }
        case 5: {
          msg.riichiBets = reader.readInt32();
          break;
        }
        case 6: {
          msg.prematurelyFinished = reader.readBool();
          break;
        }
        case 7: {
          msg.roundJustChanged = reader.readBool();
          break;
        }
        case 8: {
          msg.isFinished = reader.readBool();
          break;
        }
        case 9: {
          msg.yellowZoneAlreadyPlayed = reader.readBool();
          break;
        }
        case 10: {
          msg.lastOutcome = atoms.RoundOutcome._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_PreviewRound_Payload = {
  /**
   * Serializes Games_PreviewRound_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_PreviewRound_Payload>): Uint8Array {
    return Games_PreviewRound_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_PreviewRound_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_PreviewRound_Payload {
    return Games_PreviewRound_Payload._readMessage(
      Games_PreviewRound_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_PreviewRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_PreviewRound_Payload {
    return {
      sessionHash: "",
      roundData: atoms.Round.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_PreviewRound_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.roundData) {
      writer.writeMessage(2, msg.roundData, atoms.Round._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_PreviewRound_Payload,
    reader: BinaryReader
  ): Games_PreviewRound_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.roundData, atoms.Round._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_PreviewRound_Response = {
  /**
   * Serializes Games_PreviewRound_Response to protobuf.
   */
  encode: function (msg: Partial<Games_PreviewRound_Response>): Uint8Array {
    return Games_PreviewRound_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_PreviewRound_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_PreviewRound_Response {
    return Games_PreviewRound_Response._readMessage(
      Games_PreviewRound_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_PreviewRound_Response with all fields set to their default value.
   */
  initialize: function (): Games_PreviewRound_Response {
    return {
      state: atoms.RoundState.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_PreviewRound_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.state) {
      writer.writeMessage(1, msg.state, atoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_PreviewRound_Response,
    reader: BinaryReader
  ): Games_PreviewRound_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.state, atoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddOnlineReplay_Payload = {
  /**
   * Serializes Games_AddOnlineReplay_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_AddOnlineReplay_Payload>): Uint8Array {
    return Games_AddOnlineReplay_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddOnlineReplay_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddOnlineReplay_Payload {
    return Games_AddOnlineReplay_Payload._readMessage(
      Games_AddOnlineReplay_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddOnlineReplay_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddOnlineReplay_Payload {
    return {
      eventId: 0,
      link: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddOnlineReplay_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.link) {
      writer.writeString(2, msg.link);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddOnlineReplay_Payload,
    reader: BinaryReader
  ): Games_AddOnlineReplay_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.link = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddOnlineReplay_Response = {
  /**
   * Serializes Games_AddOnlineReplay_Response to protobuf.
   */
  encode: function (msg: Partial<Games_AddOnlineReplay_Response>): Uint8Array {
    return Games_AddOnlineReplay_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddOnlineReplay_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddOnlineReplay_Response {
    return Games_AddOnlineReplay_Response._readMessage(
      Games_AddOnlineReplay_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddOnlineReplay_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddOnlineReplay_Response {
    return {
      game: atoms.GameResult.initialize(),
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddOnlineReplay_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.game) {
      writer.writeMessage(1, msg.game, atoms.GameResult._writeMessage);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        atoms.Player._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddOnlineReplay_Response,
    reader: BinaryReader
  ): Games_AddOnlineReplay_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.game, atoms.GameResult._readMessage);
          break;
        }
        case 2: {
          const m = atoms.Player.initialize();
          reader.readMessage(m, atoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastResults_Payload = {
  /**
   * Serializes Players_GetLastResults_Payload to protobuf.
   */
  encode: function (msg: Partial<Players_GetLastResults_Payload>): Uint8Array {
    return Players_GetLastResults_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastResults_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastResults_Payload {
    return Players_GetLastResults_Payload._readMessage(
      Players_GetLastResults_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastResults_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastResults_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastResults_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastResults_Payload,
    reader: BinaryReader
  ): Players_GetLastResults_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastResults_Response = {
  /**
   * Serializes Players_GetLastResults_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetLastResults_Response>): Uint8Array {
    return Players_GetLastResults_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastResults_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastResults_Response {
    return Players_GetLastResults_Response._readMessage(
      Players_GetLastResults_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastResults_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastResults_Response {
    return {
      results: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastResults_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.results?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.results as any,
        atoms.SessionHistoryResult._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastResults_Response,
    reader: BinaryReader
  ): Players_GetLastResults_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.SessionHistoryResult.initialize();
          reader.readMessage(m, atoms.SessionHistoryResult._readMessage);
          msg.results.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastRound_Payload = {
  /**
   * Serializes Players_GetLastRound_Payload to protobuf.
   */
  encode: function (msg: Partial<Players_GetLastRound_Payload>): Uint8Array {
    return Players_GetLastRound_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastRound_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastRound_Payload {
    return Players_GetLastRound_Payload._readMessage(
      Players_GetLastRound_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastRound_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRound_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRound_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRound_Payload,
    reader: BinaryReader
  ): Players_GetLastRound_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastRound_Response = {
  /**
   * Serializes Players_GetLastRound_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetLastRound_Response>): Uint8Array {
    return Players_GetLastRound_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastRound_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastRound_Response {
    return Players_GetLastRound_Response._readMessage(
      Players_GetLastRound_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastRound_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRound_Response {
    return {
      round: atoms.RoundState.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRound_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.round) {
      writer.writeMessage(1, msg.round, atoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRound_Response,
    reader: BinaryReader
  ): Players_GetLastRound_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.round, atoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetAllRounds_Payload = {
  /**
   * Serializes Players_GetAllRounds_Payload to protobuf.
   */
  encode: function (msg: Partial<Players_GetAllRounds_Payload>): Uint8Array {
    return Players_GetAllRounds_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetAllRounds_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetAllRounds_Payload {
    return Players_GetAllRounds_Payload._readMessage(
      Players_GetAllRounds_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetAllRounds_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetAllRounds_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetAllRounds_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetAllRounds_Payload,
    reader: BinaryReader
  ): Players_GetAllRounds_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetAllRounds_Response = {
  /**
   * Serializes Players_GetAllRounds_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetAllRounds_Response>): Uint8Array {
    return Players_GetAllRounds_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetAllRounds_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetAllRounds_Response {
    return Players_GetAllRounds_Response._readMessage(
      Players_GetAllRounds_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetAllRounds_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetAllRounds_Response {
    return {
      round: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetAllRounds_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.round?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.round as any,
        atoms.RoundState._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetAllRounds_Response,
    reader: BinaryReader
  ): Players_GetAllRounds_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.RoundState.initialize();
          reader.readMessage(m, atoms.RoundState._readMessage);
          msg.round.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastRoundByHash_Payload = {
  /**
   * Serializes Players_GetLastRoundByHash_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Players_GetLastRoundByHash_Payload>
  ): Uint8Array {
    return Players_GetLastRoundByHash_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastRoundByHash_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastRoundByHash_Payload {
    return Players_GetLastRoundByHash_Payload._readMessage(
      Players_GetLastRoundByHash_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastRoundByHash_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRoundByHash_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRoundByHash_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRoundByHash_Payload,
    reader: BinaryReader
  ): Players_GetLastRoundByHash_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetLastRoundByHash_Response = {
  /**
   * Serializes Players_GetLastRoundByHash_Response to protobuf.
   */
  encode: function (
    msg: Partial<Players_GetLastRoundByHash_Response>
  ): Uint8Array {
    return Players_GetLastRoundByHash_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetLastRoundByHash_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetLastRoundByHash_Response {
    return Players_GetLastRoundByHash_Response._readMessage(
      Players_GetLastRoundByHash_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetLastRoundByHash_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRoundByHash_Response {
    return {
      round: atoms.RoundState.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRoundByHash_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.round) {
      writer.writeMessage(1, msg.round, atoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRoundByHash_Response,
    reader: BinaryReader
  ): Players_GetLastRoundByHash_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.round, atoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEventForEdit_Payload = {
  /**
   * Serializes Events_GetEventForEdit_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetEventForEdit_Payload>): Uint8Array {
    return Events_GetEventForEdit_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEventForEdit_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEventForEdit_Payload {
    return Events_GetEventForEdit_Payload._readMessage(
      Events_GetEventForEdit_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEventForEdit_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEventForEdit_Payload {
    return {
      id: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventForEdit_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventForEdit_Payload,
    reader: BinaryReader
  ): Events_GetEventForEdit_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetEventForEdit_Response = {
  /**
   * Serializes Events_GetEventForEdit_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetEventForEdit_Response>): Uint8Array {
    return Events_GetEventForEdit_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetEventForEdit_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetEventForEdit_Response {
    return Events_GetEventForEdit_Response._readMessage(
      Events_GetEventForEdit_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetEventForEdit_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEventForEdit_Response {
    return {
      id: 0,
      event: atoms.EventData.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventForEdit_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.event) {
      writer.writeMessage(2, msg.event, atoms.EventData._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventForEdit_Response,
    reader: BinaryReader
  ): Events_GetEventForEdit_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          reader.readMessage(msg.event, atoms.EventData._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdateEvent_Payload = {
  /**
   * Serializes Events_UpdateEvent_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_UpdateEvent_Payload>): Uint8Array {
    return Events_UpdateEvent_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdateEvent_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UpdateEvent_Payload {
    return Events_UpdateEvent_Payload._readMessage(
      Events_UpdateEvent_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdateEvent_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdateEvent_Payload {
    return {
      id: 0,
      event: atoms.EventData.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdateEvent_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.event) {
      writer.writeMessage(2, msg.event, atoms.EventData._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdateEvent_Payload,
    reader: BinaryReader
  ): Events_UpdateEvent_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          reader.readMessage(msg.event, atoms.EventData._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetTablesState_Response = {
  /**
   * Serializes Events_GetTablesState_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetTablesState_Response>): Uint8Array {
    return Events_GetTablesState_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetTablesState_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetTablesState_Response {
    return Events_GetTablesState_Response._readMessage(
      Events_GetTablesState_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetTablesState_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTablesState_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTablesState_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        atoms.TableState._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTablesState_Response,
    reader: BinaryReader
  ): Events_GetTablesState_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.TableState.initialize();
          reader.readMessage(m, atoms.TableState._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_RegisterPlayer_Payload = {
  /**
   * Serializes Events_RegisterPlayer_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_RegisterPlayer_Payload>): Uint8Array {
    return Events_RegisterPlayer_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_RegisterPlayer_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_RegisterPlayer_Payload {
    return Events_RegisterPlayer_Payload._readMessage(
      Events_RegisterPlayer_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_RegisterPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Events_RegisterPlayer_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_RegisterPlayer_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_RegisterPlayer_Payload,
    reader: BinaryReader
  ): Events_RegisterPlayer_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UnregisterPlayer_Payload = {
  /**
   * Serializes Events_UnregisterPlayer_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_UnregisterPlayer_Payload>): Uint8Array {
    return Events_UnregisterPlayer_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UnregisterPlayer_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UnregisterPlayer_Payload {
    return Events_UnregisterPlayer_Payload._readMessage(
      Events_UnregisterPlayer_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UnregisterPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UnregisterPlayer_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UnregisterPlayer_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UnregisterPlayer_Payload,
    reader: BinaryReader
  ): Events_UnregisterPlayer_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdatePlayerSeatingFlag_Payload = {
  /**
   * Serializes Events_UpdatePlayerSeatingFlag_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayerSeatingFlag_Payload>
  ): Uint8Array {
    return Events_UpdatePlayerSeatingFlag_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdatePlayerSeatingFlag_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UpdatePlayerSeatingFlag_Payload {
    return Events_UpdatePlayerSeatingFlag_Payload._readMessage(
      Events_UpdatePlayerSeatingFlag_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdatePlayerSeatingFlag_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayerSeatingFlag_Payload {
    return {
      playerId: 0,
      eventId: 0,
      ignoreSeating: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayerSeatingFlag_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.ignoreSeating) {
      writer.writeBool(3, msg.ignoreSeating);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayerSeatingFlag_Payload,
    reader: BinaryReader
  ): Events_UpdatePlayerSeatingFlag_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.ignoreSeating = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetAchievements_Payload = {
  /**
   * Serializes Events_GetAchievements_Payload to protobuf.
   */
  encode: function (msg: Partial<Events_GetAchievements_Payload>): Uint8Array {
    return Events_GetAchievements_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetAchievements_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetAchievements_Payload {
    return Events_GetAchievements_Payload._readMessage(
      Events_GetAchievements_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetAchievements_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievements_Payload {
    return {
      eventIds: [],
      achievementsList: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievements_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventIds?.length) {
      writer.writePackedInt32(1, msg.eventIds);
    }
    if (msg.achievementsList?.length) {
      writer.writeRepeatedString(2, msg.achievementsList);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievements_Payload,
    reader: BinaryReader
  ): Events_GetAchievements_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIds.push(...reader.readPackedInt32());
          } else {
            msg.eventIds.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          msg.achievementsList.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetAchievements_Response = {
  /**
   * Serializes Events_GetAchievements_Response to protobuf.
   */
  encode: function (msg: Partial<Events_GetAchievements_Response>): Uint8Array {
    return Events_GetAchievements_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetAchievements_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetAchievements_Response {
    return Events_GetAchievements_Response._readMessage(
      Events_GetAchievements_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetAchievements_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievements_Response {
    return {
      achievements: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievements_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.achievements?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.achievements as any,
        atoms.Achievement._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievements_Response,
    reader: BinaryReader
  ): Events_GetAchievements_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.Achievement.initialize();
          reader.readMessage(m, atoms.Achievement._readMessage);
          msg.achievements.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetAchievementsList_Payload = {
  /**
   * Serializes Events_GetAchievementsList_Payload to protobuf.
   */
  encode: function (
    _msg?: Partial<Events_GetAchievementsList_Payload>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Events_GetAchievementsList_Payload from protobuf.
   */
  decode: function (_bytes?: ByteSource): Events_GetAchievementsList_Payload {
    return {};
  },

  /**
   * Initializes Events_GetAchievementsList_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievementsList_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Events_GetAchievementsList_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: Events_GetAchievementsList_Payload,
    _reader: BinaryReader
  ): Events_GetAchievementsList_Payload {
    return _msg;
  },
};

export const Events_GetAchievementsList_Response = {
  /**
   * Serializes Events_GetAchievementsList_Response to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetAchievementsList_Response>
  ): Uint8Array {
    return Events_GetAchievementsList_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetAchievementsList_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetAchievementsList_Response {
    return Events_GetAchievementsList_Response._readMessage(
      Events_GetAchievementsList_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetAchievementsList_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievementsList_Response {
    return {
      list: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievementsList_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.list?.length) {
      writer.writeRepeatedString(1, msg.list);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievementsList_Response,
    reader: BinaryReader
  ): Events_GetAchievementsList_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.list.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdatePlayersLocalIds_Payload = {
  /**
   * Serializes Events_UpdatePlayersLocalIds_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayersLocalIds_Payload>
  ): Uint8Array {
    return Events_UpdatePlayersLocalIds_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdatePlayersLocalIds_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UpdatePlayersLocalIds_Payload {
    return Events_UpdatePlayersLocalIds_Payload._readMessage(
      Events_UpdatePlayersLocalIds_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdatePlayersLocalIds_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayersLocalIds_Payload {
    return {
      eventId: 0,
      idMap: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayersLocalIds_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.idMap?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.idMap as any,
        atoms.LocalIdMapping._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayersLocalIds_Payload,
    reader: BinaryReader
  ): Events_UpdatePlayersLocalIds_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          const m = atoms.LocalIdMapping.initialize();
          reader.readMessage(m, atoms.LocalIdMapping._readMessage);
          msg.idMap.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdatePlayerReplacement_Payload = {
  /**
   * Serializes Events_UpdatePlayerReplacement_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayerReplacement_Payload>
  ): Uint8Array {
    return Events_UpdatePlayerReplacement_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdatePlayerReplacement_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UpdatePlayerReplacement_Payload {
    return Events_UpdatePlayerReplacement_Payload._readMessage(
      Events_UpdatePlayerReplacement_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdatePlayerReplacement_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayerReplacement_Payload {
    return {
      playerId: 0,
      eventId: 0,
      replacementId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayerReplacement_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.replacementId) {
      writer.writeInt32(3, msg.replacementId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayerReplacement_Payload,
    reader: BinaryReader
  ): Events_UpdatePlayerReplacement_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.replacementId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdatePlayersTeams_Payload = {
  /**
   * Serializes Events_UpdatePlayersTeams_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayersTeams_Payload>
  ): Uint8Array {
    return Events_UpdatePlayersTeams_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdatePlayersTeams_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Events_UpdatePlayersTeams_Payload {
    return Events_UpdatePlayersTeams_Payload._readMessage(
      Events_UpdatePlayersTeams_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdatePlayersTeams_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayersTeams_Payload {
    return {
      eventId: 0,
      teamNameMap: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayersTeams_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.teamNameMap?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.teamNameMap as any,
        atoms.TeamMapping._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayersTeams_Payload,
    reader: BinaryReader
  ): Events_UpdatePlayersTeams_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          const m = atoms.TeamMapping.initialize();
          reader.readMessage(m, atoms.TeamMapping._readMessage);
          msg.teamNameMap.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_StartGame_Payload = {
  /**
   * Serializes Games_StartGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_StartGame_Payload>): Uint8Array {
    return Games_StartGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_StartGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_StartGame_Payload {
    return Games_StartGame_Payload._readMessage(
      Games_StartGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_StartGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_StartGame_Payload {
    return {
      eventId: 0,
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_StartGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.players?.length) {
      writer.writePackedInt32(2, msg.players);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_StartGame_Payload,
    reader: BinaryReader
  ): Games_StartGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.players.push(...reader.readPackedInt32());
          } else {
            msg.players.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_StartGame_Response = {
  /**
   * Serializes Games_StartGame_Response to protobuf.
   */
  encode: function (msg: Partial<Games_StartGame_Response>): Uint8Array {
    return Games_StartGame_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_StartGame_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_StartGame_Response {
    return Games_StartGame_Response._readMessage(
      Games_StartGame_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_StartGame_Response with all fields set to their default value.
   */
  initialize: function (): Games_StartGame_Response {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_StartGame_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_StartGame_Response,
    reader: BinaryReader
  ): Games_StartGame_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_EndGame_Payload = {
  /**
   * Serializes Games_EndGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_EndGame_Payload>): Uint8Array {
    return Games_EndGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_EndGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_EndGame_Payload {
    return Games_EndGame_Payload._readMessage(
      Games_EndGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_EndGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_EndGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_EndGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_EndGame_Payload,
    reader: BinaryReader
  ): Games_EndGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_CancelGame_Payload = {
  /**
   * Serializes Games_CancelGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_CancelGame_Payload>): Uint8Array {
    return Games_CancelGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_CancelGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_CancelGame_Payload {
    return Games_CancelGame_Payload._readMessage(
      Games_CancelGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_CancelGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_CancelGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_CancelGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_CancelGame_Payload,
    reader: BinaryReader
  ): Games_CancelGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_DropLastRound_Payload = {
  /**
   * Serializes Games_DropLastRound_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_DropLastRound_Payload>): Uint8Array {
    return Games_DropLastRound_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_DropLastRound_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_DropLastRound_Payload {
    return Games_DropLastRound_Payload._readMessage(
      Games_DropLastRound_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_DropLastRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_DropLastRound_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_DropLastRound_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_DropLastRound_Payload,
    reader: BinaryReader
  ): Games_DropLastRound_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_DefinalizeGame_Payload = {
  /**
   * Serializes Games_DefinalizeGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_DefinalizeGame_Payload>): Uint8Array {
    return Games_DefinalizeGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_DefinalizeGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_DefinalizeGame_Payload {
    return Games_DefinalizeGame_Payload._readMessage(
      Games_DefinalizeGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_DefinalizeGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_DefinalizeGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_DefinalizeGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_DefinalizeGame_Payload,
    reader: BinaryReader
  ): Games_DefinalizeGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddPenalty_Payload = {
  /**
   * Serializes Games_AddPenalty_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_AddPenalty_Payload>): Uint8Array {
    return Games_AddPenalty_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddPenalty_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddPenalty_Payload {
    return Games_AddPenalty_Payload._readMessage(
      Games_AddPenalty_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddPenalty_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddPenalty_Payload {
    return {
      eventId: 0,
      playerId: 0,
      amount: 0,
      reason: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenalty_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.playerId) {
      writer.writeInt32(2, msg.playerId);
    }
    if (msg.amount) {
      writer.writeInt32(3, msg.amount);
    }
    if (msg.reason) {
      writer.writeString(4, msg.reason);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenalty_Payload,
    reader: BinaryReader
  ): Games_AddPenalty_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 3: {
          msg.amount = reader.readInt32();
          break;
        }
        case 4: {
          msg.reason = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddPenaltyGame_Payload = {
  /**
   * Serializes Games_AddPenaltyGame_Payload to protobuf.
   */
  encode: function (msg: Partial<Games_AddPenaltyGame_Payload>): Uint8Array {
    return Games_AddPenaltyGame_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddPenaltyGame_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddPenaltyGame_Payload {
    return Games_AddPenaltyGame_Payload._readMessage(
      Games_AddPenaltyGame_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddPenaltyGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddPenaltyGame_Payload {
    return {
      eventId: 0,
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenaltyGame_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.players?.length) {
      writer.writePackedInt32(2, msg.players);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenaltyGame_Payload,
    reader: BinaryReader
  ): Games_AddPenaltyGame_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.players.push(...reader.readPackedInt32());
          } else {
            msg.players.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Games_AddPenaltyGame_Response = {
  /**
   * Serializes Games_AddPenaltyGame_Response to protobuf.
   */
  encode: function (msg: Partial<Games_AddPenaltyGame_Response>): Uint8Array {
    return Games_AddPenaltyGame_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Games_AddPenaltyGame_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Games_AddPenaltyGame_Response {
    return Games_AddPenaltyGame_Response._readMessage(
      Games_AddPenaltyGame_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Games_AddPenaltyGame_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddPenaltyGame_Response {
    return {
      hash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenaltyGame_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.hash) {
      writer.writeString(1, msg.hash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenaltyGame_Response,
    reader: BinaryReader
  ): Games_AddPenaltyGame_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.hash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetPlayer_Payload = {
  /**
   * Serializes Players_GetPlayer_Payload to protobuf.
   */
  encode: function (msg: Partial<Players_GetPlayer_Payload>): Uint8Array {
    return Players_GetPlayer_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetPlayer_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetPlayer_Payload {
    return Players_GetPlayer_Payload._readMessage(
      Players_GetPlayer_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayer_Payload {
    return {
      id: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayer_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayer_Payload,
    reader: BinaryReader
  ): Players_GetPlayer_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Players_GetPlayer_Response = {
  /**
   * Serializes Players_GetPlayer_Response to protobuf.
   */
  encode: function (msg: Partial<Players_GetPlayer_Response>): Uint8Array {
    return Players_GetPlayer_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Players_GetPlayer_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Players_GetPlayer_Response {
    return Players_GetPlayer_Response._readMessage(
      Players_GetPlayer_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Players_GetPlayer_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayer_Response {
    return {
      players: atoms.Player.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayer_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.players) {
      writer.writeMessage(1, msg.players, atoms.Player._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayer_Response,
    reader: BinaryReader
  ): Players_GetPlayer_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.players, atoms.Player._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetCurrentSeating_Response = {
  /**
   * Serializes Events_GetCurrentSeating_Response to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetCurrentSeating_Response>
  ): Uint8Array {
    return Events_GetCurrentSeating_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetCurrentSeating_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetCurrentSeating_Response {
    return Events_GetCurrentSeating_Response._readMessage(
      Events_GetCurrentSeating_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetCurrentSeating_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetCurrentSeating_Response {
    return {
      seating: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCurrentSeating_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.seating?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.seating as any,
        atoms.PlayerSeating._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCurrentSeating_Response,
    reader: BinaryReader
  ): Events_GetCurrentSeating_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.PlayerSeating.initialize();
          reader.readMessage(m, atoms.PlayerSeating._readMessage);
          msg.seating.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Seating_MakeShuffledSeating_Payload = {
  /**
   * Serializes Seating_MakeShuffledSeating_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Seating_MakeShuffledSeating_Payload>
  ): Uint8Array {
    return Seating_MakeShuffledSeating_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Seating_MakeShuffledSeating_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Seating_MakeShuffledSeating_Payload {
    return Seating_MakeShuffledSeating_Payload._readMessage(
      Seating_MakeShuffledSeating_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Seating_MakeShuffledSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakeShuffledSeating_Payload {
    return {
      eventId: 0,
      groupsCount: 0,
      seed: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakeShuffledSeating_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.groupsCount) {
      writer.writeInt32(2, msg.groupsCount);
    }
    if (msg.seed) {
      writer.writeInt32(3, msg.seed);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakeShuffledSeating_Payload,
    reader: BinaryReader
  ): Seating_MakeShuffledSeating_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.groupsCount = reader.readInt32();
          break;
        }
        case 3: {
          msg.seed = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Seating_GenerateSwissSeating_Response = {
  /**
   * Serializes Seating_GenerateSwissSeating_Response to protobuf.
   */
  encode: function (
    msg: Partial<Seating_GenerateSwissSeating_Response>
  ): Uint8Array {
    return Seating_GenerateSwissSeating_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Seating_GenerateSwissSeating_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Seating_GenerateSwissSeating_Response {
    return Seating_GenerateSwissSeating_Response._readMessage(
      Seating_GenerateSwissSeating_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Seating_GenerateSwissSeating_Response with all fields set to their default value.
   */
  initialize: function (): Seating_GenerateSwissSeating_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_GenerateSwissSeating_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        atoms.TableItemSwiss._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_GenerateSwissSeating_Response,
    reader: BinaryReader
  ): Seating_GenerateSwissSeating_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.TableItemSwiss.initialize();
          reader.readMessage(m, atoms.TableItemSwiss._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Seating_MakeIntervalSeating_Payload = {
  /**
   * Serializes Seating_MakeIntervalSeating_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Seating_MakeIntervalSeating_Payload>
  ): Uint8Array {
    return Seating_MakeIntervalSeating_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Seating_MakeIntervalSeating_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Seating_MakeIntervalSeating_Payload {
    return Seating_MakeIntervalSeating_Payload._readMessage(
      Seating_MakeIntervalSeating_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Seating_MakeIntervalSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakeIntervalSeating_Payload {
    return {
      eventId: 0,
      step: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakeIntervalSeating_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.step) {
      writer.writeInt32(2, msg.step);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakeIntervalSeating_Payload,
    reader: BinaryReader
  ): Seating_MakeIntervalSeating_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.step = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Seating_MakePrescriptedSeating_Payload = {
  /**
   * Serializes Seating_MakePrescriptedSeating_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Seating_MakePrescriptedSeating_Payload>
  ): Uint8Array {
    return Seating_MakePrescriptedSeating_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Seating_MakePrescriptedSeating_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Seating_MakePrescriptedSeating_Payload {
    return Seating_MakePrescriptedSeating_Payload._readMessage(
      Seating_MakePrescriptedSeating_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Seating_MakePrescriptedSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakePrescriptedSeating_Payload {
    return {
      eventId: 0,
      randomizeAtTables: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakePrescriptedSeating_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.randomizeAtTables) {
      writer.writeBool(2, msg.randomizeAtTables);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakePrescriptedSeating_Payload,
    reader: BinaryReader
  ): Seating_MakePrescriptedSeating_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.randomizeAtTables = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Seating_GetNextPrescriptedSeating_Response = {
  /**
   * Serializes Seating_GetNextPrescriptedSeating_Response to protobuf.
   */
  encode: function (
    msg: Partial<Seating_GetNextPrescriptedSeating_Response>
  ): Uint8Array {
    return Seating_GetNextPrescriptedSeating_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Seating_GetNextPrescriptedSeating_Response from protobuf.
   */
  decode: function (
    bytes: ByteSource
  ): Seating_GetNextPrescriptedSeating_Response {
    return Seating_GetNextPrescriptedSeating_Response._readMessage(
      Seating_GetNextPrescriptedSeating_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Seating_GetNextPrescriptedSeating_Response with all fields set to their default value.
   */
  initialize: function (): Seating_GetNextPrescriptedSeating_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_GetNextPrescriptedSeating_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        atoms.PrescriptedTable._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_GetNextPrescriptedSeating_Response,
    reader: BinaryReader
  ): Seating_GetNextPrescriptedSeating_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = atoms.PrescriptedTable.initialize();
          reader.readMessage(m, atoms.PrescriptedTable._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetPrescriptedEventConfig_Response = {
  /**
   * Serializes Events_GetPrescriptedEventConfig_Response to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetPrescriptedEventConfig_Response>
  ): Uint8Array {
    return Events_GetPrescriptedEventConfig_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetPrescriptedEventConfig_Response from protobuf.
   */
  decode: function (
    bytes: ByteSource
  ): Events_GetPrescriptedEventConfig_Response {
    return Events_GetPrescriptedEventConfig_Response._readMessage(
      Events_GetPrescriptedEventConfig_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetPrescriptedEventConfig_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetPrescriptedEventConfig_Response {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: undefined,
      errors: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetPrescriptedEventConfig_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.nextSessionIndex) {
      writer.writeInt32(2, msg.nextSessionIndex);
    }
    if (msg.prescript != undefined) {
      writer.writeString(3, msg.prescript);
    }
    if (msg.errors?.length) {
      writer.writeRepeatedString(4, msg.errors);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetPrescriptedEventConfig_Response,
    reader: BinaryReader
  ): Events_GetPrescriptedEventConfig_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.nextSessionIndex = reader.readInt32();
          break;
        }
        case 3: {
          msg.prescript = reader.readString();
          break;
        }
        case 4: {
          msg.errors.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_UpdatePrescriptedEventConfig_Payload = {
  /**
   * Serializes Events_UpdatePrescriptedEventConfig_Payload to protobuf.
   */
  encode: function (
    msg: Partial<Events_UpdatePrescriptedEventConfig_Payload>
  ): Uint8Array {
    return Events_UpdatePrescriptedEventConfig_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_UpdatePrescriptedEventConfig_Payload from protobuf.
   */
  decode: function (
    bytes: ByteSource
  ): Events_UpdatePrescriptedEventConfig_Payload {
    return Events_UpdatePrescriptedEventConfig_Payload._readMessage(
      Events_UpdatePrescriptedEventConfig_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_UpdatePrescriptedEventConfig_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePrescriptedEventConfig_Payload {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePrescriptedEventConfig_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.nextSessionIndex) {
      writer.writeInt32(2, msg.nextSessionIndex);
    }
    if (msg.prescript) {
      writer.writeString(3, msg.prescript);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePrescriptedEventConfig_Payload,
    reader: BinaryReader
  ): Events_UpdatePrescriptedEventConfig_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.nextSessionIndex = reader.readInt32();
          break;
        }
        case 3: {
          msg.prescript = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Events_GetStartingTimer_Response = {
  /**
   * Serializes Events_GetStartingTimer_Response to protobuf.
   */
  encode: function (
    msg: Partial<Events_GetStartingTimer_Response>
  ): Uint8Array {
    return Events_GetStartingTimer_Response._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Events_GetStartingTimer_Response from protobuf.
   */
  decode: function (bytes: ByteSource): Events_GetStartingTimer_Response {
    return Events_GetStartingTimer_Response._readMessage(
      Events_GetStartingTimer_Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Events_GetStartingTimer_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetStartingTimer_Response {
    return {
      timer: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetStartingTimer_Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.timer) {
      writer.writeInt32(1, msg.timer);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetStartingTimer_Response,
    reader: BinaryReader
  ): Events_GetStartingTimer_Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.timer = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Misc_AddErrorLog_Payload = {
  /**
   * Serializes Misc_AddErrorLog_Payload to protobuf.
   */
  encode: function (msg: Partial<Misc_AddErrorLog_Payload>): Uint8Array {
    return Misc_AddErrorLog_Payload._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Misc_AddErrorLog_Payload from protobuf.
   */
  decode: function (bytes: ByteSource): Misc_AddErrorLog_Payload {
    return Misc_AddErrorLog_Payload._readMessage(
      Misc_AddErrorLog_Payload.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Misc_AddErrorLog_Payload with all fields set to their default value.
   */
  initialize: function (): Misc_AddErrorLog_Payload {
    return {
      facility: "",
      sessionHash: "",
      playerId: 0,
      error: "",
      stack: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Misc_AddErrorLog_Payload>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.facility) {
      writer.writeString(1, msg.facility);
    }
    if (msg.sessionHash) {
      writer.writeString(2, msg.sessionHash);
    }
    if (msg.playerId) {
      writer.writeInt32(3, msg.playerId);
    }
    if (msg.error) {
      writer.writeString(4, msg.error);
    }
    if (msg.stack) {
      writer.writeString(5, msg.stack);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Misc_AddErrorLog_Payload,
    reader: BinaryReader
  ): Misc_AddErrorLog_Payload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.facility = reader.readString();
          break;
        }
        case 2: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 3: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 4: {
          msg.error = reader.readString();
          break;
        }
        case 5: {
          msg.stack = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const Events_GetRulesets_PayloadJSON = {
  /**
   * Serializes Events_GetRulesets_Payload to JSON.
   */
  encode: function (_msg?: Partial<Events_GetRulesets_Payload>): string {
    return "{}";
  },

  /**
   * Deserializes Events_GetRulesets_Payload from JSON.
   */
  decode: function (_json?: string): Events_GetRulesets_Payload {
    return {};
  },

  /**
   * Initializes Events_GetRulesets_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetRulesets_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Events_GetRulesets_Payload>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRulesets_Payload,
    _json: any
  ): Events_GetRulesets_Payload {
    return msg;
  },
};

export const Events_GetRulesets_ResponseJSON = {
  /**
   * Serializes Events_GetRulesets_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetRulesets_Response>): string {
    return JSON.stringify(Events_GetRulesets_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetRulesets_Response from JSON.
   */
  decode: function (json: string): Events_GetRulesets_Response {
    return Events_GetRulesets_ResponseJSON._readMessage(
      Events_GetRulesets_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetRulesets_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetRulesets_Response {
    return {
      rulesets: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRulesets_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rulesets?.length) {
      json["rulesets"] = msg.rulesets.map(
        atoms.RulesetGeneratedJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRulesets_Response,
    json: any
  ): Events_GetRulesets_Response {
    const _rulesets_ = json["rulesets"];
    if (_rulesets_) {
      for (const item of _rulesets_) {
        const m = atoms.RulesetGenerated.initialize();
        atoms.RulesetGeneratedJSON._readMessage(m, item);
        msg.rulesets.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetTimezones_PayloadJSON = {
  /**
   * Serializes Events_GetTimezones_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetTimezones_Payload>): string {
    return JSON.stringify(Events_GetTimezones_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetTimezones_Payload from JSON.
   */
  decode: function (json: string): Events_GetTimezones_Payload {
    return Events_GetTimezones_PayloadJSON._readMessage(
      Events_GetTimezones_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetTimezones_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetTimezones_Payload {
    return {
      addr: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimezones_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.addr) {
      json["addr"] = msg.addr;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimezones_Payload,
    json: any
  ): Events_GetTimezones_Payload {
    const _addr_ = json["addr"];
    if (_addr_) {
      msg.addr = _addr_;
    }
    return msg;
  },
};

export const Events_GetTimezones_ResponseJSON = {
  /**
   * Serializes Events_GetTimezones_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetTimezones_Response>): string {
    return JSON.stringify(Events_GetTimezones_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetTimezones_Response from JSON.
   */
  decode: function (json: string): Events_GetTimezones_Response {
    return Events_GetTimezones_ResponseJSON._readMessage(
      Events_GetTimezones_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetTimezones_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTimezones_Response {
    return {
      preferredByIp: "",
      timezones: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimezones_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.preferredByIp) {
      json["preferredByIp"] = msg.preferredByIp;
    }
    if (msg.timezones?.length) {
      json["timezones"] = msg.timezones;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimezones_Response,
    json: any
  ): Events_GetTimezones_Response {
    const _preferredByIp_ = json["preferredByIp"];
    if (_preferredByIp_) {
      msg.preferredByIp = _preferredByIp_;
    }
    const _timezones_ = json["timezones"];
    if (_timezones_) {
      msg.timezones = _timezones_;
    }
    return msg;
  },
};

export const Events_GetCountries_PayloadJSON = {
  /**
   * Serializes Events_GetCountries_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetCountries_Payload>): string {
    return JSON.stringify(Events_GetCountries_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetCountries_Payload from JSON.
   */
  decode: function (json: string): Events_GetCountries_Payload {
    return Events_GetCountries_PayloadJSON._readMessage(
      Events_GetCountries_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetCountries_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetCountries_Payload {
    return {
      addr: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCountries_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.addr) {
      json["addr"] = msg.addr;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCountries_Payload,
    json: any
  ): Events_GetCountries_Payload {
    const _addr_ = json["addr"];
    if (_addr_) {
      msg.addr = _addr_;
    }
    return msg;
  },
};

export const Events_GetCountries_ResponseJSON = {
  /**
   * Serializes Events_GetCountries_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetCountries_Response>): string {
    return JSON.stringify(Events_GetCountries_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetCountries_Response from JSON.
   */
  decode: function (json: string): Events_GetCountries_Response {
    return Events_GetCountries_ResponseJSON._readMessage(
      Events_GetCountries_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetCountries_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetCountries_Response {
    return {
      preferredByIp: "",
      countries: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCountries_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.preferredByIp) {
      json["preferredByIp"] = msg.preferredByIp;
    }
    if (msg.countries?.length) {
      json["countries"] = msg.countries.map(atoms.CountryJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCountries_Response,
    json: any
  ): Events_GetCountries_Response {
    const _preferredByIp_ = json["preferredByIp"];
    if (_preferredByIp_) {
      msg.preferredByIp = _preferredByIp_;
    }
    const _countries_ = json["countries"];
    if (_countries_) {
      for (const item of _countries_) {
        const m = atoms.Country.initialize();
        atoms.CountryJSON._readMessage(m, item);
        msg.countries.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetEvents_PayloadJSON = {
  /**
   * Serializes Events_GetEvents_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetEvents_Payload>): string {
    return JSON.stringify(Events_GetEvents_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetEvents_Payload from JSON.
   */
  decode: function (json: string): Events_GetEvents_Payload {
    return Events_GetEvents_PayloadJSON._readMessage(
      Events_GetEvents_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEvents_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEvents_Payload {
    return {
      limit: 0,
      offset: 0,
      filterUnlisted: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEvents_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    if (msg.offset) {
      json["offset"] = msg.offset;
    }
    if (msg.filterUnlisted) {
      json["filterUnlisted"] = msg.filterUnlisted;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEvents_Payload,
    json: any
  ): Events_GetEvents_Payload {
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = _limit_;
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = _offset_;
    }
    const _filterUnlisted_ = json["filterUnlisted"];
    if (_filterUnlisted_) {
      msg.filterUnlisted = _filterUnlisted_;
    }
    return msg;
  },
};

export const Events_GetEvents_ResponseJSON = {
  /**
   * Serializes Events_GetEvents_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetEvents_Response>): string {
    return JSON.stringify(Events_GetEvents_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetEvents_Response from JSON.
   */
  decode: function (json: string): Events_GetEvents_Response {
    return Events_GetEvents_ResponseJSON._readMessage(
      Events_GetEvents_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEvents_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEvents_Response {
    return {
      total: 0,
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEvents_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.total) {
      json["total"] = msg.total;
    }
    if (msg.events?.length) {
      json["events"] = msg.events.map(atoms.EventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEvents_Response,
    json: any
  ): Events_GetEvents_Response {
    const _total_ = json["total"];
    if (_total_) {
      msg.total = _total_;
    }
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = atoms.Event.initialize();
        atoms.EventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetEventsById_PayloadJSON = {
  /**
   * Serializes Events_GetEventsById_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetEventsById_Payload>): string {
    return JSON.stringify(Events_GetEventsById_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetEventsById_Payload from JSON.
   */
  decode: function (json: string): Events_GetEventsById_Payload {
    return Events_GetEventsById_PayloadJSON._readMessage(
      Events_GetEventsById_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEventsById_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEventsById_Payload {
    return {
      ids: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventsById_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ids?.length) {
      json["ids"] = msg.ids;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventsById_Payload,
    json: any
  ): Events_GetEventsById_Payload {
    const _ids_ = json["ids"];
    if (_ids_) {
      msg.ids = _ids_;
    }
    return msg;
  },
};

export const Events_GetEventsById_ResponseJSON = {
  /**
   * Serializes Events_GetEventsById_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetEventsById_Response>): string {
    return JSON.stringify(Events_GetEventsById_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetEventsById_Response from JSON.
   */
  decode: function (json: string): Events_GetEventsById_Response {
    return Events_GetEventsById_ResponseJSON._readMessage(
      Events_GetEventsById_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEventsById_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEventsById_Response {
    return {
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventsById_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.events?.length) {
      json["events"] = msg.events.map(atoms.EventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventsById_Response,
    json: any
  ): Events_GetEventsById_Response {
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = atoms.Event.initialize();
        atoms.EventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const Players_GetMyEvents_PayloadJSON = {
  /**
   * Serializes Players_GetMyEvents_Payload to JSON.
   */
  encode: function (_msg?: Partial<Players_GetMyEvents_Payload>): string {
    return "{}";
  },

  /**
   * Deserializes Players_GetMyEvents_Payload from JSON.
   */
  decode: function (_json?: string): Players_GetMyEvents_Payload {
    return {};
  },

  /**
   * Initializes Players_GetMyEvents_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetMyEvents_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Players_GetMyEvents_Payload>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetMyEvents_Payload,
    _json: any
  ): Players_GetMyEvents_Payload {
    return msg;
  },
};

export const Players_GetMyEvents_ResponseJSON = {
  /**
   * Serializes Players_GetMyEvents_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetMyEvents_Response>): string {
    return JSON.stringify(Players_GetMyEvents_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetMyEvents_Response from JSON.
   */
  decode: function (json: string): Players_GetMyEvents_Response {
    return Players_GetMyEvents_ResponseJSON._readMessage(
      Players_GetMyEvents_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetMyEvents_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetMyEvents_Response {
    return {
      events: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetMyEvents_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.events?.length) {
      json["events"] = msg.events.map(atoms.MyEventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetMyEvents_Response,
    json: any
  ): Players_GetMyEvents_Response {
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = atoms.MyEvent.initialize();
        atoms.MyEventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetRatingTable_PayloadJSON = {
  /**
   * Serializes Events_GetRatingTable_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetRatingTable_Payload>): string {
    return JSON.stringify(Events_GetRatingTable_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetRatingTable_Payload from JSON.
   */
  decode: function (json: string): Events_GetRatingTable_Payload {
    return Events_GetRatingTable_PayloadJSON._readMessage(
      Events_GetRatingTable_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetRatingTable_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetRatingTable_Payload {
    return {
      eventIdList: [],
      orderBy: "",
      order: "",
      withPrefinished: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRatingTable_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    if (msg.orderBy) {
      json["orderBy"] = msg.orderBy;
    }
    if (msg.order) {
      json["order"] = msg.order;
    }
    if (msg.withPrefinished) {
      json["withPrefinished"] = msg.withPrefinished;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRatingTable_Payload,
    json: any
  ): Events_GetRatingTable_Payload {
    const _eventIdList_ = json["eventIdList"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_;
    }
    const _orderBy_ = json["orderBy"];
    if (_orderBy_) {
      msg.orderBy = _orderBy_;
    }
    const _order_ = json["order"];
    if (_order_) {
      msg.order = _order_;
    }
    const _withPrefinished_ = json["withPrefinished"];
    if (_withPrefinished_) {
      msg.withPrefinished = _withPrefinished_;
    }
    return msg;
  },
};

export const Events_GetRatingTable_ResponseJSON = {
  /**
   * Serializes Events_GetRatingTable_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetRatingTable_Response>): string {
    return JSON.stringify(
      Events_GetRatingTable_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetRatingTable_Response from JSON.
   */
  decode: function (json: string): Events_GetRatingTable_Response {
    return Events_GetRatingTable_ResponseJSON._readMessage(
      Events_GetRatingTable_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetRatingTable_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetRatingTable_Response {
    return {
      list: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetRatingTable_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.list?.length) {
      json["list"] = msg.list.map(atoms.PlayerInRatingJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetRatingTable_Response,
    json: any
  ): Events_GetRatingTable_Response {
    const _list_ = json["list"];
    if (_list_) {
      for (const item of _list_) {
        const m = atoms.PlayerInRating.initialize();
        atoms.PlayerInRatingJSON._readMessage(m, item);
        msg.list.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetLastGames_PayloadJSON = {
  /**
   * Serializes Events_GetLastGames_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetLastGames_Payload>): string {
    return JSON.stringify(Events_GetLastGames_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetLastGames_Payload from JSON.
   */
  decode: function (json: string): Events_GetLastGames_Payload {
    return Events_GetLastGames_PayloadJSON._readMessage(
      Events_GetLastGames_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetLastGames_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetLastGames_Payload {
    return {
      eventIdList: [],
      limit: 0,
      offset: 0,
      orderBy: undefined,
      order: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetLastGames_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    if (msg.offset) {
      json["offset"] = msg.offset;
    }
    if (msg.orderBy != undefined) {
      json["orderBy"] = msg.orderBy;
    }
    if (msg.order != undefined) {
      json["order"] = msg.order;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetLastGames_Payload,
    json: any
  ): Events_GetLastGames_Payload {
    const _eventIdList_ = json["eventIdList"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_;
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = _limit_;
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = _offset_;
    }
    const _orderBy_ = json["orderBy"];
    if (_orderBy_) {
      msg.orderBy = _orderBy_;
    }
    const _order_ = json["order"];
    if (_order_) {
      msg.order = _order_;
    }
    return msg;
  },
};

export const Events_GetLastGames_ResponseJSON = {
  /**
   * Serializes Events_GetLastGames_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetLastGames_Response>): string {
    return JSON.stringify(Events_GetLastGames_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetLastGames_Response from JSON.
   */
  decode: function (json: string): Events_GetLastGames_Response {
    return Events_GetLastGames_ResponseJSON._readMessage(
      Events_GetLastGames_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetLastGames_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetLastGames_Response {
    return {
      games: [],
      players: [],
      totalGames: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetLastGames_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.games?.length) {
      json["games"] = msg.games.map(atoms.GameResultJSON._writeMessage);
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(atoms.PlayerJSON._writeMessage);
    }
    if (msg.totalGames) {
      json["totalGames"] = msg.totalGames;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetLastGames_Response,
    json: any
  ): Events_GetLastGames_Response {
    const _games_ = json["games"];
    if (_games_) {
      for (const item of _games_) {
        const m = atoms.GameResult.initialize();
        atoms.GameResultJSON._readMessage(m, item);
        msg.games.push(m);
      }
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = atoms.Player.initialize();
        atoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _totalGames_ = json["totalGames"];
    if (_totalGames_) {
      msg.totalGames = _totalGames_;
    }
    return msg;
  },
};

export const Events_GetGame_PayloadJSON = {
  /**
   * Serializes Events_GetGame_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetGame_Payload>): string {
    return JSON.stringify(Events_GetGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetGame_Payload from JSON.
   */
  decode: function (json: string): Events_GetGame_Payload {
    return Events_GetGame_PayloadJSON._readMessage(
      Events_GetGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetGame_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGame_Payload,
    json: any
  ): Events_GetGame_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Events_GetGame_ResponseJSON = {
  /**
   * Serializes Events_GetGame_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetGame_Response>): string {
    return JSON.stringify(Events_GetGame_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetGame_Response from JSON.
   */
  decode: function (json: string): Events_GetGame_Response {
    return Events_GetGame_ResponseJSON._readMessage(
      Events_GetGame_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetGame_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetGame_Response {
    return {
      game: atoms.GameResultJSON.initialize(),
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGame_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.game) {
      const _game_ = atoms.GameResultJSON._writeMessage(msg.game);
      if (Object.keys(_game_).length > 0) {
        json["game"] = _game_;
      }
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(atoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGame_Response,
    json: any
  ): Events_GetGame_Response {
    const _game_ = json["game"];
    if (_game_) {
      const m = atoms.GameResult.initialize();
      atoms.GameResultJSON._readMessage(m, _game_);
      msg.game = m;
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = atoms.Player.initialize();
        atoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetGamesSeries_ResponseJSON = {
  /**
   * Serializes Events_GetGamesSeries_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetGamesSeries_Response>): string {
    return JSON.stringify(
      Events_GetGamesSeries_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetGamesSeries_Response from JSON.
   */
  decode: function (json: string): Events_GetGamesSeries_Response {
    return Events_GetGamesSeries_ResponseJSON._readMessage(
      Events_GetGamesSeries_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetGamesSeries_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetGamesSeries_Response {
    return {
      results: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetGamesSeries_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.results?.length) {
      json["results"] = msg.results.map(atoms.SeriesResultJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetGamesSeries_Response,
    json: any
  ): Events_GetGamesSeries_Response {
    const _results_ = json["results"];
    if (_results_) {
      for (const item of _results_) {
        const m = atoms.SeriesResult.initialize();
        atoms.SeriesResultJSON._readMessage(m, item);
        msg.results.push(m);
      }
    }
    return msg;
  },
};

export const Players_GetCurrentSessions_PayloadJSON = {
  /**
   * Serializes Players_GetCurrentSessions_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetCurrentSessions_Payload>): string {
    return JSON.stringify(
      Players_GetCurrentSessions_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetCurrentSessions_Payload from JSON.
   */
  decode: function (json: string): Players_GetCurrentSessions_Payload {
    return Players_GetCurrentSessions_PayloadJSON._readMessage(
      Players_GetCurrentSessions_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetCurrentSessions_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetCurrentSessions_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetCurrentSessions_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetCurrentSessions_Payload,
    json: any
  ): Players_GetCurrentSessions_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    return msg;
  },
};

export const Players_GetCurrentSessions_ResponseJSON = {
  /**
   * Serializes Players_GetCurrentSessions_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetCurrentSessions_Response>): string {
    return JSON.stringify(
      Players_GetCurrentSessions_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetCurrentSessions_Response from JSON.
   */
  decode: function (json: string): Players_GetCurrentSessions_Response {
    return Players_GetCurrentSessions_ResponseJSON._readMessage(
      Players_GetCurrentSessions_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetCurrentSessions_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetCurrentSessions_Response {
    return {
      sessions: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetCurrentSessions_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessions?.length) {
      json["sessions"] = msg.sessions.map(
        atoms.CurrentSessionJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetCurrentSessions_Response,
    json: any
  ): Players_GetCurrentSessions_Response {
    const _sessions_ = json["sessions"];
    if (_sessions_) {
      for (const item of _sessions_) {
        const m = atoms.CurrentSession.initialize();
        atoms.CurrentSessionJSON._readMessage(m, item);
        msg.sessions.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetAllRegisteredPlayers_PayloadJSON = {
  /**
   * Serializes Events_GetAllRegisteredPlayers_Payload to JSON.
   */
  encode: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Payload>
  ): string {
    return JSON.stringify(
      Events_GetAllRegisteredPlayers_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetAllRegisteredPlayers_Payload from JSON.
   */
  decode: function (json: string): Events_GetAllRegisteredPlayers_Payload {
    return Events_GetAllRegisteredPlayers_PayloadJSON._readMessage(
      Events_GetAllRegisteredPlayers_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetAllRegisteredPlayers_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAllRegisteredPlayers_Payload {
    return {
      eventIds: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIds?.length) {
      json["eventIds"] = msg.eventIds;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAllRegisteredPlayers_Payload,
    json: any
  ): Events_GetAllRegisteredPlayers_Payload {
    const _eventIds_ = json["eventIds"];
    if (_eventIds_) {
      msg.eventIds = _eventIds_;
    }
    return msg;
  },
};

export const Events_GetAllRegisteredPlayers_ResponseJSON = {
  /**
   * Serializes Events_GetAllRegisteredPlayers_Response to JSON.
   */
  encode: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Response>
  ): string {
    return JSON.stringify(
      Events_GetAllRegisteredPlayers_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetAllRegisteredPlayers_Response from JSON.
   */
  decode: function (json: string): Events_GetAllRegisteredPlayers_Response {
    return Events_GetAllRegisteredPlayers_ResponseJSON._readMessage(
      Events_GetAllRegisteredPlayers_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetAllRegisteredPlayers_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAllRegisteredPlayers_Response {
    return {
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAllRegisteredPlayers_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players?.length) {
      json["players"] = msg.players.map(
        atoms.RegisteredPlayerJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAllRegisteredPlayers_Response,
    json: any
  ): Events_GetAllRegisteredPlayers_Response {
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = atoms.RegisteredPlayer.initialize();
        atoms.RegisteredPlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetTimerState_ResponseJSON = {
  /**
   * Serializes Events_GetTimerState_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetTimerState_Response>): string {
    return JSON.stringify(Events_GetTimerState_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_GetTimerState_Response from JSON.
   */
  decode: function (json: string): Events_GetTimerState_Response {
    return Events_GetTimerState_ResponseJSON._readMessage(
      Events_GetTimerState_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetTimerState_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTimerState_Response {
    return {
      started: false,
      finished: false,
      timeRemaining: 0,
      waitingForTimer: false,
      haveAutostart: false,
      autostartTimer: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTimerState_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.started) {
      json["started"] = msg.started;
    }
    if (msg.finished) {
      json["finished"] = msg.finished;
    }
    if (msg.timeRemaining) {
      json["timeRemaining"] = msg.timeRemaining;
    }
    if (msg.waitingForTimer) {
      json["waitingForTimer"] = msg.waitingForTimer;
    }
    if (msg.haveAutostart) {
      json["haveAutostart"] = msg.haveAutostart;
    }
    if (msg.autostartTimer) {
      json["autostartTimer"] = msg.autostartTimer;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTimerState_Response,
    json: any
  ): Events_GetTimerState_Response {
    const _started_ = json["started"];
    if (_started_) {
      msg.started = _started_;
    }
    const _finished_ = json["finished"];
    if (_finished_) {
      msg.finished = _finished_;
    }
    const _timeRemaining_ = json["timeRemaining"];
    if (_timeRemaining_) {
      msg.timeRemaining = _timeRemaining_;
    }
    const _waitingForTimer_ = json["waitingForTimer"];
    if (_waitingForTimer_) {
      msg.waitingForTimer = _waitingForTimer_;
    }
    const _haveAutostart_ = json["haveAutostart"];
    if (_haveAutostart_) {
      msg.haveAutostart = _haveAutostart_;
    }
    const _autostartTimer_ = json["autostartTimer"];
    if (_autostartTimer_) {
      msg.autostartTimer = _autostartTimer_;
    }
    return msg;
  },
};

export const Games_GetSessionOverview_PayloadJSON = {
  /**
   * Serializes Games_GetSessionOverview_Payload to JSON.
   */
  encode: function (msg: Partial<Games_GetSessionOverview_Payload>): string {
    return JSON.stringify(
      Games_GetSessionOverview_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Games_GetSessionOverview_Payload from JSON.
   */
  decode: function (json: string): Games_GetSessionOverview_Payload {
    return Games_GetSessionOverview_PayloadJSON._readMessage(
      Games_GetSessionOverview_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_GetSessionOverview_Payload with all fields set to their default value.
   */
  initialize: function (): Games_GetSessionOverview_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_GetSessionOverview_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_GetSessionOverview_Payload,
    json: any
  ): Games_GetSessionOverview_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_GetSessionOverview_ResponseJSON = {
  /**
   * Serializes Games_GetSessionOverview_Response to JSON.
   */
  encode: function (msg: Partial<Games_GetSessionOverview_Response>): string {
    return JSON.stringify(
      Games_GetSessionOverview_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Games_GetSessionOverview_Response from JSON.
   */
  decode: function (json: string): Games_GetSessionOverview_Response {
    return Games_GetSessionOverview_ResponseJSON._readMessage(
      Games_GetSessionOverview_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_GetSessionOverview_Response with all fields set to their default value.
   */
  initialize: function (): Games_GetSessionOverview_Response {
    return {
      id: 0,
      eventId: 0,
      tableIndex: undefined,
      players: [],
      state: atoms.SessionStateJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_GetSessionOverview_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.tableIndex != undefined) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(
        atoms.PlayerInSessionJSON._writeMessage
      );
    }
    if (msg.state) {
      const _state_ = atoms.SessionStateJSON._writeMessage(msg.state);
      if (Object.keys(_state_).length > 0) {
        json["state"] = _state_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_GetSessionOverview_Response,
    json: any
  ): Games_GetSessionOverview_Response {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _tableIndex_ = json["tableIndex"];
    if (_tableIndex_) {
      msg.tableIndex = _tableIndex_;
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = atoms.PlayerInSession.initialize();
        atoms.PlayerInSessionJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _state_ = json["state"];
    if (_state_) {
      const m = atoms.SessionState.initialize();
      atoms.SessionStateJSON._readMessage(m, _state_);
      msg.state = m;
    }
    return msg;
  },
};

export const Players_GetPlayerStats_PayloadJSON = {
  /**
   * Serializes Players_GetPlayerStats_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetPlayerStats_Payload>): string {
    return JSON.stringify(
      Players_GetPlayerStats_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetPlayerStats_Payload from JSON.
   */
  decode: function (json: string): Players_GetPlayerStats_Payload {
    return Players_GetPlayerStats_PayloadJSON._readMessage(
      Players_GetPlayerStats_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetPlayerStats_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayerStats_Payload {
    return {
      playerId: 0,
      eventIdList: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayerStats_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayerStats_Payload,
    json: any
  ): Players_GetPlayerStats_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventIdList_ = json["eventIdList"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_;
    }
    return msg;
  },
};

export const Players_GetPlayerStats_ResponseJSON = {
  /**
   * Serializes Players_GetPlayerStats_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetPlayerStats_Response>): string {
    return JSON.stringify(
      Players_GetPlayerStats_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetPlayerStats_Response from JSON.
   */
  decode: function (json: string): Players_GetPlayerStats_Response {
    return Players_GetPlayerStats_ResponseJSON._readMessage(
      Players_GetPlayerStats_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetPlayerStats_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayerStats_Response {
    return {
      ratingHistory: [],
      scoreHistory: [],
      playersInfo: [],
      placesSummary: [],
      totalPlayedGames: 0,
      totalPlayedRounds: 0,
      winSummary: atoms.PlayerWinSummaryJSON.initialize(),
      handsValueSummary: [],
      yakuSummary: [],
      riichiSummary: atoms.RiichiSummaryJSON.initialize(),
      doraStat: atoms.DoraSummaryJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayerStats_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ratingHistory?.length) {
      json["ratingHistory"] = msg.ratingHistory;
    }
    if (msg.scoreHistory?.length) {
      json["scoreHistory"] = msg.scoreHistory.map(
        atoms.SessionHistoryResultTableJSON._writeMessage
      );
    }
    if (msg.playersInfo?.length) {
      json["playersInfo"] = msg.playersInfo.map(atoms.PlayerJSON._writeMessage);
    }
    if (msg.placesSummary?.length) {
      json["placesSummary"] = msg.placesSummary.map(
        atoms.PlacesSummaryItemJSON._writeMessage
      );
    }
    if (msg.totalPlayedGames) {
      json["totalPlayedGames"] = msg.totalPlayedGames;
    }
    if (msg.totalPlayedRounds) {
      json["totalPlayedRounds"] = msg.totalPlayedRounds;
    }
    if (msg.winSummary) {
      const _winSummary_ = atoms.PlayerWinSummaryJSON._writeMessage(
        msg.winSummary
      );
      if (Object.keys(_winSummary_).length > 0) {
        json["winSummary"] = _winSummary_;
      }
    }
    if (msg.handsValueSummary?.length) {
      json["handsValueSummary"] = msg.handsValueSummary.map(
        atoms.HandValueStatJSON._writeMessage
      );
    }
    if (msg.yakuSummary?.length) {
      json["yakuSummary"] = msg.yakuSummary.map(
        atoms.YakuStatJSON._writeMessage
      );
    }
    if (msg.riichiSummary) {
      const _riichiSummary_ = atoms.RiichiSummaryJSON._writeMessage(
        msg.riichiSummary
      );
      if (Object.keys(_riichiSummary_).length > 0) {
        json["riichiSummary"] = _riichiSummary_;
      }
    }
    if (msg.doraStat) {
      const _doraStat_ = atoms.DoraSummaryJSON._writeMessage(msg.doraStat);
      if (Object.keys(_doraStat_).length > 0) {
        json["doraStat"] = _doraStat_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayerStats_Response,
    json: any
  ): Players_GetPlayerStats_Response {
    const _ratingHistory_ = json["ratingHistory"];
    if (_ratingHistory_) {
      msg.ratingHistory = _ratingHistory_;
    }
    const _scoreHistory_ = json["scoreHistory"];
    if (_scoreHistory_) {
      for (const item of _scoreHistory_) {
        const m = atoms.SessionHistoryResultTable.initialize();
        atoms.SessionHistoryResultTableJSON._readMessage(m, item);
        msg.scoreHistory.push(m);
      }
    }
    const _playersInfo_ = json["playersInfo"];
    if (_playersInfo_) {
      for (const item of _playersInfo_) {
        const m = atoms.Player.initialize();
        atoms.PlayerJSON._readMessage(m, item);
        msg.playersInfo.push(m);
      }
    }
    const _placesSummary_ = json["placesSummary"];
    if (_placesSummary_) {
      for (const item of _placesSummary_) {
        const m = atoms.PlacesSummaryItem.initialize();
        atoms.PlacesSummaryItemJSON._readMessage(m, item);
        msg.placesSummary.push(m);
      }
    }
    const _totalPlayedGames_ = json["totalPlayedGames"];
    if (_totalPlayedGames_) {
      msg.totalPlayedGames = _totalPlayedGames_;
    }
    const _totalPlayedRounds_ = json["totalPlayedRounds"];
    if (_totalPlayedRounds_) {
      msg.totalPlayedRounds = _totalPlayedRounds_;
    }
    const _winSummary_ = json["winSummary"];
    if (_winSummary_) {
      const m = atoms.PlayerWinSummary.initialize();
      atoms.PlayerWinSummaryJSON._readMessage(m, _winSummary_);
      msg.winSummary = m;
    }
    const _handsValueSummary_ = json["handsValueSummary"];
    if (_handsValueSummary_) {
      for (const item of _handsValueSummary_) {
        const m = atoms.HandValueStat.initialize();
        atoms.HandValueStatJSON._readMessage(m, item);
        msg.handsValueSummary.push(m);
      }
    }
    const _yakuSummary_ = json["yakuSummary"];
    if (_yakuSummary_) {
      for (const item of _yakuSummary_) {
        const m = atoms.YakuStat.initialize();
        atoms.YakuStatJSON._readMessage(m, item);
        msg.yakuSummary.push(m);
      }
    }
    const _riichiSummary_ = json["riichiSummary"];
    if (_riichiSummary_) {
      const m = atoms.RiichiSummary.initialize();
      atoms.RiichiSummaryJSON._readMessage(m, _riichiSummary_);
      msg.riichiSummary = m;
    }
    const _doraStat_ = json["doraStat"];
    if (_doraStat_) {
      const m = atoms.DoraSummary.initialize();
      atoms.DoraSummaryJSON._readMessage(m, _doraStat_);
      msg.doraStat = m;
    }
    return msg;
  },
};

export const Games_AddRound_PayloadJSON = {
  /**
   * Serializes Games_AddRound_Payload to JSON.
   */
  encode: function (msg: Partial<Games_AddRound_Payload>): string {
    return JSON.stringify(Games_AddRound_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddRound_Payload from JSON.
   */
  decode: function (json: string): Games_AddRound_Payload {
    return Games_AddRound_PayloadJSON._readMessage(
      Games_AddRound_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddRound_Payload {
    return {
      sessionHash: "",
      roundData: atoms.RoundJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddRound_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.roundData) {
      const _roundData_ = atoms.RoundJSON._writeMessage(msg.roundData);
      if (Object.keys(_roundData_).length > 0) {
        json["roundData"] = _roundData_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddRound_Payload,
    json: any
  ): Games_AddRound_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _roundData_ = json["roundData"];
    if (_roundData_) {
      const m = atoms.Round.initialize();
      atoms.RoundJSON._readMessage(m, _roundData_);
      msg.roundData = m;
    }
    return msg;
  },
};

export const Games_AddRound_ResponseJSON = {
  /**
   * Serializes Games_AddRound_Response to JSON.
   */
  encode: function (msg: Partial<Games_AddRound_Response>): string {
    return JSON.stringify(Games_AddRound_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddRound_Response from JSON.
   */
  decode: function (json: string): Games_AddRound_Response {
    return Games_AddRound_ResponseJSON._readMessage(
      Games_AddRound_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddRound_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddRound_Response {
    return {
      scores: [],
      extraPenaltyLog: [],
      round: 0,
      honba: 0,
      riichiBets: 0,
      prematurelyFinished: false,
      roundJustChanged: false,
      isFinished: false,
      yellowZoneAlreadyPlayed: false,
      lastOutcome: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddRound_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scores?.length) {
      json["scores"] = msg.scores.map(
        atoms.IntermediateResultOfSessionJSON._writeMessage
      );
    }
    if (msg.extraPenaltyLog?.length) {
      json["extraPenaltyLog"] = msg.extraPenaltyLog.map(
        atoms.PenaltyJSON._writeMessage
      );
    }
    if (msg.round) {
      json["round"] = msg.round;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiBets) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.prematurelyFinished) {
      json["prematurelyFinished"] = msg.prematurelyFinished;
    }
    if (msg.roundJustChanged) {
      json["roundJustChanged"] = msg.roundJustChanged;
    }
    if (msg.isFinished) {
      json["isFinished"] = msg.isFinished;
    }
    if (msg.yellowZoneAlreadyPlayed) {
      json["yellowZoneAlreadyPlayed"] = msg.yellowZoneAlreadyPlayed;
    }
    if (msg.lastOutcome != undefined) {
      json["lastOutcome"] = msg.lastOutcome;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddRound_Response,
    json: any
  ): Games_AddRound_Response {
    const _scores_ = json["scores"];
    if (_scores_) {
      for (const item of _scores_) {
        const m = atoms.IntermediateResultOfSession.initialize();
        atoms.IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scores.push(m);
      }
    }
    const _extraPenaltyLog_ = json["extraPenaltyLog"];
    if (_extraPenaltyLog_) {
      for (const item of _extraPenaltyLog_) {
        const m = atoms.Penalty.initialize();
        atoms.PenaltyJSON._readMessage(m, item);
        msg.extraPenaltyLog.push(m);
      }
    }
    const _round_ = json["round"];
    if (_round_) {
      msg.round = _round_;
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = _honba_;
    }
    const _riichiBets_ = json["riichiBets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_;
    }
    const _prematurelyFinished_ = json["prematurelyFinished"];
    if (_prematurelyFinished_) {
      msg.prematurelyFinished = _prematurelyFinished_;
    }
    const _roundJustChanged_ = json["roundJustChanged"];
    if (_roundJustChanged_) {
      msg.roundJustChanged = _roundJustChanged_;
    }
    const _isFinished_ = json["isFinished"];
    if (_isFinished_) {
      msg.isFinished = _isFinished_;
    }
    const _yellowZoneAlreadyPlayed_ = json["yellowZoneAlreadyPlayed"];
    if (_yellowZoneAlreadyPlayed_) {
      msg.yellowZoneAlreadyPlayed = _yellowZoneAlreadyPlayed_;
    }
    const _lastOutcome_ = json["lastOutcome"];
    if (_lastOutcome_) {
      msg.lastOutcome = _lastOutcome_;
    }
    return msg;
  },
};

export const Games_PreviewRound_PayloadJSON = {
  /**
   * Serializes Games_PreviewRound_Payload to JSON.
   */
  encode: function (msg: Partial<Games_PreviewRound_Payload>): string {
    return JSON.stringify(Games_PreviewRound_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_PreviewRound_Payload from JSON.
   */
  decode: function (json: string): Games_PreviewRound_Payload {
    return Games_PreviewRound_PayloadJSON._readMessage(
      Games_PreviewRound_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_PreviewRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_PreviewRound_Payload {
    return {
      sessionHash: "",
      roundData: atoms.RoundJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_PreviewRound_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.roundData) {
      const _roundData_ = atoms.RoundJSON._writeMessage(msg.roundData);
      if (Object.keys(_roundData_).length > 0) {
        json["roundData"] = _roundData_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_PreviewRound_Payload,
    json: any
  ): Games_PreviewRound_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _roundData_ = json["roundData"];
    if (_roundData_) {
      const m = atoms.Round.initialize();
      atoms.RoundJSON._readMessage(m, _roundData_);
      msg.roundData = m;
    }
    return msg;
  },
};

export const Games_PreviewRound_ResponseJSON = {
  /**
   * Serializes Games_PreviewRound_Response to JSON.
   */
  encode: function (msg: Partial<Games_PreviewRound_Response>): string {
    return JSON.stringify(Games_PreviewRound_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_PreviewRound_Response from JSON.
   */
  decode: function (json: string): Games_PreviewRound_Response {
    return Games_PreviewRound_ResponseJSON._readMessage(
      Games_PreviewRound_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_PreviewRound_Response with all fields set to their default value.
   */
  initialize: function (): Games_PreviewRound_Response {
    return {
      state: atoms.RoundStateJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_PreviewRound_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.state) {
      const _state_ = atoms.RoundStateJSON._writeMessage(msg.state);
      if (Object.keys(_state_).length > 0) {
        json["state"] = _state_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_PreviewRound_Response,
    json: any
  ): Games_PreviewRound_Response {
    const _state_ = json["state"];
    if (_state_) {
      const m = atoms.RoundState.initialize();
      atoms.RoundStateJSON._readMessage(m, _state_);
      msg.state = m;
    }
    return msg;
  },
};

export const Games_AddOnlineReplay_PayloadJSON = {
  /**
   * Serializes Games_AddOnlineReplay_Payload to JSON.
   */
  encode: function (msg: Partial<Games_AddOnlineReplay_Payload>): string {
    return JSON.stringify(Games_AddOnlineReplay_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddOnlineReplay_Payload from JSON.
   */
  decode: function (json: string): Games_AddOnlineReplay_Payload {
    return Games_AddOnlineReplay_PayloadJSON._readMessage(
      Games_AddOnlineReplay_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddOnlineReplay_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddOnlineReplay_Payload {
    return {
      eventId: 0,
      link: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddOnlineReplay_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.link) {
      json["link"] = msg.link;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddOnlineReplay_Payload,
    json: any
  ): Games_AddOnlineReplay_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _link_ = json["link"];
    if (_link_) {
      msg.link = _link_;
    }
    return msg;
  },
};

export const Games_AddOnlineReplay_ResponseJSON = {
  /**
   * Serializes Games_AddOnlineReplay_Response to JSON.
   */
  encode: function (msg: Partial<Games_AddOnlineReplay_Response>): string {
    return JSON.stringify(
      Games_AddOnlineReplay_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Games_AddOnlineReplay_Response from JSON.
   */
  decode: function (json: string): Games_AddOnlineReplay_Response {
    return Games_AddOnlineReplay_ResponseJSON._readMessage(
      Games_AddOnlineReplay_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddOnlineReplay_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddOnlineReplay_Response {
    return {
      game: atoms.GameResultJSON.initialize(),
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddOnlineReplay_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.game) {
      const _game_ = atoms.GameResultJSON._writeMessage(msg.game);
      if (Object.keys(_game_).length > 0) {
        json["game"] = _game_;
      }
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(atoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddOnlineReplay_Response,
    json: any
  ): Games_AddOnlineReplay_Response {
    const _game_ = json["game"];
    if (_game_) {
      const m = atoms.GameResult.initialize();
      atoms.GameResultJSON._readMessage(m, _game_);
      msg.game = m;
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = atoms.Player.initialize();
        atoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const Players_GetLastResults_PayloadJSON = {
  /**
   * Serializes Players_GetLastResults_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetLastResults_Payload>): string {
    return JSON.stringify(
      Players_GetLastResults_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetLastResults_Payload from JSON.
   */
  decode: function (json: string): Players_GetLastResults_Payload {
    return Players_GetLastResults_PayloadJSON._readMessage(
      Players_GetLastResults_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastResults_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastResults_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastResults_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastResults_Payload,
    json: any
  ): Players_GetLastResults_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    return msg;
  },
};

export const Players_GetLastResults_ResponseJSON = {
  /**
   * Serializes Players_GetLastResults_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetLastResults_Response>): string {
    return JSON.stringify(
      Players_GetLastResults_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetLastResults_Response from JSON.
   */
  decode: function (json: string): Players_GetLastResults_Response {
    return Players_GetLastResults_ResponseJSON._readMessage(
      Players_GetLastResults_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastResults_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastResults_Response {
    return {
      results: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastResults_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.results?.length) {
      json["results"] = msg.results.map(
        atoms.SessionHistoryResultJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastResults_Response,
    json: any
  ): Players_GetLastResults_Response {
    const _results_ = json["results"];
    if (_results_) {
      for (const item of _results_) {
        const m = atoms.SessionHistoryResult.initialize();
        atoms.SessionHistoryResultJSON._readMessage(m, item);
        msg.results.push(m);
      }
    }
    return msg;
  },
};

export const Players_GetLastRound_PayloadJSON = {
  /**
   * Serializes Players_GetLastRound_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetLastRound_Payload>): string {
    return JSON.stringify(Players_GetLastRound_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetLastRound_Payload from JSON.
   */
  decode: function (json: string): Players_GetLastRound_Payload {
    return Players_GetLastRound_PayloadJSON._readMessage(
      Players_GetLastRound_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastRound_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRound_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRound_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRound_Payload,
    json: any
  ): Players_GetLastRound_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    return msg;
  },
};

export const Players_GetLastRound_ResponseJSON = {
  /**
   * Serializes Players_GetLastRound_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetLastRound_Response>): string {
    return JSON.stringify(Players_GetLastRound_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetLastRound_Response from JSON.
   */
  decode: function (json: string): Players_GetLastRound_Response {
    return Players_GetLastRound_ResponseJSON._readMessage(
      Players_GetLastRound_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastRound_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRound_Response {
    return {
      round: atoms.RoundStateJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRound_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.round) {
      const _round_ = atoms.RoundStateJSON._writeMessage(msg.round);
      if (Object.keys(_round_).length > 0) {
        json["round"] = _round_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRound_Response,
    json: any
  ): Players_GetLastRound_Response {
    const _round_ = json["round"];
    if (_round_) {
      const m = atoms.RoundState.initialize();
      atoms.RoundStateJSON._readMessage(m, _round_);
      msg.round = m;
    }
    return msg;
  },
};

export const Players_GetAllRounds_PayloadJSON = {
  /**
   * Serializes Players_GetAllRounds_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetAllRounds_Payload>): string {
    return JSON.stringify(Players_GetAllRounds_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetAllRounds_Payload from JSON.
   */
  decode: function (json: string): Players_GetAllRounds_Payload {
    return Players_GetAllRounds_PayloadJSON._readMessage(
      Players_GetAllRounds_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetAllRounds_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetAllRounds_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetAllRounds_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetAllRounds_Payload,
    json: any
  ): Players_GetAllRounds_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Players_GetAllRounds_ResponseJSON = {
  /**
   * Serializes Players_GetAllRounds_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetAllRounds_Response>): string {
    return JSON.stringify(Players_GetAllRounds_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetAllRounds_Response from JSON.
   */
  decode: function (json: string): Players_GetAllRounds_Response {
    return Players_GetAllRounds_ResponseJSON._readMessage(
      Players_GetAllRounds_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetAllRounds_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetAllRounds_Response {
    return {
      round: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetAllRounds_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.round?.length) {
      json["round"] = msg.round.map(atoms.RoundStateJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetAllRounds_Response,
    json: any
  ): Players_GetAllRounds_Response {
    const _round_ = json["round"];
    if (_round_) {
      for (const item of _round_) {
        const m = atoms.RoundState.initialize();
        atoms.RoundStateJSON._readMessage(m, item);
        msg.round.push(m);
      }
    }
    return msg;
  },
};

export const Players_GetLastRoundByHash_PayloadJSON = {
  /**
   * Serializes Players_GetLastRoundByHash_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetLastRoundByHash_Payload>): string {
    return JSON.stringify(
      Players_GetLastRoundByHash_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetLastRoundByHash_Payload from JSON.
   */
  decode: function (json: string): Players_GetLastRoundByHash_Payload {
    return Players_GetLastRoundByHash_PayloadJSON._readMessage(
      Players_GetLastRoundByHash_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastRoundByHash_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRoundByHash_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRoundByHash_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRoundByHash_Payload,
    json: any
  ): Players_GetLastRoundByHash_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Players_GetLastRoundByHash_ResponseJSON = {
  /**
   * Serializes Players_GetLastRoundByHash_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetLastRoundByHash_Response>): string {
    return JSON.stringify(
      Players_GetLastRoundByHash_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Players_GetLastRoundByHash_Response from JSON.
   */
  decode: function (json: string): Players_GetLastRoundByHash_Response {
    return Players_GetLastRoundByHash_ResponseJSON._readMessage(
      Players_GetLastRoundByHash_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetLastRoundByHash_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetLastRoundByHash_Response {
    return {
      round: atoms.RoundStateJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetLastRoundByHash_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.round) {
      const _round_ = atoms.RoundStateJSON._writeMessage(msg.round);
      if (Object.keys(_round_).length > 0) {
        json["round"] = _round_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetLastRoundByHash_Response,
    json: any
  ): Players_GetLastRoundByHash_Response {
    const _round_ = json["round"];
    if (_round_) {
      const m = atoms.RoundState.initialize();
      atoms.RoundStateJSON._readMessage(m, _round_);
      msg.round = m;
    }
    return msg;
  },
};

export const Events_GetEventForEdit_PayloadJSON = {
  /**
   * Serializes Events_GetEventForEdit_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetEventForEdit_Payload>): string {
    return JSON.stringify(
      Events_GetEventForEdit_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetEventForEdit_Payload from JSON.
   */
  decode: function (json: string): Events_GetEventForEdit_Payload {
    return Events_GetEventForEdit_PayloadJSON._readMessage(
      Events_GetEventForEdit_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEventForEdit_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetEventForEdit_Payload {
    return {
      id: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventForEdit_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventForEdit_Payload,
    json: any
  ): Events_GetEventForEdit_Payload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const Events_GetEventForEdit_ResponseJSON = {
  /**
   * Serializes Events_GetEventForEdit_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetEventForEdit_Response>): string {
    return JSON.stringify(
      Events_GetEventForEdit_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetEventForEdit_Response from JSON.
   */
  decode: function (json: string): Events_GetEventForEdit_Response {
    return Events_GetEventForEdit_ResponseJSON._readMessage(
      Events_GetEventForEdit_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetEventForEdit_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetEventForEdit_Response {
    return {
      id: 0,
      event: atoms.EventDataJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetEventForEdit_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.event) {
      const _event_ = atoms.EventDataJSON._writeMessage(msg.event);
      if (Object.keys(_event_).length > 0) {
        json["event"] = _event_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetEventForEdit_Response,
    json: any
  ): Events_GetEventForEdit_Response {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _event_ = json["event"];
    if (_event_) {
      const m = atoms.EventData.initialize();
      atoms.EventDataJSON._readMessage(m, _event_);
      msg.event = m;
    }
    return msg;
  },
};

export const Events_UpdateEvent_PayloadJSON = {
  /**
   * Serializes Events_UpdateEvent_Payload to JSON.
   */
  encode: function (msg: Partial<Events_UpdateEvent_Payload>): string {
    return JSON.stringify(Events_UpdateEvent_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_UpdateEvent_Payload from JSON.
   */
  decode: function (json: string): Events_UpdateEvent_Payload {
    return Events_UpdateEvent_PayloadJSON._readMessage(
      Events_UpdateEvent_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdateEvent_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdateEvent_Payload {
    return {
      id: 0,
      event: atoms.EventDataJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdateEvent_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.event) {
      const _event_ = atoms.EventDataJSON._writeMessage(msg.event);
      if (Object.keys(_event_).length > 0) {
        json["event"] = _event_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdateEvent_Payload,
    json: any
  ): Events_UpdateEvent_Payload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _event_ = json["event"];
    if (_event_) {
      const m = atoms.EventData.initialize();
      atoms.EventDataJSON._readMessage(m, _event_);
      msg.event = m;
    }
    return msg;
  },
};

export const Events_GetTablesState_ResponseJSON = {
  /**
   * Serializes Events_GetTablesState_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetTablesState_Response>): string {
    return JSON.stringify(
      Events_GetTablesState_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetTablesState_Response from JSON.
   */
  decode: function (json: string): Events_GetTablesState_Response {
    return Events_GetTablesState_ResponseJSON._readMessage(
      Events_GetTablesState_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetTablesState_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetTablesState_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetTablesState_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(atoms.TableStateJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetTablesState_Response,
    json: any
  ): Events_GetTablesState_Response {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = atoms.TableState.initialize();
        atoms.TableStateJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const Events_RegisterPlayer_PayloadJSON = {
  /**
   * Serializes Events_RegisterPlayer_Payload to JSON.
   */
  encode: function (msg: Partial<Events_RegisterPlayer_Payload>): string {
    return JSON.stringify(Events_RegisterPlayer_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Events_RegisterPlayer_Payload from JSON.
   */
  decode: function (json: string): Events_RegisterPlayer_Payload {
    return Events_RegisterPlayer_PayloadJSON._readMessage(
      Events_RegisterPlayer_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_RegisterPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Events_RegisterPlayer_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_RegisterPlayer_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_RegisterPlayer_Payload,
    json: any
  ): Events_RegisterPlayer_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    return msg;
  },
};

export const Events_UnregisterPlayer_PayloadJSON = {
  /**
   * Serializes Events_UnregisterPlayer_Payload to JSON.
   */
  encode: function (msg: Partial<Events_UnregisterPlayer_Payload>): string {
    return JSON.stringify(
      Events_UnregisterPlayer_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UnregisterPlayer_Payload from JSON.
   */
  decode: function (json: string): Events_UnregisterPlayer_Payload {
    return Events_UnregisterPlayer_PayloadJSON._readMessage(
      Events_UnregisterPlayer_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UnregisterPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UnregisterPlayer_Payload {
    return {
      playerId: 0,
      eventId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UnregisterPlayer_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UnregisterPlayer_Payload,
    json: any
  ): Events_UnregisterPlayer_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    return msg;
  },
};

export const Events_UpdatePlayerSeatingFlag_PayloadJSON = {
  /**
   * Serializes Events_UpdatePlayerSeatingFlag_Payload to JSON.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayerSeatingFlag_Payload>
  ): string {
    return JSON.stringify(
      Events_UpdatePlayerSeatingFlag_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UpdatePlayerSeatingFlag_Payload from JSON.
   */
  decode: function (json: string): Events_UpdatePlayerSeatingFlag_Payload {
    return Events_UpdatePlayerSeatingFlag_PayloadJSON._readMessage(
      Events_UpdatePlayerSeatingFlag_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdatePlayerSeatingFlag_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayerSeatingFlag_Payload {
    return {
      playerId: 0,
      eventId: 0,
      ignoreSeating: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayerSeatingFlag_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.ignoreSeating) {
      json["ignoreSeating"] = msg.ignoreSeating;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayerSeatingFlag_Payload,
    json: any
  ): Events_UpdatePlayerSeatingFlag_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _ignoreSeating_ = json["ignoreSeating"];
    if (_ignoreSeating_) {
      msg.ignoreSeating = _ignoreSeating_;
    }
    return msg;
  },
};

export const Events_GetAchievements_PayloadJSON = {
  /**
   * Serializes Events_GetAchievements_Payload to JSON.
   */
  encode: function (msg: Partial<Events_GetAchievements_Payload>): string {
    return JSON.stringify(
      Events_GetAchievements_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetAchievements_Payload from JSON.
   */
  decode: function (json: string): Events_GetAchievements_Payload {
    return Events_GetAchievements_PayloadJSON._readMessage(
      Events_GetAchievements_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetAchievements_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievements_Payload {
    return {
      eventIds: [],
      achievementsList: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievements_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIds?.length) {
      json["eventIds"] = msg.eventIds;
    }
    if (msg.achievementsList?.length) {
      json["achievementsList"] = msg.achievementsList;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievements_Payload,
    json: any
  ): Events_GetAchievements_Payload {
    const _eventIds_ = json["eventIds"];
    if (_eventIds_) {
      msg.eventIds = _eventIds_;
    }
    const _achievementsList_ = json["achievementsList"];
    if (_achievementsList_) {
      msg.achievementsList = _achievementsList_;
    }
    return msg;
  },
};

export const Events_GetAchievements_ResponseJSON = {
  /**
   * Serializes Events_GetAchievements_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetAchievements_Response>): string {
    return JSON.stringify(
      Events_GetAchievements_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetAchievements_Response from JSON.
   */
  decode: function (json: string): Events_GetAchievements_Response {
    return Events_GetAchievements_ResponseJSON._readMessage(
      Events_GetAchievements_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetAchievements_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievements_Response {
    return {
      achievements: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievements_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.achievements?.length) {
      json["achievements"] = msg.achievements.map(
        atoms.AchievementJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievements_Response,
    json: any
  ): Events_GetAchievements_Response {
    const _achievements_ = json["achievements"];
    if (_achievements_) {
      for (const item of _achievements_) {
        const m = atoms.Achievement.initialize();
        atoms.AchievementJSON._readMessage(m, item);
        msg.achievements.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetAchievementsList_PayloadJSON = {
  /**
   * Serializes Events_GetAchievementsList_Payload to JSON.
   */
  encode: function (
    _msg?: Partial<Events_GetAchievementsList_Payload>
  ): string {
    return "{}";
  },

  /**
   * Deserializes Events_GetAchievementsList_Payload from JSON.
   */
  decode: function (_json?: string): Events_GetAchievementsList_Payload {
    return {};
  },

  /**
   * Initializes Events_GetAchievementsList_Payload with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievementsList_Payload {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Events_GetAchievementsList_Payload>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievementsList_Payload,
    _json: any
  ): Events_GetAchievementsList_Payload {
    return msg;
  },
};

export const Events_GetAchievementsList_ResponseJSON = {
  /**
   * Serializes Events_GetAchievementsList_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetAchievementsList_Response>): string {
    return JSON.stringify(
      Events_GetAchievementsList_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetAchievementsList_Response from JSON.
   */
  decode: function (json: string): Events_GetAchievementsList_Response {
    return Events_GetAchievementsList_ResponseJSON._readMessage(
      Events_GetAchievementsList_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetAchievementsList_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetAchievementsList_Response {
    return {
      list: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetAchievementsList_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.list?.length) {
      json["list"] = msg.list;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetAchievementsList_Response,
    json: any
  ): Events_GetAchievementsList_Response {
    const _list_ = json["list"];
    if (_list_) {
      msg.list = _list_;
    }
    return msg;
  },
};

export const Events_UpdatePlayersLocalIds_PayloadJSON = {
  /**
   * Serializes Events_UpdatePlayersLocalIds_Payload to JSON.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayersLocalIds_Payload>
  ): string {
    return JSON.stringify(
      Events_UpdatePlayersLocalIds_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UpdatePlayersLocalIds_Payload from JSON.
   */
  decode: function (json: string): Events_UpdatePlayersLocalIds_Payload {
    return Events_UpdatePlayersLocalIds_PayloadJSON._readMessage(
      Events_UpdatePlayersLocalIds_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdatePlayersLocalIds_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayersLocalIds_Payload {
    return {
      eventId: 0,
      idMap: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayersLocalIds_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.idMap?.length) {
      json["idMap"] = msg.idMap.map(atoms.LocalIdMappingJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayersLocalIds_Payload,
    json: any
  ): Events_UpdatePlayersLocalIds_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _idMap_ = json["idMap"];
    if (_idMap_) {
      for (const item of _idMap_) {
        const m = atoms.LocalIdMapping.initialize();
        atoms.LocalIdMappingJSON._readMessage(m, item);
        msg.idMap.push(m);
      }
    }
    return msg;
  },
};

export const Events_UpdatePlayerReplacement_PayloadJSON = {
  /**
   * Serializes Events_UpdatePlayerReplacement_Payload to JSON.
   */
  encode: function (
    msg: Partial<Events_UpdatePlayerReplacement_Payload>
  ): string {
    return JSON.stringify(
      Events_UpdatePlayerReplacement_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UpdatePlayerReplacement_Payload from JSON.
   */
  decode: function (json: string): Events_UpdatePlayerReplacement_Payload {
    return Events_UpdatePlayerReplacement_PayloadJSON._readMessage(
      Events_UpdatePlayerReplacement_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdatePlayerReplacement_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayerReplacement_Payload {
    return {
      playerId: 0,
      eventId: 0,
      replacementId: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayerReplacement_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.replacementId) {
      json["replacementId"] = msg.replacementId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayerReplacement_Payload,
    json: any
  ): Events_UpdatePlayerReplacement_Payload {
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _replacementId_ = json["replacementId"];
    if (_replacementId_) {
      msg.replacementId = _replacementId_;
    }
    return msg;
  },
};

export const Events_UpdatePlayersTeams_PayloadJSON = {
  /**
   * Serializes Events_UpdatePlayersTeams_Payload to JSON.
   */
  encode: function (msg: Partial<Events_UpdatePlayersTeams_Payload>): string {
    return JSON.stringify(
      Events_UpdatePlayersTeams_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UpdatePlayersTeams_Payload from JSON.
   */
  decode: function (json: string): Events_UpdatePlayersTeams_Payload {
    return Events_UpdatePlayersTeams_PayloadJSON._readMessage(
      Events_UpdatePlayersTeams_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdatePlayersTeams_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePlayersTeams_Payload {
    return {
      eventId: 0,
      teamNameMap: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePlayersTeams_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.teamNameMap?.length) {
      json["teamNameMap"] = msg.teamNameMap.map(
        atoms.TeamMappingJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePlayersTeams_Payload,
    json: any
  ): Events_UpdatePlayersTeams_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _teamNameMap_ = json["teamNameMap"];
    if (_teamNameMap_) {
      for (const item of _teamNameMap_) {
        const m = atoms.TeamMapping.initialize();
        atoms.TeamMappingJSON._readMessage(m, item);
        msg.teamNameMap.push(m);
      }
    }
    return msg;
  },
};

export const Games_StartGame_PayloadJSON = {
  /**
   * Serializes Games_StartGame_Payload to JSON.
   */
  encode: function (msg: Partial<Games_StartGame_Payload>): string {
    return JSON.stringify(Games_StartGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_StartGame_Payload from JSON.
   */
  decode: function (json: string): Games_StartGame_Payload {
    return Games_StartGame_PayloadJSON._readMessage(
      Games_StartGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_StartGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_StartGame_Payload {
    return {
      eventId: 0,
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_StartGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.players?.length) {
      json["players"] = msg.players;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_StartGame_Payload,
    json: any
  ): Games_StartGame_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _players_ = json["players"];
    if (_players_) {
      msg.players = _players_;
    }
    return msg;
  },
};

export const Games_StartGame_ResponseJSON = {
  /**
   * Serializes Games_StartGame_Response to JSON.
   */
  encode: function (msg: Partial<Games_StartGame_Response>): string {
    return JSON.stringify(Games_StartGame_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_StartGame_Response from JSON.
   */
  decode: function (json: string): Games_StartGame_Response {
    return Games_StartGame_ResponseJSON._readMessage(
      Games_StartGame_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_StartGame_Response with all fields set to their default value.
   */
  initialize: function (): Games_StartGame_Response {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_StartGame_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_StartGame_Response,
    json: any
  ): Games_StartGame_Response {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_EndGame_PayloadJSON = {
  /**
   * Serializes Games_EndGame_Payload to JSON.
   */
  encode: function (msg: Partial<Games_EndGame_Payload>): string {
    return JSON.stringify(Games_EndGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_EndGame_Payload from JSON.
   */
  decode: function (json: string): Games_EndGame_Payload {
    return Games_EndGame_PayloadJSON._readMessage(
      Games_EndGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_EndGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_EndGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_EndGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_EndGame_Payload,
    json: any
  ): Games_EndGame_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_CancelGame_PayloadJSON = {
  /**
   * Serializes Games_CancelGame_Payload to JSON.
   */
  encode: function (msg: Partial<Games_CancelGame_Payload>): string {
    return JSON.stringify(Games_CancelGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_CancelGame_Payload from JSON.
   */
  decode: function (json: string): Games_CancelGame_Payload {
    return Games_CancelGame_PayloadJSON._readMessage(
      Games_CancelGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_CancelGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_CancelGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_CancelGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_CancelGame_Payload,
    json: any
  ): Games_CancelGame_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_DropLastRound_PayloadJSON = {
  /**
   * Serializes Games_DropLastRound_Payload to JSON.
   */
  encode: function (msg: Partial<Games_DropLastRound_Payload>): string {
    return JSON.stringify(Games_DropLastRound_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_DropLastRound_Payload from JSON.
   */
  decode: function (json: string): Games_DropLastRound_Payload {
    return Games_DropLastRound_PayloadJSON._readMessage(
      Games_DropLastRound_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_DropLastRound_Payload with all fields set to their default value.
   */
  initialize: function (): Games_DropLastRound_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_DropLastRound_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_DropLastRound_Payload,
    json: any
  ): Games_DropLastRound_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_DefinalizeGame_PayloadJSON = {
  /**
   * Serializes Games_DefinalizeGame_Payload to JSON.
   */
  encode: function (msg: Partial<Games_DefinalizeGame_Payload>): string {
    return JSON.stringify(Games_DefinalizeGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_DefinalizeGame_Payload from JSON.
   */
  decode: function (json: string): Games_DefinalizeGame_Payload {
    return Games_DefinalizeGame_PayloadJSON._readMessage(
      Games_DefinalizeGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_DefinalizeGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_DefinalizeGame_Payload {
    return {
      sessionHash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_DefinalizeGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_DefinalizeGame_Payload,
    json: any
  ): Games_DefinalizeGame_Payload {
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};

export const Games_AddPenalty_PayloadJSON = {
  /**
   * Serializes Games_AddPenalty_Payload to JSON.
   */
  encode: function (msg: Partial<Games_AddPenalty_Payload>): string {
    return JSON.stringify(Games_AddPenalty_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddPenalty_Payload from JSON.
   */
  decode: function (json: string): Games_AddPenalty_Payload {
    return Games_AddPenalty_PayloadJSON._readMessage(
      Games_AddPenalty_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddPenalty_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddPenalty_Payload {
    return {
      eventId: 0,
      playerId: 0,
      amount: 0,
      reason: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenalty_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.reason) {
      json["reason"] = msg.reason;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenalty_Payload,
    json: any
  ): Games_AddPenalty_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = _amount_;
    }
    const _reason_ = json["reason"];
    if (_reason_) {
      msg.reason = _reason_;
    }
    return msg;
  },
};

export const Games_AddPenaltyGame_PayloadJSON = {
  /**
   * Serializes Games_AddPenaltyGame_Payload to JSON.
   */
  encode: function (msg: Partial<Games_AddPenaltyGame_Payload>): string {
    return JSON.stringify(Games_AddPenaltyGame_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddPenaltyGame_Payload from JSON.
   */
  decode: function (json: string): Games_AddPenaltyGame_Payload {
    return Games_AddPenaltyGame_PayloadJSON._readMessage(
      Games_AddPenaltyGame_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddPenaltyGame_Payload with all fields set to their default value.
   */
  initialize: function (): Games_AddPenaltyGame_Payload {
    return {
      eventId: 0,
      players: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenaltyGame_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.players?.length) {
      json["players"] = msg.players;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenaltyGame_Payload,
    json: any
  ): Games_AddPenaltyGame_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _players_ = json["players"];
    if (_players_) {
      msg.players = _players_;
    }
    return msg;
  },
};

export const Games_AddPenaltyGame_ResponseJSON = {
  /**
   * Serializes Games_AddPenaltyGame_Response to JSON.
   */
  encode: function (msg: Partial<Games_AddPenaltyGame_Response>): string {
    return JSON.stringify(Games_AddPenaltyGame_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Games_AddPenaltyGame_Response from JSON.
   */
  decode: function (json: string): Games_AddPenaltyGame_Response {
    return Games_AddPenaltyGame_ResponseJSON._readMessage(
      Games_AddPenaltyGame_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Games_AddPenaltyGame_Response with all fields set to their default value.
   */
  initialize: function (): Games_AddPenaltyGame_Response {
    return {
      hash: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Games_AddPenaltyGame_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.hash) {
      json["hash"] = msg.hash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Games_AddPenaltyGame_Response,
    json: any
  ): Games_AddPenaltyGame_Response {
    const _hash_ = json["hash"];
    if (_hash_) {
      msg.hash = _hash_;
    }
    return msg;
  },
};

export const Players_GetPlayer_PayloadJSON = {
  /**
   * Serializes Players_GetPlayer_Payload to JSON.
   */
  encode: function (msg: Partial<Players_GetPlayer_Payload>): string {
    return JSON.stringify(Players_GetPlayer_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetPlayer_Payload from JSON.
   */
  decode: function (json: string): Players_GetPlayer_Payload {
    return Players_GetPlayer_PayloadJSON._readMessage(
      Players_GetPlayer_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetPlayer_Payload with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayer_Payload {
    return {
      id: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayer_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayer_Payload,
    json: any
  ): Players_GetPlayer_Payload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const Players_GetPlayer_ResponseJSON = {
  /**
   * Serializes Players_GetPlayer_Response to JSON.
   */
  encode: function (msg: Partial<Players_GetPlayer_Response>): string {
    return JSON.stringify(Players_GetPlayer_ResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes Players_GetPlayer_Response from JSON.
   */
  decode: function (json: string): Players_GetPlayer_Response {
    return Players_GetPlayer_ResponseJSON._readMessage(
      Players_GetPlayer_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Players_GetPlayer_Response with all fields set to their default value.
   */
  initialize: function (): Players_GetPlayer_Response {
    return {
      players: atoms.PlayerJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Players_GetPlayer_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players) {
      const _players_ = atoms.PlayerJSON._writeMessage(msg.players);
      if (Object.keys(_players_).length > 0) {
        json["players"] = _players_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Players_GetPlayer_Response,
    json: any
  ): Players_GetPlayer_Response {
    const _players_ = json["players"];
    if (_players_) {
      const m = atoms.Player.initialize();
      atoms.PlayerJSON._readMessage(m, _players_);
      msg.players = m;
    }
    return msg;
  },
};

export const Events_GetCurrentSeating_ResponseJSON = {
  /**
   * Serializes Events_GetCurrentSeating_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetCurrentSeating_Response>): string {
    return JSON.stringify(
      Events_GetCurrentSeating_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetCurrentSeating_Response from JSON.
   */
  decode: function (json: string): Events_GetCurrentSeating_Response {
    return Events_GetCurrentSeating_ResponseJSON._readMessage(
      Events_GetCurrentSeating_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetCurrentSeating_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetCurrentSeating_Response {
    return {
      seating: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetCurrentSeating_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seating?.length) {
      json["seating"] = msg.seating.map(atoms.PlayerSeatingJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetCurrentSeating_Response,
    json: any
  ): Events_GetCurrentSeating_Response {
    const _seating_ = json["seating"];
    if (_seating_) {
      for (const item of _seating_) {
        const m = atoms.PlayerSeating.initialize();
        atoms.PlayerSeatingJSON._readMessage(m, item);
        msg.seating.push(m);
      }
    }
    return msg;
  },
};

export const Seating_MakeShuffledSeating_PayloadJSON = {
  /**
   * Serializes Seating_MakeShuffledSeating_Payload to JSON.
   */
  encode: function (msg: Partial<Seating_MakeShuffledSeating_Payload>): string {
    return JSON.stringify(
      Seating_MakeShuffledSeating_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Seating_MakeShuffledSeating_Payload from JSON.
   */
  decode: function (json: string): Seating_MakeShuffledSeating_Payload {
    return Seating_MakeShuffledSeating_PayloadJSON._readMessage(
      Seating_MakeShuffledSeating_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Seating_MakeShuffledSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakeShuffledSeating_Payload {
    return {
      eventId: 0,
      groupsCount: 0,
      seed: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakeShuffledSeating_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.groupsCount) {
      json["groupsCount"] = msg.groupsCount;
    }
    if (msg.seed) {
      json["seed"] = msg.seed;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakeShuffledSeating_Payload,
    json: any
  ): Seating_MakeShuffledSeating_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _groupsCount_ = json["groupsCount"];
    if (_groupsCount_) {
      msg.groupsCount = _groupsCount_;
    }
    const _seed_ = json["seed"];
    if (_seed_) {
      msg.seed = _seed_;
    }
    return msg;
  },
};

export const Seating_GenerateSwissSeating_ResponseJSON = {
  /**
   * Serializes Seating_GenerateSwissSeating_Response to JSON.
   */
  encode: function (
    msg: Partial<Seating_GenerateSwissSeating_Response>
  ): string {
    return JSON.stringify(
      Seating_GenerateSwissSeating_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Seating_GenerateSwissSeating_Response from JSON.
   */
  decode: function (json: string): Seating_GenerateSwissSeating_Response {
    return Seating_GenerateSwissSeating_ResponseJSON._readMessage(
      Seating_GenerateSwissSeating_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Seating_GenerateSwissSeating_Response with all fields set to their default value.
   */
  initialize: function (): Seating_GenerateSwissSeating_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_GenerateSwissSeating_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(atoms.TableItemSwissJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_GenerateSwissSeating_Response,
    json: any
  ): Seating_GenerateSwissSeating_Response {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = atoms.TableItemSwiss.initialize();
        atoms.TableItemSwissJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const Seating_MakeIntervalSeating_PayloadJSON = {
  /**
   * Serializes Seating_MakeIntervalSeating_Payload to JSON.
   */
  encode: function (msg: Partial<Seating_MakeIntervalSeating_Payload>): string {
    return JSON.stringify(
      Seating_MakeIntervalSeating_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Seating_MakeIntervalSeating_Payload from JSON.
   */
  decode: function (json: string): Seating_MakeIntervalSeating_Payload {
    return Seating_MakeIntervalSeating_PayloadJSON._readMessage(
      Seating_MakeIntervalSeating_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Seating_MakeIntervalSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakeIntervalSeating_Payload {
    return {
      eventId: 0,
      step: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakeIntervalSeating_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.step) {
      json["step"] = msg.step;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakeIntervalSeating_Payload,
    json: any
  ): Seating_MakeIntervalSeating_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _step_ = json["step"];
    if (_step_) {
      msg.step = _step_;
    }
    return msg;
  },
};

export const Seating_MakePrescriptedSeating_PayloadJSON = {
  /**
   * Serializes Seating_MakePrescriptedSeating_Payload to JSON.
   */
  encode: function (
    msg: Partial<Seating_MakePrescriptedSeating_Payload>
  ): string {
    return JSON.stringify(
      Seating_MakePrescriptedSeating_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Seating_MakePrescriptedSeating_Payload from JSON.
   */
  decode: function (json: string): Seating_MakePrescriptedSeating_Payload {
    return Seating_MakePrescriptedSeating_PayloadJSON._readMessage(
      Seating_MakePrescriptedSeating_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Seating_MakePrescriptedSeating_Payload with all fields set to their default value.
   */
  initialize: function (): Seating_MakePrescriptedSeating_Payload {
    return {
      eventId: 0,
      randomizeAtTables: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_MakePrescriptedSeating_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.randomizeAtTables) {
      json["randomizeAtTables"] = msg.randomizeAtTables;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_MakePrescriptedSeating_Payload,
    json: any
  ): Seating_MakePrescriptedSeating_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _randomizeAtTables_ = json["randomizeAtTables"];
    if (_randomizeAtTables_) {
      msg.randomizeAtTables = _randomizeAtTables_;
    }
    return msg;
  },
};

export const Seating_GetNextPrescriptedSeating_ResponseJSON = {
  /**
   * Serializes Seating_GetNextPrescriptedSeating_Response to JSON.
   */
  encode: function (
    msg: Partial<Seating_GetNextPrescriptedSeating_Response>
  ): string {
    return JSON.stringify(
      Seating_GetNextPrescriptedSeating_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Seating_GetNextPrescriptedSeating_Response from JSON.
   */
  decode: function (json: string): Seating_GetNextPrescriptedSeating_Response {
    return Seating_GetNextPrescriptedSeating_ResponseJSON._readMessage(
      Seating_GetNextPrescriptedSeating_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Seating_GetNextPrescriptedSeating_Response with all fields set to their default value.
   */
  initialize: function (): Seating_GetNextPrescriptedSeating_Response {
    return {
      tables: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Seating_GetNextPrescriptedSeating_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(atoms.PrescriptedTableJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Seating_GetNextPrescriptedSeating_Response,
    json: any
  ): Seating_GetNextPrescriptedSeating_Response {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = atoms.PrescriptedTable.initialize();
        atoms.PrescriptedTableJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const Events_GetPrescriptedEventConfig_ResponseJSON = {
  /**
   * Serializes Events_GetPrescriptedEventConfig_Response to JSON.
   */
  encode: function (
    msg: Partial<Events_GetPrescriptedEventConfig_Response>
  ): string {
    return JSON.stringify(
      Events_GetPrescriptedEventConfig_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetPrescriptedEventConfig_Response from JSON.
   */
  decode: function (json: string): Events_GetPrescriptedEventConfig_Response {
    return Events_GetPrescriptedEventConfig_ResponseJSON._readMessage(
      Events_GetPrescriptedEventConfig_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetPrescriptedEventConfig_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetPrescriptedEventConfig_Response {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: undefined,
      errors: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetPrescriptedEventConfig_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.nextSessionIndex) {
      json["nextSessionIndex"] = msg.nextSessionIndex;
    }
    if (msg.prescript != undefined) {
      json["prescript"] = msg.prescript;
    }
    if (msg.errors?.length) {
      json["errors"] = msg.errors;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetPrescriptedEventConfig_Response,
    json: any
  ): Events_GetPrescriptedEventConfig_Response {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _nextSessionIndex_ = json["nextSessionIndex"];
    if (_nextSessionIndex_) {
      msg.nextSessionIndex = _nextSessionIndex_;
    }
    const _prescript_ = json["prescript"];
    if (_prescript_) {
      msg.prescript = _prescript_;
    }
    const _errors_ = json["errors"];
    if (_errors_) {
      msg.errors = _errors_;
    }
    return msg;
  },
};

export const Events_UpdatePrescriptedEventConfig_PayloadJSON = {
  /**
   * Serializes Events_UpdatePrescriptedEventConfig_Payload to JSON.
   */
  encode: function (
    msg: Partial<Events_UpdatePrescriptedEventConfig_Payload>
  ): string {
    return JSON.stringify(
      Events_UpdatePrescriptedEventConfig_PayloadJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_UpdatePrescriptedEventConfig_Payload from JSON.
   */
  decode: function (json: string): Events_UpdatePrescriptedEventConfig_Payload {
    return Events_UpdatePrescriptedEventConfig_PayloadJSON._readMessage(
      Events_UpdatePrescriptedEventConfig_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_UpdatePrescriptedEventConfig_Payload with all fields set to their default value.
   */
  initialize: function (): Events_UpdatePrescriptedEventConfig_Payload {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_UpdatePrescriptedEventConfig_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.nextSessionIndex) {
      json["nextSessionIndex"] = msg.nextSessionIndex;
    }
    if (msg.prescript) {
      json["prescript"] = msg.prescript;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_UpdatePrescriptedEventConfig_Payload,
    json: any
  ): Events_UpdatePrescriptedEventConfig_Payload {
    const _eventId_ = json["eventId"];
    if (_eventId_) {
      msg.eventId = _eventId_;
    }
    const _nextSessionIndex_ = json["nextSessionIndex"];
    if (_nextSessionIndex_) {
      msg.nextSessionIndex = _nextSessionIndex_;
    }
    const _prescript_ = json["prescript"];
    if (_prescript_) {
      msg.prescript = _prescript_;
    }
    return msg;
  },
};

export const Events_GetStartingTimer_ResponseJSON = {
  /**
   * Serializes Events_GetStartingTimer_Response to JSON.
   */
  encode: function (msg: Partial<Events_GetStartingTimer_Response>): string {
    return JSON.stringify(
      Events_GetStartingTimer_ResponseJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes Events_GetStartingTimer_Response from JSON.
   */
  decode: function (json: string): Events_GetStartingTimer_Response {
    return Events_GetStartingTimer_ResponseJSON._readMessage(
      Events_GetStartingTimer_ResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Events_GetStartingTimer_Response with all fields set to their default value.
   */
  initialize: function (): Events_GetStartingTimer_Response {
    return {
      timer: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Events_GetStartingTimer_Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.timer) {
      json["timer"] = msg.timer;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Events_GetStartingTimer_Response,
    json: any
  ): Events_GetStartingTimer_Response {
    const _timer_ = json["timer"];
    if (_timer_) {
      msg.timer = _timer_;
    }
    return msg;
  },
};

export const Misc_AddErrorLog_PayloadJSON = {
  /**
   * Serializes Misc_AddErrorLog_Payload to JSON.
   */
  encode: function (msg: Partial<Misc_AddErrorLog_Payload>): string {
    return JSON.stringify(Misc_AddErrorLog_PayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes Misc_AddErrorLog_Payload from JSON.
   */
  decode: function (json: string): Misc_AddErrorLog_Payload {
    return Misc_AddErrorLog_PayloadJSON._readMessage(
      Misc_AddErrorLog_PayloadJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Misc_AddErrorLog_Payload with all fields set to their default value.
   */
  initialize: function (): Misc_AddErrorLog_Payload {
    return {
      facility: "",
      sessionHash: "",
      playerId: 0,
      error: "",
      stack: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Misc_AddErrorLog_Payload>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.facility) {
      json["facility"] = msg.facility;
    }
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.error) {
      json["error"] = msg.error;
    }
    if (msg.stack) {
      json["stack"] = msg.stack;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Misc_AddErrorLog_Payload,
    json: any
  ): Misc_AddErrorLog_Payload {
    const _facility_ = json["facility"];
    if (_facility_) {
      msg.facility = _facility_;
    }
    const _sessionHash_ = json["sessionHash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _playerId_ = json["playerId"];
    if (_playerId_) {
      msg.playerId = _playerId_;
    }
    const _error_ = json["error"];
    if (_error_) {
      msg.error = _error_;
    }
    const _stack_ = json["stack"];
    if (_stack_) {
      msg.stack = _stack_;
    }
    return msg;
  },
};
