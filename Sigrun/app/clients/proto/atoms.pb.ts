// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: proto/atoms.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type EventType =
  | "EVENT_TYPE_UNSPECIFIED"
  | "EVENT_TYPE_TOURNAMENT"
  | "EVENT_TYPE_LOCAL"
  | "EVENT_TYPE_ONLINE";

export type TournamentGamesStatus =
  | "TOURNAMENT_GAMES_STATUS_UNSPECIFIED"
  | "TOURNAMENT_GAMES_STATUS_SEATING_READY"
  | "TOURNAMENT_GAMES_STATUS_STARTED";

export type RoundOutcome =
  | "ROUND_OUTCOME_UNSPECIFIED"
  | "ROUND_OUTCOME_RON"
  | "ROUND_OUTCOME_TSUMO"
  | "ROUND_OUTCOME_DRAW"
  | "ROUND_OUTCOME_ABORT"
  | "ROUND_OUTCOME_CHOMBO"
  | "ROUND_OUTCOME_NAGASHI"
  | "ROUND_OUTCOME_MULTIRON";

export type SessionStatus =
  | "SESSION_STATUS_UNSPECIFIED"
  | "SESSION_STATUS_INPROGRESS"
  | "SESSION_STATUS_PREFINISHED"
  | "SESSION_STATUS_FINISHED"
  | "SESSION_STATUS_CANCELLED"
  | "SESSION_STATUS_PLANNED";

export type UmaType =
  | "UMA_TYPE_UNSPECIFIED"
  | "UMA_TYPE_UMA_SIMPLE"
  | "UMA_TYPE_UMA_COMPLEX";

export type EndingPolicy =
  | "ENDING_POLICY_EP_UNSPECIFIED"
  | "ENDING_POLICY_EP_ONE_MORE_HAND"
  | "ENDING_POLICY_EP_END_AFTER_HAND";

export type PlatformType =
  | "PLATFORM_TYPE_UNSPECIFIED"
  | "PLATFORM_TYPE_TENHOUNET"
  | "PLATFORM_TYPE_MAHJONGSOUL";

export interface AccessRules {
  rules: Record<string, AccessRules.Rules["value"] | undefined>;
}

export declare namespace AccessRules {
  interface Rules {
    key: string;
    value: RuleValue;
  }
}

export interface RuleValue {
  /**
   * Represents a double value.
   */
  numberValue?: number | null | undefined;
  /**
   * Represents a string value.
   */
  stringValue?: string | null | undefined;
  /**
   * Represents a boolean value.
   */
  boolValue?: boolean | null | undefined;
}

export interface EventAdmin {
  ruleId: number;
  personId: number;
  personName: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface EventReferee {
  ruleId: number;
  personId: number;
  personName: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface RuleListItem {
  default: string;
  type: string;
  title: string;
}

export interface EventRuleListItem {
  isGlobal: boolean;
  id: number;
  value: RuleValue;
  name: string;
  ownerTitle: string;
  allowedValues: string[];
}

export interface RuleListItemEx {
  id: number;
  type: string;
  value: RuleValue;
  allowedValues: string[];
}

export interface RuleListItemExMap {
  rules: Record<string, RuleListItemExMap.Rules["value"] | undefined>;
}

export declare namespace RuleListItemExMap {
  interface Rules {
    key: string;
    value: RuleListItemEx;
  }
}

export interface Person {
  id: number;
  city: string;
  tenhouId: string;
  title: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface PersonEx {
  id: number;
  city: string;
  tenhouId: string;
  title: string;
  country: string;
  email: string;
  phone: string;
  groups: number[];
  hasAvatar: boolean;
  lastUpdate: string;
  msNickname: string;
  msAccountId: number;
  telegramId: string;
  notifications: string;
}

export interface Group {
  id: number;
  title: string;
  color: string;
  description: string;
}

export interface Country {
  code: string;
  name: string;
}

export interface Event {
  id: number;
  title: string;
  description: string;
  finished: boolean;
  isListed: boolean;
  isRatingShown: boolean;
  tournamentStarted: boolean;
  type: EventType;
  isPrescripted: boolean;
  isTeam: boolean;
  hasSeries: boolean;
  withChips: boolean;
  minGamesCount: number;
  achievementsShown: boolean;
  withYakitori: boolean;
  platformId: PlatformType;
}

export interface MyEvent {
  id: number;
  title: string;
  description: string;
  isOnline: boolean;
}

export interface GameConfig {
  rulesetTitle: string;
  eventTitle: string;
  eventDescription: string;
  eventStatHost: string;
  useTimer: boolean;
  usePenalty: boolean;
  gameDuration: number;
  timezone: string;
  isOnline: boolean;
  isTeam: boolean;
  autoSeating: boolean;
  syncStart: boolean;
  syncEnd: boolean;
  sortByGames: boolean;
  allowPlayerAppend: boolean;
  seriesLength: number;
  minGamesCount: number;
  gamesStatus: TournamentGamesStatus;
  hideResults: boolean;
  hideAddReplayButton: boolean;
  isPrescripted: boolean;
  isFinished: boolean;
  rulesetConfig: RulesetConfig;
  lobbyId: number;
  allowViewOtherTables: boolean;
}

export interface PlayerInRating {
  id: number;
  title: string;
  tenhouId: string;
  rating: number;
  chips: number;
  winnerZone: boolean;
  avgPlace: number;
  avgScore: number;
  gamesPlayed: number;
  teamName?: string | null | undefined;
  hasAvatar: boolean;
  lastUpdate: string;
  penaltiesAmount: number;
  penaltiesCount: number;
}

export interface Player {
  id: number;
  title: string;
  tenhouId: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface FinalResultOfSession {
  playerId: number;
  score: number;
  ratingDelta: number;
  place: number;
}

export interface Penalty {
  who: number;
  amount: number;
  reason?: string | null | undefined;
  assignedBy: number;
  createdAt: string;
  isCancelled: boolean;
  cancellationReason?: string | null | undefined;
  id: number;
}

export interface RonResult {
  roundIndex: number;
  honba: number;
  winnerId: number;
  loserId: number;
  paoPlayerId: number;
  han: number;
  fu: number;
  yaku: number[];
  riichiBets: number[];
  dora: number;
  uradora: number;
  kandora: number;
  kanuradora: number;
  openHand: boolean;
}

export interface MultironWin {
  winnerId: number;
  paoPlayerId: number;
  han: number;
  fu: number;
  yaku: number[];
  dora: number;
  uradora: number;
  kandora: number;
  kanuradora: number;
  openHand: boolean;
}

export interface MultironResult {
  roundIndex: number;
  honba: number;
  loserId: number;
  multiRon: number;
  wins: MultironWin[];
  riichiBets: number[];
}

export interface TsumoResult {
  roundIndex: number;
  honba: number;
  winnerId: number;
  paoPlayerId: number;
  han: number;
  fu: number;
  yaku: number[];
  riichiBets: number[];
  dora: number;
  uradora: number;
  kandora: number;
  kanuradora: number;
  openHand: boolean;
}

export interface DrawResult {
  roundIndex: number;
  honba: number;
  riichiBets: number[];
  tempai: number[];
}

export interface AbortResult {
  roundIndex: number;
  honba: number;
  riichiBets: number[];
}

export interface ChomboResult {
  roundIndex: number;
  honba: number;
  loserId: number;
}

export interface NagashiResult {
  roundIndex: number;
  honba: number;
  riichiBets: number[];
  tempai: number[];
  nagashi: number[];
}

export interface Round {
  ron?: RonResult | null | undefined;
  tsumo?: TsumoResult | null | undefined;
  multiron?: MultironResult | null | undefined;
  draw?: DrawResult | null | undefined;
  abort?: AbortResult | null | undefined;
  chombo?: ChomboResult | null | undefined;
  nagashi?: NagashiResult | null | undefined;
}

export interface GameResult {
  sessionHash: string;
  date?: string | null | undefined;
  replayLink: string;
  players: number[];
  finalResults: FinalResultOfSession[];
  rounds: Round[];
}

export interface PlayerPlaceInSeries {
  sessionHash: string;
  place: number;
}

export interface SeriesResult {
  player: Player;
  bestSeries: PlayerPlaceInSeries[];
  bestSeriesScores: number;
  bestSeriesPlaces: number;
  bestSeriesAvgPlace: string;
  currentSeries: PlayerPlaceInSeries[];
  currentSeriesScores: number;
  currentSeriesPlaces: number;
  currentSeriesAvgPlace: string;
}

export interface ReplacementPlayer {
  id: number;
  title: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface PlayerInSession {
  id: number;
  title: string;
  score: number;
  replacedBy?: ReplacementPlayer | null | undefined;
  ratingDelta: number;
  hasAvatar: boolean;
  lastUpdate: string;
  yakitori: boolean;
}

export interface RegisteredPlayer {
  id: number;
  title: string;
  localId?: number | null | undefined;
  teamName?: string | null | undefined;
  tenhouId: string;
  ignoreSeating: boolean;
  replacedBy?: ReplacementPlayer | null | undefined;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface SessionHistoryResult {
  sessionHash: string;
  eventId: number;
  playerId: number;
  score: number;
  ratingDelta: number;
  place: number;
  title: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface SessionHistoryResultTable {
  tables: SessionHistoryResult[];
}

export interface PlacesSummaryItem {
  place: number;
  count: number;
}

export interface PlayerWinSummary {
  ron: number;
  tsumo: number;
  chombo: number;
  feed: number;
  tsumofeed: number;
  winsWithOpen: number;
  winsWithRiichi: number;
  winsWithDama: number;
  unforcedFeedToOpen: number;
  unforcedFeedToRiichi: number;
  unforcedFeedToDama: number;
  draw: number;
  drawTempai: number;
  pointsWon: number;
  pointsLostRon: number;
  pointsLostTsumo: number;
}

export interface HandValueStat {
  hanCount: number;
  count: number;
}

export interface YakuStat {
  yakuId: number;
  count: number;
}

export interface RiichiSummary {
  riichiWon: number;
  riichiLost: number;
  feedUnderRiichi: number;
}

export interface DoraSummary {
  count: number;
  average: number;
}

export interface IntermediateResultOfSession {
  playerId: number;
  score: number;
  chomboCount: number;
}

export interface PaymentLogItem {
  from?: number | null | undefined;
  to?: number | null | undefined;
  amount: number;
}

export interface PaymentLog {
  direct: PaymentLogItem[];
  riichi: PaymentLogItem[];
  honba: PaymentLogItem[];
}

export interface RoundState {
  sessionHash: string;
  dealer: number;
  roundIndex: number;
  riichi: number;
  honba: number;
  riichiIds: number[];
  scores: IntermediateResultOfSession[];
  scoresDelta: IntermediateResultOfSession[];
  payments: PaymentLog;
  round: Round;
  outcome: RoundOutcome;
}

export interface EventData {
  type?: EventType | null | undefined;
  title: string;
  description: string;
  duration: number;
  timezone: string;
  lobbyId: number;
  seriesLength: number;
  minGames: number;
  isTeam: boolean;
  isPrescripted: boolean;
  autostart: number;
  rulesetConfig: RulesetConfig;
  isListed: boolean;
  isRatingShown: boolean;
  achievementsShown: boolean;
  allowViewOtherTables: boolean;
  platformId: PlatformType;
}

export interface TableState {
  status: SessionStatus;
  mayDefinalize: boolean;
  sessionHash: string;
  tableIndex?: number | null | undefined;
  lastRound?: Round | null | undefined;
  currentRoundIndex: number;
  scores: IntermediateResultOfSession[];
  players: RegisteredPlayer[];
  extraTime?: number | null | undefined;
}

export interface Achievement {
  achievementId: string;
  achievementData: string;
}

export interface LocalIdMapping {
  playerId: number;
  localId: number;
}

export interface TeamMapping {
  playerId: number;
  teamName: string;
}

export interface PlayerSeating {
  order: number;
  playerId: number;
  sessionId: number;
  tableIndex: number;
  rating: number;
  playerTitle: string;
  hasAvatar: boolean;
  lastUpdate: string;
}

export interface PlayerSeatingSwiss {
  playerId: number;
  rating: number;
}

export interface TableItemSwiss {
  players: PlayerSeatingSwiss[];
}

export interface PrescriptedTable {
  players: RegisteredPlayer[];
}

export interface Chombo {
  playerId: number;
  amount: number;
}

export interface SessionState {
  dealer: number;
  roundIndex: number;
  riichiCount: number;
  honbaCount: number;
  scores: IntermediateResultOfSession[];
  finished: boolean;
  lastHandStarted: boolean;
  chombo: Chombo[];
}

export interface Uma {
  place1: number;
  place2: number;
  place3: number;
  place4: number;
}

export interface ComplexUma {
  neg1: Uma;
  neg3: Uma;
  otherwise: Uma;
}

export interface RulesetConfig {
  complexUma: ComplexUma;
  endingPolicy: EndingPolicy;
  uma: Uma;
  umaType: UmaType;
  doubleronHonbaAtamahane: boolean;
  doubleronRiichiAtamahane: boolean;
  equalizeUma: boolean;
  extraChomboPayments: boolean;
  playAdditionalRounds: boolean;
  riichiGoesToWinner: boolean;
  tonpuusen: boolean;
  withAbortives: boolean;
  withAtamahane: boolean;
  withButtobi: boolean;
  withKazoe: boolean;
  withKiriageMangan: boolean;
  withKuitan: boolean;
  withLeadingDealerGameOver: boolean;
  withMultiYakumans: boolean;
  withNagashiMangan: boolean;
  withWinningDealerHonbaSkipped: boolean;
  chipsValue: number;
  chomboAmount: number;
  gameExpirationTime: number;
  goalPoints: number;
  maxPenalty: number;
  minPenalty: number;
  oka: number;
  penaltyStep: number;
  replacementPlayerFixedPoints: number;
  replacementPlayerOverrideUma: number;
  startPoints: number;
  startRating: number;
  allowedYaku: number[];
  yakuWithPao: number[];
  withYakitori: boolean;
  yakitoriPenalty: number;
  chomboEndsGame: boolean;
  honbaValue: number;
}

export interface GenericSuccessResponse {
  success: boolean;
}

export interface GenericEventPayload {
  eventId: number;
}

export interface GenericSessionPayload {
  sessionHash: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const EventType = {
  EVENT_TYPE_UNSPECIFIED: "EVENT_TYPE_UNSPECIFIED",
  EVENT_TYPE_TOURNAMENT: "EVENT_TYPE_TOURNAMENT",
  EVENT_TYPE_LOCAL: "EVENT_TYPE_LOCAL",
  EVENT_TYPE_ONLINE: "EVENT_TYPE_ONLINE",
  /**
   * @private
   */
  _fromInt: function (i: number): EventType {
    switch (i) {
      case 0: {
        return "EVENT_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "EVENT_TYPE_TOURNAMENT";
      }
      case 2: {
        return "EVENT_TYPE_LOCAL";
      }
      case 3: {
        return "EVENT_TYPE_ONLINE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as EventType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: EventType): number {
    switch (i) {
      case "EVENT_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "EVENT_TYPE_TOURNAMENT": {
        return 1;
      }
      case "EVENT_TYPE_LOCAL": {
        return 2;
      }
      case "EVENT_TYPE_ONLINE": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TournamentGamesStatus = {
  TOURNAMENT_GAMES_STATUS_UNSPECIFIED: "TOURNAMENT_GAMES_STATUS_UNSPECIFIED",
  TOURNAMENT_GAMES_STATUS_SEATING_READY:
    "TOURNAMENT_GAMES_STATUS_SEATING_READY",
  TOURNAMENT_GAMES_STATUS_STARTED: "TOURNAMENT_GAMES_STATUS_STARTED",
  /**
   * @private
   */
  _fromInt: function (i: number): TournamentGamesStatus {
    switch (i) {
      case 0: {
        return "TOURNAMENT_GAMES_STATUS_UNSPECIFIED";
      }
      case 1: {
        return "TOURNAMENT_GAMES_STATUS_SEATING_READY";
      }
      case 2: {
        return "TOURNAMENT_GAMES_STATUS_STARTED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TournamentGamesStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TournamentGamesStatus): number {
    switch (i) {
      case "TOURNAMENT_GAMES_STATUS_UNSPECIFIED": {
        return 0;
      }
      case "TOURNAMENT_GAMES_STATUS_SEATING_READY": {
        return 1;
      }
      case "TOURNAMENT_GAMES_STATUS_STARTED": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const RoundOutcome = {
  ROUND_OUTCOME_UNSPECIFIED: "ROUND_OUTCOME_UNSPECIFIED",
  ROUND_OUTCOME_RON: "ROUND_OUTCOME_RON",
  ROUND_OUTCOME_TSUMO: "ROUND_OUTCOME_TSUMO",
  ROUND_OUTCOME_DRAW: "ROUND_OUTCOME_DRAW",
  ROUND_OUTCOME_ABORT: "ROUND_OUTCOME_ABORT",
  ROUND_OUTCOME_CHOMBO: "ROUND_OUTCOME_CHOMBO",
  ROUND_OUTCOME_NAGASHI: "ROUND_OUTCOME_NAGASHI",
  ROUND_OUTCOME_MULTIRON: "ROUND_OUTCOME_MULTIRON",
  /**
   * @private
   */
  _fromInt: function (i: number): RoundOutcome {
    switch (i) {
      case 0: {
        return "ROUND_OUTCOME_UNSPECIFIED";
      }
      case 1: {
        return "ROUND_OUTCOME_RON";
      }
      case 2: {
        return "ROUND_OUTCOME_TSUMO";
      }
      case 3: {
        return "ROUND_OUTCOME_DRAW";
      }
      case 4: {
        return "ROUND_OUTCOME_ABORT";
      }
      case 5: {
        return "ROUND_OUTCOME_CHOMBO";
      }
      case 6: {
        return "ROUND_OUTCOME_NAGASHI";
      }
      case 7: {
        return "ROUND_OUTCOME_MULTIRON";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as RoundOutcome;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: RoundOutcome): number {
    switch (i) {
      case "ROUND_OUTCOME_UNSPECIFIED": {
        return 0;
      }
      case "ROUND_OUTCOME_RON": {
        return 1;
      }
      case "ROUND_OUTCOME_TSUMO": {
        return 2;
      }
      case "ROUND_OUTCOME_DRAW": {
        return 3;
      }
      case "ROUND_OUTCOME_ABORT": {
        return 4;
      }
      case "ROUND_OUTCOME_CHOMBO": {
        return 5;
      }
      case "ROUND_OUTCOME_NAGASHI": {
        return 6;
      }
      case "ROUND_OUTCOME_MULTIRON": {
        return 7;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SessionStatus = {
  SESSION_STATUS_UNSPECIFIED: "SESSION_STATUS_UNSPECIFIED",
  SESSION_STATUS_INPROGRESS: "SESSION_STATUS_INPROGRESS",
  SESSION_STATUS_PREFINISHED: "SESSION_STATUS_PREFINISHED",
  SESSION_STATUS_FINISHED: "SESSION_STATUS_FINISHED",
  SESSION_STATUS_CANCELLED: "SESSION_STATUS_CANCELLED",
  SESSION_STATUS_PLANNED: "SESSION_STATUS_PLANNED",
  /**
   * @private
   */
  _fromInt: function (i: number): SessionStatus {
    switch (i) {
      case 0: {
        return "SESSION_STATUS_UNSPECIFIED";
      }
      case 1: {
        return "SESSION_STATUS_INPROGRESS";
      }
      case 2: {
        return "SESSION_STATUS_PREFINISHED";
      }
      case 3: {
        return "SESSION_STATUS_FINISHED";
      }
      case 4: {
        return "SESSION_STATUS_CANCELLED";
      }
      case 5: {
        return "SESSION_STATUS_PLANNED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SessionStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SessionStatus): number {
    switch (i) {
      case "SESSION_STATUS_UNSPECIFIED": {
        return 0;
      }
      case "SESSION_STATUS_INPROGRESS": {
        return 1;
      }
      case "SESSION_STATUS_PREFINISHED": {
        return 2;
      }
      case "SESSION_STATUS_FINISHED": {
        return 3;
      }
      case "SESSION_STATUS_CANCELLED": {
        return 4;
      }
      case "SESSION_STATUS_PLANNED": {
        return 5;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const UmaType = {
  UMA_TYPE_UNSPECIFIED: "UMA_TYPE_UNSPECIFIED",
  UMA_TYPE_UMA_SIMPLE: "UMA_TYPE_UMA_SIMPLE",
  UMA_TYPE_UMA_COMPLEX: "UMA_TYPE_UMA_COMPLEX",
  /**
   * @private
   */
  _fromInt: function (i: number): UmaType {
    switch (i) {
      case 0: {
        return "UMA_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "UMA_TYPE_UMA_SIMPLE";
      }
      case 2: {
        return "UMA_TYPE_UMA_COMPLEX";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as UmaType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: UmaType): number {
    switch (i) {
      case "UMA_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "UMA_TYPE_UMA_SIMPLE": {
        return 1;
      }
      case "UMA_TYPE_UMA_COMPLEX": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const EndingPolicy = {
  ENDING_POLICY_EP_UNSPECIFIED: "ENDING_POLICY_EP_UNSPECIFIED",
  ENDING_POLICY_EP_ONE_MORE_HAND: "ENDING_POLICY_EP_ONE_MORE_HAND",
  ENDING_POLICY_EP_END_AFTER_HAND: "ENDING_POLICY_EP_END_AFTER_HAND",
  /**
   * @private
   */
  _fromInt: function (i: number): EndingPolicy {
    switch (i) {
      case 0: {
        return "ENDING_POLICY_EP_UNSPECIFIED";
      }
      case 1: {
        return "ENDING_POLICY_EP_ONE_MORE_HAND";
      }
      case 2: {
        return "ENDING_POLICY_EP_END_AFTER_HAND";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as EndingPolicy;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: EndingPolicy): number {
    switch (i) {
      case "ENDING_POLICY_EP_UNSPECIFIED": {
        return 0;
      }
      case "ENDING_POLICY_EP_ONE_MORE_HAND": {
        return 1;
      }
      case "ENDING_POLICY_EP_END_AFTER_HAND": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PlatformType = {
  PLATFORM_TYPE_UNSPECIFIED: "PLATFORM_TYPE_UNSPECIFIED",
  PLATFORM_TYPE_TENHOUNET: "PLATFORM_TYPE_TENHOUNET",
  PLATFORM_TYPE_MAHJONGSOUL: "PLATFORM_TYPE_MAHJONGSOUL",
  /**
   * @private
   */
  _fromInt: function (i: number): PlatformType {
    switch (i) {
      case 0: {
        return "PLATFORM_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "PLATFORM_TYPE_TENHOUNET";
      }
      case 2: {
        return "PLATFORM_TYPE_MAHJONGSOUL";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as PlatformType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: PlatformType): number {
    switch (i) {
      case "PLATFORM_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "PLATFORM_TYPE_TENHOUNET": {
        return 1;
      }
      case "PLATFORM_TYPE_MAHJONGSOUL": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const AccessRules = {
  /**
   * Serializes AccessRules to protobuf.
   */
  encode: function (msg: PartialDeep<AccessRules>): Uint8Array {
    return AccessRules._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes AccessRules from protobuf.
   */
  decode: function (bytes: ByteSource): AccessRules {
    return AccessRules._readMessage(
      AccessRules.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes AccessRules with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AccessRules>): AccessRules {
    return {
      rules: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AccessRules>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.rules) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.rules).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        AccessRules.Rules._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AccessRules,
    reader: protoscript.BinaryReader,
  ): AccessRules {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as AccessRules.Rules;
          reader.readMessage(map, AccessRules.Rules._readMessage);
          msg.rules[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Rules: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<AccessRules.Rules>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, RuleValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: AccessRules.Rules,
      reader: protoscript.BinaryReader,
    ): AccessRules.Rules {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = RuleValue.initialize();
            reader.readMessage(msg.value, RuleValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const RuleValue = {
  /**
   * Serializes RuleValue to protobuf.
   */
  encode: function (msg: PartialDeep<RuleValue>): Uint8Array {
    return RuleValue._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RuleValue from protobuf.
   */
  decode: function (bytes: ByteSource): RuleValue {
    return RuleValue._readMessage(
      RuleValue.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RuleValue with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleValue>): RuleValue {
    return {
      numberValue: undefined,
      stringValue: undefined,
      boolValue: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleValue>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.numberValue != undefined) {
      writer.writeInt32(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RuleValue,
    reader: protoscript.BinaryReader,
  ): RuleValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2: {
          msg.numberValue = reader.readInt32();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventAdmin = {
  /**
   * Serializes EventAdmin to protobuf.
   */
  encode: function (msg: PartialDeep<EventAdmin>): Uint8Array {
    return EventAdmin._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventAdmin from protobuf.
   */
  decode: function (bytes: ByteSource): EventAdmin {
    return EventAdmin._readMessage(
      EventAdmin.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventAdmin with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventAdmin>): EventAdmin {
    return {
      ruleId: 0,
      personId: 0,
      personName: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventAdmin>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ruleId) {
      writer.writeInt32(1, msg.ruleId);
    }
    if (msg.personId) {
      writer.writeInt32(2, msg.personId);
    }
    if (msg.personName) {
      writer.writeString(3, msg.personName);
    }
    if (msg.hasAvatar) {
      writer.writeBool(4, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(5, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventAdmin,
    reader: protoscript.BinaryReader,
  ): EventAdmin {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ruleId = reader.readInt32();
          break;
        }
        case 2: {
          msg.personId = reader.readInt32();
          break;
        }
        case 3: {
          msg.personName = reader.readString();
          break;
        }
        case 4: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 5: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventReferee = {
  /**
   * Serializes EventReferee to protobuf.
   */
  encode: function (msg: PartialDeep<EventReferee>): Uint8Array {
    return EventReferee._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventReferee from protobuf.
   */
  decode: function (bytes: ByteSource): EventReferee {
    return EventReferee._readMessage(
      EventReferee.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventReferee with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventReferee>): EventReferee {
    return {
      ruleId: 0,
      personId: 0,
      personName: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventReferee>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ruleId) {
      writer.writeInt32(1, msg.ruleId);
    }
    if (msg.personId) {
      writer.writeInt32(2, msg.personId);
    }
    if (msg.personName) {
      writer.writeString(3, msg.personName);
    }
    if (msg.hasAvatar) {
      writer.writeBool(4, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(5, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventReferee,
    reader: protoscript.BinaryReader,
  ): EventReferee {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ruleId = reader.readInt32();
          break;
        }
        case 2: {
          msg.personId = reader.readInt32();
          break;
        }
        case 3: {
          msg.personName = reader.readString();
          break;
        }
        case 4: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 5: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RuleListItem = {
  /**
   * Serializes RuleListItem to protobuf.
   */
  encode: function (msg: PartialDeep<RuleListItem>): Uint8Array {
    return RuleListItem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RuleListItem from protobuf.
   */
  decode: function (bytes: ByteSource): RuleListItem {
    return RuleListItem._readMessage(
      RuleListItem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RuleListItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItem>): RuleListItem {
    return {
      default: "",
      type: "",
      title: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.default) {
      writer.writeString(1, msg.default);
    }
    if (msg.type) {
      writer.writeString(2, msg.type);
    }
    if (msg.title) {
      writer.writeString(3, msg.title);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RuleListItem,
    reader: protoscript.BinaryReader,
  ): RuleListItem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.default = reader.readString();
          break;
        }
        case 2: {
          msg.type = reader.readString();
          break;
        }
        case 3: {
          msg.title = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventRuleListItem = {
  /**
   * Serializes EventRuleListItem to protobuf.
   */
  encode: function (msg: PartialDeep<EventRuleListItem>): Uint8Array {
    return EventRuleListItem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventRuleListItem from protobuf.
   */
  decode: function (bytes: ByteSource): EventRuleListItem {
    return EventRuleListItem._readMessage(
      EventRuleListItem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventRuleListItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventRuleListItem>): EventRuleListItem {
    return {
      isGlobal: false,
      id: 0,
      value: RuleValue.initialize(),
      name: "",
      ownerTitle: "",
      allowedValues: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventRuleListItem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.isGlobal) {
      writer.writeBool(1, msg.isGlobal);
    }
    if (msg.id) {
      writer.writeInt32(2, msg.id);
    }
    if (msg.value) {
      writer.writeMessage(3, msg.value, RuleValue._writeMessage);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.ownerTitle) {
      writer.writeString(5, msg.ownerTitle);
    }
    if (msg.allowedValues?.length) {
      writer.writeRepeatedString(6, msg.allowedValues);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventRuleListItem,
    reader: protoscript.BinaryReader,
  ): EventRuleListItem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.isGlobal = reader.readBool();
          break;
        }
        case 2: {
          msg.id = reader.readInt32();
          break;
        }
        case 3: {
          reader.readMessage(msg.value, RuleValue._readMessage);
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 5: {
          msg.ownerTitle = reader.readString();
          break;
        }
        case 6: {
          msg.allowedValues.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RuleListItemEx = {
  /**
   * Serializes RuleListItemEx to protobuf.
   */
  encode: function (msg: PartialDeep<RuleListItemEx>): Uint8Array {
    return RuleListItemEx._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RuleListItemEx from protobuf.
   */
  decode: function (bytes: ByteSource): RuleListItemEx {
    return RuleListItemEx._readMessage(
      RuleListItemEx.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RuleListItemEx with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItemEx>): RuleListItemEx {
    return {
      id: 0,
      type: "",
      value: RuleValue.initialize(),
      allowedValues: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItemEx>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.type) {
      writer.writeString(2, msg.type);
    }
    if (msg.value) {
      writer.writeMessage(3, msg.value, RuleValue._writeMessage);
    }
    if (msg.allowedValues?.length) {
      writer.writeRepeatedString(4, msg.allowedValues);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RuleListItemEx,
    reader: protoscript.BinaryReader,
  ): RuleListItemEx {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.type = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.value, RuleValue._readMessage);
          break;
        }
        case 4: {
          msg.allowedValues.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RuleListItemExMap = {
  /**
   * Serializes RuleListItemExMap to protobuf.
   */
  encode: function (msg: PartialDeep<RuleListItemExMap>): Uint8Array {
    return RuleListItemExMap._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RuleListItemExMap from protobuf.
   */
  decode: function (bytes: ByteSource): RuleListItemExMap {
    return RuleListItemExMap._readMessage(
      RuleListItemExMap.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RuleListItemExMap with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItemExMap>): RuleListItemExMap {
    return {
      rules: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItemExMap>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.rules) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.rules).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        RuleListItemExMap.Rules._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RuleListItemExMap,
    reader: protoscript.BinaryReader,
  ): RuleListItemExMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as RuleListItemExMap.Rules;
          reader.readMessage(map, RuleListItemExMap.Rules._readMessage);
          msg.rules[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Rules: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<RuleListItemExMap.Rules>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, RuleListItemEx._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: RuleListItemExMap.Rules,
      reader: protoscript.BinaryReader,
    ): RuleListItemExMap.Rules {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = RuleListItemEx.initialize();
            reader.readMessage(msg.value, RuleListItemEx._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Person = {
  /**
   * Serializes Person to protobuf.
   */
  encode: function (msg: PartialDeep<Person>): Uint8Array {
    return Person._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Person from protobuf.
   */
  decode: function (bytes: ByteSource): Person {
    return Person._readMessage(
      Person.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Person with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Person>): Person {
    return {
      id: 0,
      city: "",
      tenhouId: "",
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Person>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.city) {
      writer.writeString(2, msg.city);
    }
    if (msg.tenhouId) {
      writer.writeString(3, msg.tenhouId);
    }
    if (msg.title) {
      writer.writeString(4, msg.title);
    }
    if (msg.hasAvatar) {
      writer.writeBool(5, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(6, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Person,
    reader: protoscript.BinaryReader,
  ): Person {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.city = reader.readString();
          break;
        }
        case 3: {
          msg.tenhouId = reader.readString();
          break;
        }
        case 4: {
          msg.title = reader.readString();
          break;
        }
        case 5: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 6: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PersonEx = {
  /**
   * Serializes PersonEx to protobuf.
   */
  encode: function (msg: PartialDeep<PersonEx>): Uint8Array {
    return PersonEx._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PersonEx from protobuf.
   */
  decode: function (bytes: ByteSource): PersonEx {
    return PersonEx._readMessage(
      PersonEx.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PersonEx with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PersonEx>): PersonEx {
    return {
      id: 0,
      city: "",
      tenhouId: "",
      title: "",
      country: "",
      email: "",
      phone: "",
      groups: [],
      hasAvatar: false,
      lastUpdate: "",
      msNickname: "",
      msAccountId: 0,
      telegramId: "",
      notifications: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PersonEx>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.city) {
      writer.writeString(2, msg.city);
    }
    if (msg.tenhouId) {
      writer.writeString(3, msg.tenhouId);
    }
    if (msg.title) {
      writer.writeString(4, msg.title);
    }
    if (msg.country) {
      writer.writeString(5, msg.country);
    }
    if (msg.email) {
      writer.writeString(6, msg.email);
    }
    if (msg.phone) {
      writer.writeString(7, msg.phone);
    }
    if (msg.groups?.length) {
      writer.writePackedInt32(8, msg.groups);
    }
    if (msg.hasAvatar) {
      writer.writeBool(9, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(10, msg.lastUpdate);
    }
    if (msg.msNickname) {
      writer.writeString(11, msg.msNickname);
    }
    if (msg.msAccountId) {
      writer.writeInt32(12, msg.msAccountId);
    }
    if (msg.telegramId) {
      writer.writeString(13, msg.telegramId);
    }
    if (msg.notifications) {
      writer.writeString(14, msg.notifications);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PersonEx,
    reader: protoscript.BinaryReader,
  ): PersonEx {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.city = reader.readString();
          break;
        }
        case 3: {
          msg.tenhouId = reader.readString();
          break;
        }
        case 4: {
          msg.title = reader.readString();
          break;
        }
        case 5: {
          msg.country = reader.readString();
          break;
        }
        case 6: {
          msg.email = reader.readString();
          break;
        }
        case 7: {
          msg.phone = reader.readString();
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.groups.push(...reader.readPackedInt32());
          } else {
            msg.groups.push(reader.readInt32());
          }
          break;
        }
        case 9: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 10: {
          msg.lastUpdate = reader.readString();
          break;
        }
        case 11: {
          msg.msNickname = reader.readString();
          break;
        }
        case 12: {
          msg.msAccountId = reader.readInt32();
          break;
        }
        case 13: {
          msg.telegramId = reader.readString();
          break;
        }
        case 14: {
          msg.notifications = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Group = {
  /**
   * Serializes Group to protobuf.
   */
  encode: function (msg: PartialDeep<Group>): Uint8Array {
    return Group._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Group from protobuf.
   */
  decode: function (bytes: ByteSource): Group {
    return Group._readMessage(
      Group.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Group with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Group>): Group {
    return {
      id: 0,
      title: "",
      color: "",
      description: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Group>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.color) {
      writer.writeString(3, msg.color);
    }
    if (msg.description) {
      writer.writeString(4, msg.description);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Group, reader: protoscript.BinaryReader): Group {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.color = reader.readString();
          break;
        }
        case 4: {
          msg.description = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Country = {
  /**
   * Serializes Country to protobuf.
   */
  encode: function (msg: PartialDeep<Country>): Uint8Array {
    return Country._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Country from protobuf.
   */
  decode: function (bytes: ByteSource): Country {
    return Country._readMessage(
      Country.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Country with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Country>): Country {
    return {
      code: "",
      name: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Country>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.code) {
      writer.writeString(1, msg.code);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Country,
    reader: protoscript.BinaryReader,
  ): Country {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.code = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Event = {
  /**
   * Serializes Event to protobuf.
   */
  encode: function (msg: PartialDeep<Event>): Uint8Array {
    return Event._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Event from protobuf.
   */
  decode: function (bytes: ByteSource): Event {
    return Event._readMessage(
      Event.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Event with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Event>): Event {
    return {
      id: 0,
      title: "",
      description: "",
      finished: false,
      isListed: false,
      isRatingShown: false,
      tournamentStarted: false,
      type: EventType._fromInt(0),
      isPrescripted: false,
      isTeam: false,
      hasSeries: false,
      withChips: false,
      minGamesCount: 0,
      achievementsShown: false,
      withYakitori: false,
      platformId: PlatformType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Event>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.finished) {
      writer.writeBool(4, msg.finished);
    }
    if (msg.isListed) {
      writer.writeBool(5, msg.isListed);
    }
    if (msg.isRatingShown) {
      writer.writeBool(6, msg.isRatingShown);
    }
    if (msg.tournamentStarted) {
      writer.writeBool(7, msg.tournamentStarted);
    }
    if (msg.type && EventType._toInt(msg.type)) {
      writer.writeEnum(8, EventType._toInt(msg.type));
    }
    if (msg.isPrescripted) {
      writer.writeBool(9, msg.isPrescripted);
    }
    if (msg.isTeam) {
      writer.writeBool(10, msg.isTeam);
    }
    if (msg.hasSeries) {
      writer.writeBool(11, msg.hasSeries);
    }
    if (msg.withChips) {
      writer.writeBool(12, msg.withChips);
    }
    if (msg.minGamesCount) {
      writer.writeInt32(13, msg.minGamesCount);
    }
    if (msg.achievementsShown) {
      writer.writeBool(15, msg.achievementsShown);
    }
    if (msg.withYakitori) {
      writer.writeBool(16, msg.withYakitori);
    }
    if (msg.platformId && PlatformType._toInt(msg.platformId)) {
      writer.writeEnum(17, PlatformType._toInt(msg.platformId));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Event, reader: protoscript.BinaryReader): Event {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.finished = reader.readBool();
          break;
        }
        case 5: {
          msg.isListed = reader.readBool();
          break;
        }
        case 6: {
          msg.isRatingShown = reader.readBool();
          break;
        }
        case 7: {
          msg.tournamentStarted = reader.readBool();
          break;
        }
        case 8: {
          msg.type = EventType._fromInt(reader.readEnum());
          break;
        }
        case 9: {
          msg.isPrescripted = reader.readBool();
          break;
        }
        case 10: {
          msg.isTeam = reader.readBool();
          break;
        }
        case 11: {
          msg.hasSeries = reader.readBool();
          break;
        }
        case 12: {
          msg.withChips = reader.readBool();
          break;
        }
        case 13: {
          msg.minGamesCount = reader.readInt32();
          break;
        }
        case 15: {
          msg.achievementsShown = reader.readBool();
          break;
        }
        case 16: {
          msg.withYakitori = reader.readBool();
          break;
        }
        case 17: {
          msg.platformId = PlatformType._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MyEvent = {
  /**
   * Serializes MyEvent to protobuf.
   */
  encode: function (msg: PartialDeep<MyEvent>): Uint8Array {
    return MyEvent._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MyEvent from protobuf.
   */
  decode: function (bytes: ByteSource): MyEvent {
    return MyEvent._readMessage(
      MyEvent.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes MyEvent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MyEvent>): MyEvent {
    return {
      id: 0,
      title: "",
      description: "",
      isOnline: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MyEvent>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.isOnline) {
      writer.writeBool(4, msg.isOnline);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MyEvent,
    reader: protoscript.BinaryReader,
  ): MyEvent {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.isOnline = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GameConfig = {
  /**
   * Serializes GameConfig to protobuf.
   */
  encode: function (msg: PartialDeep<GameConfig>): Uint8Array {
    return GameConfig._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GameConfig from protobuf.
   */
  decode: function (bytes: ByteSource): GameConfig {
    return GameConfig._readMessage(
      GameConfig.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GameConfig with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GameConfig>): GameConfig {
    return {
      rulesetTitle: "",
      eventTitle: "",
      eventDescription: "",
      eventStatHost: "",
      useTimer: false,
      usePenalty: false,
      gameDuration: 0,
      timezone: "",
      isOnline: false,
      isTeam: false,
      autoSeating: false,
      syncStart: false,
      syncEnd: false,
      sortByGames: false,
      allowPlayerAppend: false,
      seriesLength: 0,
      minGamesCount: 0,
      gamesStatus: TournamentGamesStatus._fromInt(0),
      hideResults: false,
      hideAddReplayButton: false,
      isPrescripted: false,
      isFinished: false,
      rulesetConfig: RulesetConfig.initialize(),
      lobbyId: 0,
      allowViewOtherTables: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GameConfig>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.rulesetTitle) {
      writer.writeString(10, msg.rulesetTitle);
    }
    if (msg.eventTitle) {
      writer.writeString(26, msg.eventTitle);
    }
    if (msg.eventDescription) {
      writer.writeString(27, msg.eventDescription);
    }
    if (msg.eventStatHost) {
      writer.writeString(28, msg.eventStatHost);
    }
    if (msg.useTimer) {
      writer.writeBool(29, msg.useTimer);
    }
    if (msg.usePenalty) {
      writer.writeBool(30, msg.usePenalty);
    }
    if (msg.gameDuration) {
      writer.writeInt32(34, msg.gameDuration);
    }
    if (msg.timezone) {
      writer.writeString(35, msg.timezone);
    }
    if (msg.isOnline) {
      writer.writeBool(36, msg.isOnline);
    }
    if (msg.isTeam) {
      writer.writeBool(37, msg.isTeam);
    }
    if (msg.autoSeating) {
      writer.writeBool(38, msg.autoSeating);
    }
    if (msg.syncStart) {
      writer.writeBool(39, msg.syncStart);
    }
    if (msg.syncEnd) {
      writer.writeBool(40, msg.syncEnd);
    }
    if (msg.sortByGames) {
      writer.writeBool(41, msg.sortByGames);
    }
    if (msg.allowPlayerAppend) {
      writer.writeBool(42, msg.allowPlayerAppend);
    }
    if (msg.seriesLength) {
      writer.writeInt32(45, msg.seriesLength);
    }
    if (msg.minGamesCount) {
      writer.writeInt32(46, msg.minGamesCount);
    }
    if (msg.gamesStatus && TournamentGamesStatus._toInt(msg.gamesStatus)) {
      writer.writeEnum(47, TournamentGamesStatus._toInt(msg.gamesStatus));
    }
    if (msg.hideResults) {
      writer.writeBool(48, msg.hideResults);
    }
    if (msg.hideAddReplayButton) {
      writer.writeBool(49, msg.hideAddReplayButton);
    }
    if (msg.isPrescripted) {
      writer.writeBool(50, msg.isPrescripted);
    }
    if (msg.isFinished) {
      writer.writeBool(52, msg.isFinished);
    }
    if (msg.rulesetConfig) {
      writer.writeMessage(53, msg.rulesetConfig, RulesetConfig._writeMessage);
    }
    if (msg.lobbyId) {
      writer.writeInt32(54, msg.lobbyId);
    }
    if (msg.allowViewOtherTables) {
      writer.writeBool(55, msg.allowViewOtherTables);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GameConfig,
    reader: protoscript.BinaryReader,
  ): GameConfig {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 10: {
          msg.rulesetTitle = reader.readString();
          break;
        }
        case 26: {
          msg.eventTitle = reader.readString();
          break;
        }
        case 27: {
          msg.eventDescription = reader.readString();
          break;
        }
        case 28: {
          msg.eventStatHost = reader.readString();
          break;
        }
        case 29: {
          msg.useTimer = reader.readBool();
          break;
        }
        case 30: {
          msg.usePenalty = reader.readBool();
          break;
        }
        case 34: {
          msg.gameDuration = reader.readInt32();
          break;
        }
        case 35: {
          msg.timezone = reader.readString();
          break;
        }
        case 36: {
          msg.isOnline = reader.readBool();
          break;
        }
        case 37: {
          msg.isTeam = reader.readBool();
          break;
        }
        case 38: {
          msg.autoSeating = reader.readBool();
          break;
        }
        case 39: {
          msg.syncStart = reader.readBool();
          break;
        }
        case 40: {
          msg.syncEnd = reader.readBool();
          break;
        }
        case 41: {
          msg.sortByGames = reader.readBool();
          break;
        }
        case 42: {
          msg.allowPlayerAppend = reader.readBool();
          break;
        }
        case 45: {
          msg.seriesLength = reader.readInt32();
          break;
        }
        case 46: {
          msg.minGamesCount = reader.readInt32();
          break;
        }
        case 47: {
          msg.gamesStatus = TournamentGamesStatus._fromInt(reader.readEnum());
          break;
        }
        case 48: {
          msg.hideResults = reader.readBool();
          break;
        }
        case 49: {
          msg.hideAddReplayButton = reader.readBool();
          break;
        }
        case 50: {
          msg.isPrescripted = reader.readBool();
          break;
        }
        case 52: {
          msg.isFinished = reader.readBool();
          break;
        }
        case 53: {
          reader.readMessage(msg.rulesetConfig, RulesetConfig._readMessage);
          break;
        }
        case 54: {
          msg.lobbyId = reader.readInt32();
          break;
        }
        case 55: {
          msg.allowViewOtherTables = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerInRating = {
  /**
   * Serializes PlayerInRating to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerInRating>): Uint8Array {
    return PlayerInRating._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerInRating from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerInRating {
    return PlayerInRating._readMessage(
      PlayerInRating.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerInRating with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerInRating>): PlayerInRating {
    return {
      id: 0,
      title: "",
      tenhouId: "",
      rating: 0,
      chips: 0,
      winnerZone: false,
      avgPlace: 0,
      avgScore: 0,
      gamesPlayed: 0,
      teamName: undefined,
      hasAvatar: false,
      lastUpdate: "",
      penaltiesAmount: 0,
      penaltiesCount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerInRating>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.tenhouId) {
      writer.writeString(3, msg.tenhouId);
    }
    if (msg.rating) {
      writer.writeFloat(4, msg.rating);
    }
    if (msg.chips) {
      writer.writeInt32(5, msg.chips);
    }
    if (msg.winnerZone) {
      writer.writeBool(6, msg.winnerZone);
    }
    if (msg.avgPlace) {
      writer.writeFloat(7, msg.avgPlace);
    }
    if (msg.avgScore) {
      writer.writeFloat(8, msg.avgScore);
    }
    if (msg.gamesPlayed) {
      writer.writeInt32(9, msg.gamesPlayed);
    }
    if (msg.teamName != undefined) {
      writer.writeString(10, msg.teamName);
    }
    if (msg.hasAvatar) {
      writer.writeBool(11, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(12, msg.lastUpdate);
    }
    if (msg.penaltiesAmount) {
      writer.writeFloat(13, msg.penaltiesAmount);
    }
    if (msg.penaltiesCount) {
      writer.writeInt32(14, msg.penaltiesCount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerInRating,
    reader: protoscript.BinaryReader,
  ): PlayerInRating {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.tenhouId = reader.readString();
          break;
        }
        case 4: {
          msg.rating = reader.readFloat();
          break;
        }
        case 5: {
          msg.chips = reader.readInt32();
          break;
        }
        case 6: {
          msg.winnerZone = reader.readBool();
          break;
        }
        case 7: {
          msg.avgPlace = reader.readFloat();
          break;
        }
        case 8: {
          msg.avgScore = reader.readFloat();
          break;
        }
        case 9: {
          msg.gamesPlayed = reader.readInt32();
          break;
        }
        case 10: {
          msg.teamName = reader.readString();
          break;
        }
        case 11: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 12: {
          msg.lastUpdate = reader.readString();
          break;
        }
        case 13: {
          msg.penaltiesAmount = reader.readFloat();
          break;
        }
        case 14: {
          msg.penaltiesCount = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Player = {
  /**
   * Serializes Player to protobuf.
   */
  encode: function (msg: PartialDeep<Player>): Uint8Array {
    return Player._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Player from protobuf.
   */
  decode: function (bytes: ByteSource): Player {
    return Player._readMessage(
      Player.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Player with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Player>): Player {
    return {
      id: 0,
      title: "",
      tenhouId: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Player>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.tenhouId) {
      writer.writeString(3, msg.tenhouId);
    }
    if (msg.hasAvatar) {
      writer.writeBool(4, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(5, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Player,
    reader: protoscript.BinaryReader,
  ): Player {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.tenhouId = reader.readString();
          break;
        }
        case 4: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 5: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FinalResultOfSession = {
  /**
   * Serializes FinalResultOfSession to protobuf.
   */
  encode: function (msg: PartialDeep<FinalResultOfSession>): Uint8Array {
    return FinalResultOfSession._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FinalResultOfSession from protobuf.
   */
  decode: function (bytes: ByteSource): FinalResultOfSession {
    return FinalResultOfSession._readMessage(
      FinalResultOfSession.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FinalResultOfSession with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FinalResultOfSession>,
  ): FinalResultOfSession {
    return {
      playerId: 0,
      score: 0,
      ratingDelta: 0,
      place: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FinalResultOfSession>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.score) {
      writer.writeInt32(2, msg.score);
    }
    if (msg.ratingDelta) {
      writer.writeFloat(3, msg.ratingDelta);
    }
    if (msg.place) {
      writer.writeInt32(4, msg.place);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FinalResultOfSession,
    reader: protoscript.BinaryReader,
  ): FinalResultOfSession {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.score = reader.readInt32();
          break;
        }
        case 3: {
          msg.ratingDelta = reader.readFloat();
          break;
        }
        case 4: {
          msg.place = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Penalty = {
  /**
   * Serializes Penalty to protobuf.
   */
  encode: function (msg: PartialDeep<Penalty>): Uint8Array {
    return Penalty._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Penalty from protobuf.
   */
  decode: function (bytes: ByteSource): Penalty {
    return Penalty._readMessage(
      Penalty.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Penalty with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Penalty>): Penalty {
    return {
      who: 0,
      amount: 0,
      reason: undefined,
      assignedBy: 0,
      createdAt: "",
      isCancelled: false,
      cancellationReason: undefined,
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Penalty>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.who) {
      writer.writeInt32(1, msg.who);
    }
    if (msg.amount) {
      writer.writeInt32(2, msg.amount);
    }
    if (msg.reason != undefined) {
      writer.writeString(3, msg.reason);
    }
    if (msg.assignedBy) {
      writer.writeInt32(4, msg.assignedBy);
    }
    if (msg.createdAt) {
      writer.writeString(5, msg.createdAt);
    }
    if (msg.isCancelled) {
      writer.writeBool(6, msg.isCancelled);
    }
    if (msg.cancellationReason != undefined) {
      writer.writeString(7, msg.cancellationReason);
    }
    if (msg.id) {
      writer.writeInt32(8, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Penalty,
    reader: protoscript.BinaryReader,
  ): Penalty {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.who = reader.readInt32();
          break;
        }
        case 2: {
          msg.amount = reader.readInt32();
          break;
        }
        case 3: {
          msg.reason = reader.readString();
          break;
        }
        case 4: {
          msg.assignedBy = reader.readInt32();
          break;
        }
        case 5: {
          msg.createdAt = reader.readString();
          break;
        }
        case 6: {
          msg.isCancelled = reader.readBool();
          break;
        }
        case 7: {
          msg.cancellationReason = reader.readString();
          break;
        }
        case 8: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RonResult = {
  /**
   * Serializes RonResult to protobuf.
   */
  encode: function (msg: PartialDeep<RonResult>): Uint8Array {
    return RonResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RonResult from protobuf.
   */
  decode: function (bytes: ByteSource): RonResult {
    return RonResult._readMessage(
      RonResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RonResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RonResult>): RonResult {
    return {
      roundIndex: 0,
      honba: 0,
      winnerId: 0,
      loserId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      riichiBets: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RonResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.winnerId) {
      writer.writeInt32(3, msg.winnerId);
    }
    if (msg.loserId) {
      writer.writeInt32(4, msg.loserId);
    }
    if (msg.paoPlayerId) {
      writer.writeInt32(5, msg.paoPlayerId);
    }
    if (msg.han) {
      writer.writeInt32(6, msg.han);
    }
    if (msg.fu) {
      writer.writeInt32(7, msg.fu);
    }
    if (msg.yaku?.length) {
      writer.writePackedInt32(8, msg.yaku);
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(9, msg.riichiBets);
    }
    if (msg.dora) {
      writer.writeInt32(10, msg.dora);
    }
    if (msg.uradora) {
      writer.writeInt32(11, msg.uradora);
    }
    if (msg.kandora) {
      writer.writeInt32(12, msg.kandora);
    }
    if (msg.kanuradora) {
      writer.writeInt32(13, msg.kanuradora);
    }
    if (msg.openHand) {
      writer.writeBool(14, msg.openHand);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RonResult,
    reader: protoscript.BinaryReader,
  ): RonResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          msg.winnerId = reader.readInt32();
          break;
        }
        case 4: {
          msg.loserId = reader.readInt32();
          break;
        }
        case 5: {
          msg.paoPlayerId = reader.readInt32();
          break;
        }
        case 6: {
          msg.han = reader.readInt32();
          break;
        }
        case 7: {
          msg.fu = reader.readInt32();
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.yaku.push(...reader.readPackedInt32());
          } else {
            msg.yaku.push(reader.readInt32());
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        case 10: {
          msg.dora = reader.readInt32();
          break;
        }
        case 11: {
          msg.uradora = reader.readInt32();
          break;
        }
        case 12: {
          msg.kandora = reader.readInt32();
          break;
        }
        case 13: {
          msg.kanuradora = reader.readInt32();
          break;
        }
        case 14: {
          msg.openHand = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MultironWin = {
  /**
   * Serializes MultironWin to protobuf.
   */
  encode: function (msg: PartialDeep<MultironWin>): Uint8Array {
    return MultironWin._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MultironWin from protobuf.
   */
  decode: function (bytes: ByteSource): MultironWin {
    return MultironWin._readMessage(
      MultironWin.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes MultironWin with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MultironWin>): MultironWin {
    return {
      winnerId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MultironWin>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.winnerId) {
      writer.writeInt32(1, msg.winnerId);
    }
    if (msg.paoPlayerId) {
      writer.writeInt32(2, msg.paoPlayerId);
    }
    if (msg.han) {
      writer.writeInt32(3, msg.han);
    }
    if (msg.fu) {
      writer.writeInt32(4, msg.fu);
    }
    if (msg.yaku?.length) {
      writer.writePackedInt32(5, msg.yaku);
    }
    if (msg.dora) {
      writer.writeInt32(6, msg.dora);
    }
    if (msg.uradora) {
      writer.writeInt32(7, msg.uradora);
    }
    if (msg.kandora) {
      writer.writeInt32(8, msg.kandora);
    }
    if (msg.kanuradora) {
      writer.writeInt32(9, msg.kanuradora);
    }
    if (msg.openHand) {
      writer.writeBool(10, msg.openHand);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MultironWin,
    reader: protoscript.BinaryReader,
  ): MultironWin {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.winnerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.paoPlayerId = reader.readInt32();
          break;
        }
        case 3: {
          msg.han = reader.readInt32();
          break;
        }
        case 4: {
          msg.fu = reader.readInt32();
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.yaku.push(...reader.readPackedInt32());
          } else {
            msg.yaku.push(reader.readInt32());
          }
          break;
        }
        case 6: {
          msg.dora = reader.readInt32();
          break;
        }
        case 7: {
          msg.uradora = reader.readInt32();
          break;
        }
        case 8: {
          msg.kandora = reader.readInt32();
          break;
        }
        case 9: {
          msg.kanuradora = reader.readInt32();
          break;
        }
        case 10: {
          msg.openHand = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MultironResult = {
  /**
   * Serializes MultironResult to protobuf.
   */
  encode: function (msg: PartialDeep<MultironResult>): Uint8Array {
    return MultironResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MultironResult from protobuf.
   */
  decode: function (bytes: ByteSource): MultironResult {
    return MultironResult._readMessage(
      MultironResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes MultironResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MultironResult>): MultironResult {
    return {
      roundIndex: 0,
      honba: 0,
      loserId: 0,
      multiRon: 0,
      wins: [],
      riichiBets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MultironResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.loserId) {
      writer.writeInt32(3, msg.loserId);
    }
    if (msg.multiRon) {
      writer.writeInt32(4, msg.multiRon);
    }
    if (msg.wins?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.wins as any,
        MultironWin._writeMessage,
      );
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(6, msg.riichiBets);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MultironResult,
    reader: protoscript.BinaryReader,
  ): MultironResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          msg.loserId = reader.readInt32();
          break;
        }
        case 4: {
          msg.multiRon = reader.readInt32();
          break;
        }
        case 5: {
          const m = MultironWin.initialize();
          reader.readMessage(m, MultironWin._readMessage);
          msg.wins.push(m);
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TsumoResult = {
  /**
   * Serializes TsumoResult to protobuf.
   */
  encode: function (msg: PartialDeep<TsumoResult>): Uint8Array {
    return TsumoResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TsumoResult from protobuf.
   */
  decode: function (bytes: ByteSource): TsumoResult {
    return TsumoResult._readMessage(
      TsumoResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TsumoResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TsumoResult>): TsumoResult {
    return {
      roundIndex: 0,
      honba: 0,
      winnerId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      riichiBets: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TsumoResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.winnerId) {
      writer.writeInt32(3, msg.winnerId);
    }
    if (msg.paoPlayerId) {
      writer.writeInt32(4, msg.paoPlayerId);
    }
    if (msg.han) {
      writer.writeInt32(5, msg.han);
    }
    if (msg.fu) {
      writer.writeInt32(6, msg.fu);
    }
    if (msg.yaku?.length) {
      writer.writePackedInt32(7, msg.yaku);
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(8, msg.riichiBets);
    }
    if (msg.dora) {
      writer.writeInt32(9, msg.dora);
    }
    if (msg.uradora) {
      writer.writeInt32(10, msg.uradora);
    }
    if (msg.kandora) {
      writer.writeInt32(11, msg.kandora);
    }
    if (msg.kanuradora) {
      writer.writeInt32(12, msg.kanuradora);
    }
    if (msg.openHand) {
      writer.writeBool(13, msg.openHand);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TsumoResult,
    reader: protoscript.BinaryReader,
  ): TsumoResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          msg.winnerId = reader.readInt32();
          break;
        }
        case 4: {
          msg.paoPlayerId = reader.readInt32();
          break;
        }
        case 5: {
          msg.han = reader.readInt32();
          break;
        }
        case 6: {
          msg.fu = reader.readInt32();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.yaku.push(...reader.readPackedInt32());
          } else {
            msg.yaku.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        case 9: {
          msg.dora = reader.readInt32();
          break;
        }
        case 10: {
          msg.uradora = reader.readInt32();
          break;
        }
        case 11: {
          msg.kandora = reader.readInt32();
          break;
        }
        case 12: {
          msg.kanuradora = reader.readInt32();
          break;
        }
        case 13: {
          msg.openHand = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const DrawResult = {
  /**
   * Serializes DrawResult to protobuf.
   */
  encode: function (msg: PartialDeep<DrawResult>): Uint8Array {
    return DrawResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DrawResult from protobuf.
   */
  decode: function (bytes: ByteSource): DrawResult {
    return DrawResult._readMessage(
      DrawResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DrawResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DrawResult>): DrawResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      tempai: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DrawResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(3, msg.riichiBets);
    }
    if (msg.tempai?.length) {
      writer.writePackedInt32(4, msg.tempai);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DrawResult,
    reader: protoscript.BinaryReader,
  ): DrawResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.tempai.push(...reader.readPackedInt32());
          } else {
            msg.tempai.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const AbortResult = {
  /**
   * Serializes AbortResult to protobuf.
   */
  encode: function (msg: PartialDeep<AbortResult>): Uint8Array {
    return AbortResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes AbortResult from protobuf.
   */
  decode: function (bytes: ByteSource): AbortResult {
    return AbortResult._readMessage(
      AbortResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes AbortResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AbortResult>): AbortResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AbortResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(3, msg.riichiBets);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AbortResult,
    reader: protoscript.BinaryReader,
  ): AbortResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChomboResult = {
  /**
   * Serializes ChomboResult to protobuf.
   */
  encode: function (msg: PartialDeep<ChomboResult>): Uint8Array {
    return ChomboResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ChomboResult from protobuf.
   */
  decode: function (bytes: ByteSource): ChomboResult {
    return ChomboResult._readMessage(
      ChomboResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ChomboResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ChomboResult>): ChomboResult {
    return {
      roundIndex: 0,
      honba: 0,
      loserId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ChomboResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.loserId) {
      writer.writeInt32(3, msg.loserId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChomboResult,
    reader: protoscript.BinaryReader,
  ): ChomboResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          msg.loserId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NagashiResult = {
  /**
   * Serializes NagashiResult to protobuf.
   */
  encode: function (msg: PartialDeep<NagashiResult>): Uint8Array {
    return NagashiResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes NagashiResult from protobuf.
   */
  decode: function (bytes: ByteSource): NagashiResult {
    return NagashiResult._readMessage(
      NagashiResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes NagashiResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<NagashiResult>): NagashiResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      tempai: [],
      nagashi: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NagashiResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.roundIndex) {
      writer.writeInt32(1, msg.roundIndex);
    }
    if (msg.honba) {
      writer.writeInt32(2, msg.honba);
    }
    if (msg.riichiBets?.length) {
      writer.writePackedInt32(3, msg.riichiBets);
    }
    if (msg.tempai?.length) {
      writer.writePackedInt32(4, msg.tempai);
    }
    if (msg.nagashi?.length) {
      writer.writePackedInt32(5, msg.nagashi);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NagashiResult,
    reader: protoscript.BinaryReader,
  ): NagashiResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.honba = reader.readInt32();
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.riichiBets.push(...reader.readPackedInt32());
          } else {
            msg.riichiBets.push(reader.readInt32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.tempai.push(...reader.readPackedInt32());
          } else {
            msg.tempai.push(reader.readInt32());
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.nagashi.push(...reader.readPackedInt32());
          } else {
            msg.nagashi.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Round = {
  /**
   * Serializes Round to protobuf.
   */
  encode: function (msg: PartialDeep<Round>): Uint8Array {
    return Round._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Round from protobuf.
   */
  decode: function (bytes: ByteSource): Round {
    return Round._readMessage(
      Round.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Round with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Round>): Round {
    return {
      ron: undefined,
      tsumo: undefined,
      multiron: undefined,
      draw: undefined,
      abort: undefined,
      chombo: undefined,
      nagashi: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Round>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ron != undefined) {
      writer.writeMessage(1, msg.ron, RonResult._writeMessage);
    }
    if (msg.tsumo != undefined) {
      writer.writeMessage(2, msg.tsumo, TsumoResult._writeMessage);
    }
    if (msg.multiron != undefined) {
      writer.writeMessage(3, msg.multiron, MultironResult._writeMessage);
    }
    if (msg.draw != undefined) {
      writer.writeMessage(4, msg.draw, DrawResult._writeMessage);
    }
    if (msg.abort != undefined) {
      writer.writeMessage(5, msg.abort, AbortResult._writeMessage);
    }
    if (msg.chombo != undefined) {
      writer.writeMessage(6, msg.chombo, ChomboResult._writeMessage);
    }
    if (msg.nagashi != undefined) {
      writer.writeMessage(7, msg.nagashi, NagashiResult._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Round, reader: protoscript.BinaryReader): Round {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ron = RonResult.initialize();
          reader.readMessage(msg.ron, RonResult._readMessage);
          break;
        }
        case 2: {
          msg.tsumo = TsumoResult.initialize();
          reader.readMessage(msg.tsumo, TsumoResult._readMessage);
          break;
        }
        case 3: {
          msg.multiron = MultironResult.initialize();
          reader.readMessage(msg.multiron, MultironResult._readMessage);
          break;
        }
        case 4: {
          msg.draw = DrawResult.initialize();
          reader.readMessage(msg.draw, DrawResult._readMessage);
          break;
        }
        case 5: {
          msg.abort = AbortResult.initialize();
          reader.readMessage(msg.abort, AbortResult._readMessage);
          break;
        }
        case 6: {
          msg.chombo = ChomboResult.initialize();
          reader.readMessage(msg.chombo, ChomboResult._readMessage);
          break;
        }
        case 7: {
          msg.nagashi = NagashiResult.initialize();
          reader.readMessage(msg.nagashi, NagashiResult._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GameResult = {
  /**
   * Serializes GameResult to protobuf.
   */
  encode: function (msg: PartialDeep<GameResult>): Uint8Array {
    return GameResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GameResult from protobuf.
   */
  decode: function (bytes: ByteSource): GameResult {
    return GameResult._readMessage(
      GameResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GameResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GameResult>): GameResult {
    return {
      sessionHash: "",
      date: undefined,
      replayLink: "",
      players: [],
      finalResults: [],
      rounds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GameResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.date != undefined) {
      writer.writeString(2, msg.date);
    }
    if (msg.replayLink) {
      writer.writeString(3, msg.replayLink);
    }
    if (msg.players?.length) {
      writer.writePackedInt32(4, msg.players);
    }
    if (msg.finalResults?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.finalResults as any,
        FinalResultOfSession._writeMessage,
      );
    }
    if (msg.rounds?.length) {
      writer.writeRepeatedMessage(7, msg.rounds as any, Round._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GameResult,
    reader: protoscript.BinaryReader,
  ): GameResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          msg.date = reader.readString();
          break;
        }
        case 3: {
          msg.replayLink = reader.readString();
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.players.push(...reader.readPackedInt32());
          } else {
            msg.players.push(reader.readInt32());
          }
          break;
        }
        case 5: {
          const m = FinalResultOfSession.initialize();
          reader.readMessage(m, FinalResultOfSession._readMessage);
          msg.finalResults.push(m);
          break;
        }
        case 7: {
          const m = Round.initialize();
          reader.readMessage(m, Round._readMessage);
          msg.rounds.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerPlaceInSeries = {
  /**
   * Serializes PlayerPlaceInSeries to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerPlaceInSeries>): Uint8Array {
    return PlayerPlaceInSeries._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerPlaceInSeries from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerPlaceInSeries {
    return PlayerPlaceInSeries._readMessage(
      PlayerPlaceInSeries.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerPlaceInSeries with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayerPlaceInSeries>,
  ): PlayerPlaceInSeries {
    return {
      sessionHash: "",
      place: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerPlaceInSeries>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.place) {
      writer.writeInt32(2, msg.place);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerPlaceInSeries,
    reader: protoscript.BinaryReader,
  ): PlayerPlaceInSeries {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          msg.place = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeriesResult = {
  /**
   * Serializes SeriesResult to protobuf.
   */
  encode: function (msg: PartialDeep<SeriesResult>): Uint8Array {
    return SeriesResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeriesResult from protobuf.
   */
  decode: function (bytes: ByteSource): SeriesResult {
    return SeriesResult._readMessage(
      SeriesResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeriesResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SeriesResult>): SeriesResult {
    return {
      player: Player.initialize(),
      bestSeries: [],
      bestSeriesScores: 0,
      bestSeriesPlaces: 0,
      bestSeriesAvgPlace: "",
      currentSeries: [],
      currentSeriesScores: 0,
      currentSeriesPlaces: 0,
      currentSeriesAvgPlace: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeriesResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.player) {
      writer.writeMessage(1, msg.player, Player._writeMessage);
    }
    if (msg.bestSeries?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.bestSeries as any,
        PlayerPlaceInSeries._writeMessage,
      );
    }
    if (msg.bestSeriesScores) {
      writer.writeFloat(3, msg.bestSeriesScores);
    }
    if (msg.bestSeriesPlaces) {
      writer.writeInt32(4, msg.bestSeriesPlaces);
    }
    if (msg.bestSeriesAvgPlace) {
      writer.writeString(5, msg.bestSeriesAvgPlace);
    }
    if (msg.currentSeries?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.currentSeries as any,
        PlayerPlaceInSeries._writeMessage,
      );
    }
    if (msg.currentSeriesScores) {
      writer.writeFloat(7, msg.currentSeriesScores);
    }
    if (msg.currentSeriesPlaces) {
      writer.writeInt32(8, msg.currentSeriesPlaces);
    }
    if (msg.currentSeriesAvgPlace) {
      writer.writeString(9, msg.currentSeriesAvgPlace);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeriesResult,
    reader: protoscript.BinaryReader,
  ): SeriesResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.player, Player._readMessage);
          break;
        }
        case 2: {
          const m = PlayerPlaceInSeries.initialize();
          reader.readMessage(m, PlayerPlaceInSeries._readMessage);
          msg.bestSeries.push(m);
          break;
        }
        case 3: {
          msg.bestSeriesScores = reader.readFloat();
          break;
        }
        case 4: {
          msg.bestSeriesPlaces = reader.readInt32();
          break;
        }
        case 5: {
          msg.bestSeriesAvgPlace = reader.readString();
          break;
        }
        case 6: {
          const m = PlayerPlaceInSeries.initialize();
          reader.readMessage(m, PlayerPlaceInSeries._readMessage);
          msg.currentSeries.push(m);
          break;
        }
        case 7: {
          msg.currentSeriesScores = reader.readFloat();
          break;
        }
        case 8: {
          msg.currentSeriesPlaces = reader.readInt32();
          break;
        }
        case 9: {
          msg.currentSeriesAvgPlace = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ReplacementPlayer = {
  /**
   * Serializes ReplacementPlayer to protobuf.
   */
  encode: function (msg: PartialDeep<ReplacementPlayer>): Uint8Array {
    return ReplacementPlayer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ReplacementPlayer from protobuf.
   */
  decode: function (bytes: ByteSource): ReplacementPlayer {
    return ReplacementPlayer._readMessage(
      ReplacementPlayer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ReplacementPlayer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ReplacementPlayer>): ReplacementPlayer {
    return {
      id: 0,
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReplacementPlayer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.hasAvatar) {
      writer.writeBool(3, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(4, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReplacementPlayer,
    reader: protoscript.BinaryReader,
  ): ReplacementPlayer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 4: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerInSession = {
  /**
   * Serializes PlayerInSession to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerInSession>): Uint8Array {
    return PlayerInSession._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerInSession from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerInSession {
    return PlayerInSession._readMessage(
      PlayerInSession.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerInSession with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerInSession>): PlayerInSession {
    return {
      id: 0,
      title: "",
      score: 0,
      replacedBy: undefined,
      ratingDelta: 0,
      hasAvatar: false,
      lastUpdate: "",
      yakitori: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerInSession>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.score) {
      writer.writeInt32(3, msg.score);
    }
    if (msg.replacedBy != undefined) {
      writer.writeMessage(4, msg.replacedBy, ReplacementPlayer._writeMessage);
    }
    if (msg.ratingDelta) {
      writer.writeFloat(5, msg.ratingDelta);
    }
    if (msg.hasAvatar) {
      writer.writeBool(6, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(7, msg.lastUpdate);
    }
    if (msg.yakitori) {
      writer.writeBool(8, msg.yakitori);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerInSession,
    reader: protoscript.BinaryReader,
  ): PlayerInSession {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.score = reader.readInt32();
          break;
        }
        case 4: {
          msg.replacedBy = ReplacementPlayer.initialize();
          reader.readMessage(msg.replacedBy, ReplacementPlayer._readMessage);
          break;
        }
        case 5: {
          msg.ratingDelta = reader.readFloat();
          break;
        }
        case 6: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 7: {
          msg.lastUpdate = reader.readString();
          break;
        }
        case 8: {
          msg.yakitori = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RegisteredPlayer = {
  /**
   * Serializes RegisteredPlayer to protobuf.
   */
  encode: function (msg: PartialDeep<RegisteredPlayer>): Uint8Array {
    return RegisteredPlayer._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RegisteredPlayer from protobuf.
   */
  decode: function (bytes: ByteSource): RegisteredPlayer {
    return RegisteredPlayer._readMessage(
      RegisteredPlayer.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RegisteredPlayer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RegisteredPlayer>): RegisteredPlayer {
    return {
      id: 0,
      title: "",
      localId: undefined,
      teamName: undefined,
      tenhouId: "",
      ignoreSeating: false,
      replacedBy: undefined,
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisteredPlayer>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.localId != undefined) {
      writer.writeInt32(3, msg.localId);
    }
    if (msg.teamName != undefined) {
      writer.writeString(4, msg.teamName);
    }
    if (msg.tenhouId) {
      writer.writeString(5, msg.tenhouId);
    }
    if (msg.ignoreSeating) {
      writer.writeBool(6, msg.ignoreSeating);
    }
    if (msg.replacedBy != undefined) {
      writer.writeMessage(7, msg.replacedBy, ReplacementPlayer._writeMessage);
    }
    if (msg.hasAvatar) {
      writer.writeBool(8, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(9, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RegisteredPlayer,
    reader: protoscript.BinaryReader,
  ): RegisteredPlayer {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.localId = reader.readInt32();
          break;
        }
        case 4: {
          msg.teamName = reader.readString();
          break;
        }
        case 5: {
          msg.tenhouId = reader.readString();
          break;
        }
        case 6: {
          msg.ignoreSeating = reader.readBool();
          break;
        }
        case 7: {
          msg.replacedBy = ReplacementPlayer.initialize();
          reader.readMessage(msg.replacedBy, ReplacementPlayer._readMessage);
          break;
        }
        case 8: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 9: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SessionHistoryResult = {
  /**
   * Serializes SessionHistoryResult to protobuf.
   */
  encode: function (msg: PartialDeep<SessionHistoryResult>): Uint8Array {
    return SessionHistoryResult._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SessionHistoryResult from protobuf.
   */
  decode: function (bytes: ByteSource): SessionHistoryResult {
    return SessionHistoryResult._readMessage(
      SessionHistoryResult.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SessionHistoryResult with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SessionHistoryResult>,
  ): SessionHistoryResult {
    return {
      sessionHash: "",
      eventId: 0,
      playerId: 0,
      score: 0,
      ratingDelta: 0,
      place: 0,
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionHistoryResult>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.playerId) {
      writer.writeInt32(3, msg.playerId);
    }
    if (msg.score) {
      writer.writeInt32(4, msg.score);
    }
    if (msg.ratingDelta) {
      writer.writeFloat(5, msg.ratingDelta);
    }
    if (msg.place) {
      writer.writeInt32(6, msg.place);
    }
    if (msg.title) {
      writer.writeString(7, msg.title);
    }
    if (msg.hasAvatar) {
      writer.writeBool(8, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(9, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SessionHistoryResult,
    reader: protoscript.BinaryReader,
  ): SessionHistoryResult {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 4: {
          msg.score = reader.readInt32();
          break;
        }
        case 5: {
          msg.ratingDelta = reader.readFloat();
          break;
        }
        case 6: {
          msg.place = reader.readInt32();
          break;
        }
        case 7: {
          msg.title = reader.readString();
          break;
        }
        case 8: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 9: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SessionHistoryResultTable = {
  /**
   * Serializes SessionHistoryResultTable to protobuf.
   */
  encode: function (msg: PartialDeep<SessionHistoryResultTable>): Uint8Array {
    return SessionHistoryResultTable._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SessionHistoryResultTable from protobuf.
   */
  decode: function (bytes: ByteSource): SessionHistoryResultTable {
    return SessionHistoryResultTable._readMessage(
      SessionHistoryResultTable.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SessionHistoryResultTable with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SessionHistoryResultTable>,
  ): SessionHistoryResultTable {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionHistoryResultTable>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        SessionHistoryResult._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SessionHistoryResultTable,
    reader: protoscript.BinaryReader,
  ): SessionHistoryResultTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = SessionHistoryResult.initialize();
          reader.readMessage(m, SessionHistoryResult._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlacesSummaryItem = {
  /**
   * Serializes PlacesSummaryItem to protobuf.
   */
  encode: function (msg: PartialDeep<PlacesSummaryItem>): Uint8Array {
    return PlacesSummaryItem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlacesSummaryItem from protobuf.
   */
  decode: function (bytes: ByteSource): PlacesSummaryItem {
    return PlacesSummaryItem._readMessage(
      PlacesSummaryItem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlacesSummaryItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlacesSummaryItem>): PlacesSummaryItem {
    return {
      place: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlacesSummaryItem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.place) {
      writer.writeInt32(1, msg.place);
    }
    if (msg.count) {
      writer.writeInt32(2, msg.count);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlacesSummaryItem,
    reader: protoscript.BinaryReader,
  ): PlacesSummaryItem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.place = reader.readInt32();
          break;
        }
        case 2: {
          msg.count = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerWinSummary = {
  /**
   * Serializes PlayerWinSummary to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerWinSummary>): Uint8Array {
    return PlayerWinSummary._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerWinSummary from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerWinSummary {
    return PlayerWinSummary._readMessage(
      PlayerWinSummary.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerWinSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerWinSummary>): PlayerWinSummary {
    return {
      ron: 0,
      tsumo: 0,
      chombo: 0,
      feed: 0,
      tsumofeed: 0,
      winsWithOpen: 0,
      winsWithRiichi: 0,
      winsWithDama: 0,
      unforcedFeedToOpen: 0,
      unforcedFeedToRiichi: 0,
      unforcedFeedToDama: 0,
      draw: 0,
      drawTempai: 0,
      pointsWon: 0,
      pointsLostRon: 0,
      pointsLostTsumo: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerWinSummary>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ron) {
      writer.writeInt32(1, msg.ron);
    }
    if (msg.tsumo) {
      writer.writeInt32(2, msg.tsumo);
    }
    if (msg.chombo) {
      writer.writeInt32(3, msg.chombo);
    }
    if (msg.feed) {
      writer.writeInt32(4, msg.feed);
    }
    if (msg.tsumofeed) {
      writer.writeInt32(5, msg.tsumofeed);
    }
    if (msg.winsWithOpen) {
      writer.writeInt32(6, msg.winsWithOpen);
    }
    if (msg.winsWithRiichi) {
      writer.writeInt32(7, msg.winsWithRiichi);
    }
    if (msg.winsWithDama) {
      writer.writeInt32(8, msg.winsWithDama);
    }
    if (msg.unforcedFeedToOpen) {
      writer.writeInt32(9, msg.unforcedFeedToOpen);
    }
    if (msg.unforcedFeedToRiichi) {
      writer.writeInt32(10, msg.unforcedFeedToRiichi);
    }
    if (msg.unforcedFeedToDama) {
      writer.writeInt32(11, msg.unforcedFeedToDama);
    }
    if (msg.draw) {
      writer.writeInt32(12, msg.draw);
    }
    if (msg.drawTempai) {
      writer.writeInt32(13, msg.drawTempai);
    }
    if (msg.pointsWon) {
      writer.writeInt32(14, msg.pointsWon);
    }
    if (msg.pointsLostRon) {
      writer.writeInt32(15, msg.pointsLostRon);
    }
    if (msg.pointsLostTsumo) {
      writer.writeInt32(16, msg.pointsLostTsumo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerWinSummary,
    reader: protoscript.BinaryReader,
  ): PlayerWinSummary {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.ron = reader.readInt32();
          break;
        }
        case 2: {
          msg.tsumo = reader.readInt32();
          break;
        }
        case 3: {
          msg.chombo = reader.readInt32();
          break;
        }
        case 4: {
          msg.feed = reader.readInt32();
          break;
        }
        case 5: {
          msg.tsumofeed = reader.readInt32();
          break;
        }
        case 6: {
          msg.winsWithOpen = reader.readInt32();
          break;
        }
        case 7: {
          msg.winsWithRiichi = reader.readInt32();
          break;
        }
        case 8: {
          msg.winsWithDama = reader.readInt32();
          break;
        }
        case 9: {
          msg.unforcedFeedToOpen = reader.readInt32();
          break;
        }
        case 10: {
          msg.unforcedFeedToRiichi = reader.readInt32();
          break;
        }
        case 11: {
          msg.unforcedFeedToDama = reader.readInt32();
          break;
        }
        case 12: {
          msg.draw = reader.readInt32();
          break;
        }
        case 13: {
          msg.drawTempai = reader.readInt32();
          break;
        }
        case 14: {
          msg.pointsWon = reader.readInt32();
          break;
        }
        case 15: {
          msg.pointsLostRon = reader.readInt32();
          break;
        }
        case 16: {
          msg.pointsLostTsumo = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const HandValueStat = {
  /**
   * Serializes HandValueStat to protobuf.
   */
  encode: function (msg: PartialDeep<HandValueStat>): Uint8Array {
    return HandValueStat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes HandValueStat from protobuf.
   */
  decode: function (bytes: ByteSource): HandValueStat {
    return HandValueStat._readMessage(
      HandValueStat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes HandValueStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<HandValueStat>): HandValueStat {
    return {
      hanCount: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<HandValueStat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.hanCount) {
      writer.writeInt32(1, msg.hanCount);
    }
    if (msg.count) {
      writer.writeInt32(2, msg.count);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: HandValueStat,
    reader: protoscript.BinaryReader,
  ): HandValueStat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.hanCount = reader.readInt32();
          break;
        }
        case 2: {
          msg.count = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const YakuStat = {
  /**
   * Serializes YakuStat to protobuf.
   */
  encode: function (msg: PartialDeep<YakuStat>): Uint8Array {
    return YakuStat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes YakuStat from protobuf.
   */
  decode: function (bytes: ByteSource): YakuStat {
    return YakuStat._readMessage(
      YakuStat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes YakuStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<YakuStat>): YakuStat {
    return {
      yakuId: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<YakuStat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.yakuId) {
      writer.writeInt32(1, msg.yakuId);
    }
    if (msg.count) {
      writer.writeInt32(2, msg.count);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: YakuStat,
    reader: protoscript.BinaryReader,
  ): YakuStat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.yakuId = reader.readInt32();
          break;
        }
        case 2: {
          msg.count = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RiichiSummary = {
  /**
   * Serializes RiichiSummary to protobuf.
   */
  encode: function (msg: PartialDeep<RiichiSummary>): Uint8Array {
    return RiichiSummary._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RiichiSummary from protobuf.
   */
  decode: function (bytes: ByteSource): RiichiSummary {
    return RiichiSummary._readMessage(
      RiichiSummary.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RiichiSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RiichiSummary>): RiichiSummary {
    return {
      riichiWon: 0,
      riichiLost: 0,
      feedUnderRiichi: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RiichiSummary>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.riichiWon) {
      writer.writeInt32(1, msg.riichiWon);
    }
    if (msg.riichiLost) {
      writer.writeInt32(2, msg.riichiLost);
    }
    if (msg.feedUnderRiichi) {
      writer.writeInt32(3, msg.feedUnderRiichi);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RiichiSummary,
    reader: protoscript.BinaryReader,
  ): RiichiSummary {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.riichiWon = reader.readInt32();
          break;
        }
        case 2: {
          msg.riichiLost = reader.readInt32();
          break;
        }
        case 3: {
          msg.feedUnderRiichi = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const DoraSummary = {
  /**
   * Serializes DoraSummary to protobuf.
   */
  encode: function (msg: PartialDeep<DoraSummary>): Uint8Array {
    return DoraSummary._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DoraSummary from protobuf.
   */
  decode: function (bytes: ByteSource): DoraSummary {
    return DoraSummary._readMessage(
      DoraSummary.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DoraSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DoraSummary>): DoraSummary {
    return {
      count: 0,
      average: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DoraSummary>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.count) {
      writer.writeInt32(1, msg.count);
    }
    if (msg.average) {
      writer.writeFloat(2, msg.average);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DoraSummary,
    reader: protoscript.BinaryReader,
  ): DoraSummary {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.count = reader.readInt32();
          break;
        }
        case 2: {
          msg.average = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const IntermediateResultOfSession = {
  /**
   * Serializes IntermediateResultOfSession to protobuf.
   */
  encode: function (msg: PartialDeep<IntermediateResultOfSession>): Uint8Array {
    return IntermediateResultOfSession._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes IntermediateResultOfSession from protobuf.
   */
  decode: function (bytes: ByteSource): IntermediateResultOfSession {
    return IntermediateResultOfSession._readMessage(
      IntermediateResultOfSession.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes IntermediateResultOfSession with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<IntermediateResultOfSession>,
  ): IntermediateResultOfSession {
    return {
      playerId: 0,
      score: 0,
      chomboCount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<IntermediateResultOfSession>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.score) {
      writer.writeInt32(2, msg.score);
    }
    if (msg.chomboCount) {
      writer.writeInt32(4, msg.chomboCount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: IntermediateResultOfSession,
    reader: protoscript.BinaryReader,
  ): IntermediateResultOfSession {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.score = reader.readInt32();
          break;
        }
        case 4: {
          msg.chomboCount = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PaymentLogItem = {
  /**
   * Serializes PaymentLogItem to protobuf.
   */
  encode: function (msg: PartialDeep<PaymentLogItem>): Uint8Array {
    return PaymentLogItem._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PaymentLogItem from protobuf.
   */
  decode: function (bytes: ByteSource): PaymentLogItem {
    return PaymentLogItem._readMessage(
      PaymentLogItem.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PaymentLogItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PaymentLogItem>): PaymentLogItem {
    return {
      from: undefined,
      to: undefined,
      amount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PaymentLogItem>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.from != undefined) {
      writer.writeInt32(1, msg.from);
    }
    if (msg.to != undefined) {
      writer.writeInt32(2, msg.to);
    }
    if (msg.amount) {
      writer.writeInt32(3, msg.amount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PaymentLogItem,
    reader: protoscript.BinaryReader,
  ): PaymentLogItem {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.from = reader.readInt32();
          break;
        }
        case 2: {
          msg.to = reader.readInt32();
          break;
        }
        case 3: {
          msg.amount = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PaymentLog = {
  /**
   * Serializes PaymentLog to protobuf.
   */
  encode: function (msg: PartialDeep<PaymentLog>): Uint8Array {
    return PaymentLog._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PaymentLog from protobuf.
   */
  decode: function (bytes: ByteSource): PaymentLog {
    return PaymentLog._readMessage(
      PaymentLog.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PaymentLog with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PaymentLog>): PaymentLog {
    return {
      direct: [],
      riichi: [],
      honba: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PaymentLog>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.direct?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.direct as any,
        PaymentLogItem._writeMessage,
      );
    }
    if (msg.riichi?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.riichi as any,
        PaymentLogItem._writeMessage,
      );
    }
    if (msg.honba?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.honba as any,
        PaymentLogItem._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PaymentLog,
    reader: protoscript.BinaryReader,
  ): PaymentLog {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = PaymentLogItem.initialize();
          reader.readMessage(m, PaymentLogItem._readMessage);
          msg.direct.push(m);
          break;
        }
        case 2: {
          const m = PaymentLogItem.initialize();
          reader.readMessage(m, PaymentLogItem._readMessage);
          msg.riichi.push(m);
          break;
        }
        case 3: {
          const m = PaymentLogItem.initialize();
          reader.readMessage(m, PaymentLogItem._readMessage);
          msg.honba.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RoundState = {
  /**
   * Serializes RoundState to protobuf.
   */
  encode: function (msg: PartialDeep<RoundState>): Uint8Array {
    return RoundState._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RoundState from protobuf.
   */
  decode: function (bytes: ByteSource): RoundState {
    return RoundState._readMessage(
      RoundState.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RoundState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RoundState>): RoundState {
    return {
      sessionHash: "",
      dealer: 0,
      roundIndex: 0,
      riichi: 0,
      honba: 0,
      riichiIds: [],
      scores: [],
      scoresDelta: [],
      payments: PaymentLog.initialize(),
      round: Round.initialize(),
      outcome: RoundOutcome._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RoundState>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.dealer) {
      writer.writeInt32(2, msg.dealer);
    }
    if (msg.roundIndex) {
      writer.writeInt32(3, msg.roundIndex);
    }
    if (msg.riichi) {
      writer.writeInt32(4, msg.riichi);
    }
    if (msg.honba) {
      writer.writeInt32(5, msg.honba);
    }
    if (msg.riichiIds?.length) {
      writer.writePackedInt32(6, msg.riichiIds);
    }
    if (msg.scores?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.scores as any,
        IntermediateResultOfSession._writeMessage,
      );
    }
    if (msg.scoresDelta?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.scoresDelta as any,
        IntermediateResultOfSession._writeMessage,
      );
    }
    if (msg.payments) {
      writer.writeMessage(9, msg.payments, PaymentLog._writeMessage);
    }
    if (msg.round) {
      writer.writeMessage(10, msg.round, Round._writeMessage);
    }
    if (msg.outcome && RoundOutcome._toInt(msg.outcome)) {
      writer.writeEnum(11, RoundOutcome._toInt(msg.outcome));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RoundState,
    reader: protoscript.BinaryReader,
  ): RoundState {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          msg.dealer = reader.readInt32();
          break;
        }
        case 3: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 4: {
          msg.riichi = reader.readInt32();
          break;
        }
        case 5: {
          msg.honba = reader.readInt32();
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.riichiIds.push(...reader.readPackedInt32());
          } else {
            msg.riichiIds.push(reader.readInt32());
          }
          break;
        }
        case 7: {
          const m = IntermediateResultOfSession.initialize();
          reader.readMessage(m, IntermediateResultOfSession._readMessage);
          msg.scores.push(m);
          break;
        }
        case 8: {
          const m = IntermediateResultOfSession.initialize();
          reader.readMessage(m, IntermediateResultOfSession._readMessage);
          msg.scoresDelta.push(m);
          break;
        }
        case 9: {
          reader.readMessage(msg.payments, PaymentLog._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.round, Round._readMessage);
          break;
        }
        case 11: {
          msg.outcome = RoundOutcome._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventData = {
  /**
   * Serializes EventData to protobuf.
   */
  encode: function (msg: PartialDeep<EventData>): Uint8Array {
    return EventData._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventData from protobuf.
   */
  decode: function (bytes: ByteSource): EventData {
    return EventData._readMessage(
      EventData.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventData with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventData>): EventData {
    return {
      type: undefined,
      title: "",
      description: "",
      duration: 0,
      timezone: "",
      lobbyId: 0,
      seriesLength: 0,
      minGames: 0,
      isTeam: false,
      isPrescripted: false,
      autostart: 0,
      rulesetConfig: RulesetConfig.initialize(),
      isListed: false,
      isRatingShown: false,
      achievementsShown: false,
      allowViewOtherTables: false,
      platformId: PlatformType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventData>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.type != undefined) {
      writer.writeEnum(1, EventType._toInt(msg.type));
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.duration) {
      writer.writeInt32(4, msg.duration);
    }
    if (msg.timezone) {
      writer.writeString(6, msg.timezone);
    }
    if (msg.lobbyId) {
      writer.writeInt32(7, msg.lobbyId);
    }
    if (msg.seriesLength) {
      writer.writeInt32(8, msg.seriesLength);
    }
    if (msg.minGames) {
      writer.writeInt32(9, msg.minGames);
    }
    if (msg.isTeam) {
      writer.writeBool(10, msg.isTeam);
    }
    if (msg.isPrescripted) {
      writer.writeBool(11, msg.isPrescripted);
    }
    if (msg.autostart) {
      writer.writeInt32(12, msg.autostart);
    }
    if (msg.rulesetConfig) {
      writer.writeMessage(14, msg.rulesetConfig, RulesetConfig._writeMessage);
    }
    if (msg.isListed) {
      writer.writeBool(15, msg.isListed);
    }
    if (msg.isRatingShown) {
      writer.writeBool(16, msg.isRatingShown);
    }
    if (msg.achievementsShown) {
      writer.writeBool(17, msg.achievementsShown);
    }
    if (msg.allowViewOtherTables) {
      writer.writeBool(18, msg.allowViewOtherTables);
    }
    if (msg.platformId && PlatformType._toInt(msg.platformId)) {
      writer.writeEnum(19, PlatformType._toInt(msg.platformId));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventData,
    reader: protoscript.BinaryReader,
  ): EventData {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.type = EventType._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.duration = reader.readInt32();
          break;
        }
        case 6: {
          msg.timezone = reader.readString();
          break;
        }
        case 7: {
          msg.lobbyId = reader.readInt32();
          break;
        }
        case 8: {
          msg.seriesLength = reader.readInt32();
          break;
        }
        case 9: {
          msg.minGames = reader.readInt32();
          break;
        }
        case 10: {
          msg.isTeam = reader.readBool();
          break;
        }
        case 11: {
          msg.isPrescripted = reader.readBool();
          break;
        }
        case 12: {
          msg.autostart = reader.readInt32();
          break;
        }
        case 14: {
          reader.readMessage(msg.rulesetConfig, RulesetConfig._readMessage);
          break;
        }
        case 15: {
          msg.isListed = reader.readBool();
          break;
        }
        case 16: {
          msg.isRatingShown = reader.readBool();
          break;
        }
        case 17: {
          msg.achievementsShown = reader.readBool();
          break;
        }
        case 18: {
          msg.allowViewOtherTables = reader.readBool();
          break;
        }
        case 19: {
          msg.platformId = PlatformType._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TableState = {
  /**
   * Serializes TableState to protobuf.
   */
  encode: function (msg: PartialDeep<TableState>): Uint8Array {
    return TableState._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TableState from protobuf.
   */
  decode: function (bytes: ByteSource): TableState {
    return TableState._readMessage(
      TableState.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TableState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TableState>): TableState {
    return {
      status: SessionStatus._fromInt(0),
      mayDefinalize: false,
      sessionHash: "",
      tableIndex: undefined,
      lastRound: undefined,
      currentRoundIndex: 0,
      scores: [],
      players: [],
      extraTime: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TableState>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status && SessionStatus._toInt(msg.status)) {
      writer.writeEnum(1, SessionStatus._toInt(msg.status));
    }
    if (msg.mayDefinalize) {
      writer.writeBool(2, msg.mayDefinalize);
    }
    if (msg.sessionHash) {
      writer.writeString(3, msg.sessionHash);
    }
    if (msg.tableIndex != undefined) {
      writer.writeInt32(5, msg.tableIndex);
    }
    if (msg.lastRound != undefined) {
      writer.writeMessage(6, msg.lastRound, Round._writeMessage);
    }
    if (msg.currentRoundIndex) {
      writer.writeInt32(7, msg.currentRoundIndex);
    }
    if (msg.scores?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.scores as any,
        IntermediateResultOfSession._writeMessage,
      );
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.players as any,
        RegisteredPlayer._writeMessage,
      );
    }
    if (msg.extraTime != undefined) {
      writer.writeInt32(10, msg.extraTime);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TableState,
    reader: protoscript.BinaryReader,
  ): TableState {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.status = SessionStatus._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.mayDefinalize = reader.readBool();
          break;
        }
        case 3: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 5: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 6: {
          msg.lastRound = Round.initialize();
          reader.readMessage(msg.lastRound, Round._readMessage);
          break;
        }
        case 7: {
          msg.currentRoundIndex = reader.readInt32();
          break;
        }
        case 8: {
          const m = IntermediateResultOfSession.initialize();
          reader.readMessage(m, IntermediateResultOfSession._readMessage);
          msg.scores.push(m);
          break;
        }
        case 9: {
          const m = RegisteredPlayer.initialize();
          reader.readMessage(m, RegisteredPlayer._readMessage);
          msg.players.push(m);
          break;
        }
        case 10: {
          msg.extraTime = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Achievement = {
  /**
   * Serializes Achievement to protobuf.
   */
  encode: function (msg: PartialDeep<Achievement>): Uint8Array {
    return Achievement._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Achievement from protobuf.
   */
  decode: function (bytes: ByteSource): Achievement {
    return Achievement._readMessage(
      Achievement.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Achievement with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Achievement>): Achievement {
    return {
      achievementId: "",
      achievementData: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Achievement>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.achievementId) {
      writer.writeString(1, msg.achievementId);
    }
    if (msg.achievementData) {
      writer.writeString(2, msg.achievementData);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Achievement,
    reader: protoscript.BinaryReader,
  ): Achievement {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.achievementId = reader.readString();
          break;
        }
        case 2: {
          msg.achievementData = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const LocalIdMapping = {
  /**
   * Serializes LocalIdMapping to protobuf.
   */
  encode: function (msg: PartialDeep<LocalIdMapping>): Uint8Array {
    return LocalIdMapping._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes LocalIdMapping from protobuf.
   */
  decode: function (bytes: ByteSource): LocalIdMapping {
    return LocalIdMapping._readMessage(
      LocalIdMapping.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes LocalIdMapping with all fields set to their default value.
   */
  initialize: function (msg?: Partial<LocalIdMapping>): LocalIdMapping {
    return {
      playerId: 0,
      localId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<LocalIdMapping>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.localId) {
      writer.writeInt32(2, msg.localId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: LocalIdMapping,
    reader: protoscript.BinaryReader,
  ): LocalIdMapping {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.localId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TeamMapping = {
  /**
   * Serializes TeamMapping to protobuf.
   */
  encode: function (msg: PartialDeep<TeamMapping>): Uint8Array {
    return TeamMapping._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TeamMapping from protobuf.
   */
  decode: function (bytes: ByteSource): TeamMapping {
    return TeamMapping._readMessage(
      TeamMapping.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TeamMapping with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TeamMapping>): TeamMapping {
    return {
      playerId: 0,
      teamName: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TeamMapping>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.teamName) {
      writer.writeString(2, msg.teamName);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TeamMapping,
    reader: protoscript.BinaryReader,
  ): TeamMapping {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.teamName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerSeating = {
  /**
   * Serializes PlayerSeating to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerSeating>): Uint8Array {
    return PlayerSeating._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerSeating from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerSeating {
    return PlayerSeating._readMessage(
      PlayerSeating.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerSeating with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerSeating>): PlayerSeating {
    return {
      order: 0,
      playerId: 0,
      sessionId: 0,
      tableIndex: 0,
      rating: 0,
      playerTitle: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerSeating>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.order) {
      writer.writeInt32(1, msg.order);
    }
    if (msg.playerId) {
      writer.writeInt32(2, msg.playerId);
    }
    if (msg.sessionId) {
      writer.writeInt32(3, msg.sessionId);
    }
    if (msg.tableIndex) {
      writer.writeInt32(4, msg.tableIndex);
    }
    if (msg.rating) {
      writer.writeFloat(5, msg.rating);
    }
    if (msg.playerTitle) {
      writer.writeString(6, msg.playerTitle);
    }
    if (msg.hasAvatar) {
      writer.writeBool(7, msg.hasAvatar);
    }
    if (msg.lastUpdate) {
      writer.writeString(8, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerSeating,
    reader: protoscript.BinaryReader,
  ): PlayerSeating {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.order = reader.readInt32();
          break;
        }
        case 2: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 3: {
          msg.sessionId = reader.readInt32();
          break;
        }
        case 4: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 5: {
          msg.rating = reader.readFloat();
          break;
        }
        case 6: {
          msg.playerTitle = reader.readString();
          break;
        }
        case 7: {
          msg.hasAvatar = reader.readBool();
          break;
        }
        case 8: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayerSeatingSwiss = {
  /**
   * Serializes PlayerSeatingSwiss to protobuf.
   */
  encode: function (msg: PartialDeep<PlayerSeatingSwiss>): Uint8Array {
    return PlayerSeatingSwiss._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayerSeatingSwiss from protobuf.
   */
  decode: function (bytes: ByteSource): PlayerSeatingSwiss {
    return PlayerSeatingSwiss._readMessage(
      PlayerSeatingSwiss.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayerSeatingSwiss with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerSeatingSwiss>): PlayerSeatingSwiss {
    return {
      playerId: 0,
      rating: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerSeatingSwiss>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.rating) {
      writer.writeFloat(2, msg.rating);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerSeatingSwiss,
    reader: protoscript.BinaryReader,
  ): PlayerSeatingSwiss {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.rating = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TableItemSwiss = {
  /**
   * Serializes TableItemSwiss to protobuf.
   */
  encode: function (msg: PartialDeep<TableItemSwiss>): Uint8Array {
    return TableItemSwiss._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TableItemSwiss from protobuf.
   */
  decode: function (bytes: ByteSource): TableItemSwiss {
    return TableItemSwiss._readMessage(
      TableItemSwiss.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TableItemSwiss with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TableItemSwiss>): TableItemSwiss {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TableItemSwiss>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.players as any,
        PlayerSeatingSwiss._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TableItemSwiss,
    reader: protoscript.BinaryReader,
  ): TableItemSwiss {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = PlayerSeatingSwiss.initialize();
          reader.readMessage(m, PlayerSeatingSwiss._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PrescriptedTable = {
  /**
   * Serializes PrescriptedTable to protobuf.
   */
  encode: function (msg: PartialDeep<PrescriptedTable>): Uint8Array {
    return PrescriptedTable._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PrescriptedTable from protobuf.
   */
  decode: function (bytes: ByteSource): PrescriptedTable {
    return PrescriptedTable._readMessage(
      PrescriptedTable.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PrescriptedTable with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PrescriptedTable>): PrescriptedTable {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PrescriptedTable>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.players as any,
        RegisteredPlayer._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PrescriptedTable,
    reader: protoscript.BinaryReader,
  ): PrescriptedTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = RegisteredPlayer.initialize();
          reader.readMessage(m, RegisteredPlayer._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Chombo = {
  /**
   * Serializes Chombo to protobuf.
   */
  encode: function (msg: PartialDeep<Chombo>): Uint8Array {
    return Chombo._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Chombo from protobuf.
   */
  decode: function (bytes: ByteSource): Chombo {
    return Chombo._readMessage(
      Chombo.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Chombo with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Chombo>): Chombo {
    return {
      playerId: 0,
      amount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Chombo>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.amount) {
      writer.writeFloat(2, msg.amount);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Chombo,
    reader: protoscript.BinaryReader,
  ): Chombo {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.amount = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SessionState = {
  /**
   * Serializes SessionState to protobuf.
   */
  encode: function (msg: PartialDeep<SessionState>): Uint8Array {
    return SessionState._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SessionState from protobuf.
   */
  decode: function (bytes: ByteSource): SessionState {
    return SessionState._readMessage(
      SessionState.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SessionState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SessionState>): SessionState {
    return {
      dealer: 0,
      roundIndex: 0,
      riichiCount: 0,
      honbaCount: 0,
      scores: [],
      finished: false,
      lastHandStarted: false,
      chombo: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionState>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.dealer) {
      writer.writeInt32(1, msg.dealer);
    }
    if (msg.roundIndex) {
      writer.writeInt32(2, msg.roundIndex);
    }
    if (msg.riichiCount) {
      writer.writeInt32(3, msg.riichiCount);
    }
    if (msg.honbaCount) {
      writer.writeInt32(4, msg.honbaCount);
    }
    if (msg.scores?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.scores as any,
        IntermediateResultOfSession._writeMessage,
      );
    }
    if (msg.finished) {
      writer.writeBool(6, msg.finished);
    }
    if (msg.lastHandStarted) {
      writer.writeBool(8, msg.lastHandStarted);
    }
    if (msg.chombo?.length) {
      writer.writeRepeatedMessage(9, msg.chombo as any, Chombo._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SessionState,
    reader: protoscript.BinaryReader,
  ): SessionState {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.dealer = reader.readInt32();
          break;
        }
        case 2: {
          msg.roundIndex = reader.readInt32();
          break;
        }
        case 3: {
          msg.riichiCount = reader.readInt32();
          break;
        }
        case 4: {
          msg.honbaCount = reader.readInt32();
          break;
        }
        case 5: {
          const m = IntermediateResultOfSession.initialize();
          reader.readMessage(m, IntermediateResultOfSession._readMessage);
          msg.scores.push(m);
          break;
        }
        case 6: {
          msg.finished = reader.readBool();
          break;
        }
        case 8: {
          msg.lastHandStarted = reader.readBool();
          break;
        }
        case 9: {
          const m = Chombo.initialize();
          reader.readMessage(m, Chombo._readMessage);
          msg.chombo.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uma = {
  /**
   * Serializes Uma to protobuf.
   */
  encode: function (msg: PartialDeep<Uma>): Uint8Array {
    return Uma._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Uma from protobuf.
   */
  decode: function (bytes: ByteSource): Uma {
    return Uma._readMessage(
      Uma.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Uma with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Uma>): Uma {
    return {
      place1: 0,
      place2: 0,
      place3: 0,
      place4: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Uma>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.place1) {
      writer.writeInt32(1, msg.place1);
    }
    if (msg.place2) {
      writer.writeInt32(2, msg.place2);
    }
    if (msg.place3) {
      writer.writeInt32(3, msg.place3);
    }
    if (msg.place4) {
      writer.writeInt32(4, msg.place4);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uma, reader: protoscript.BinaryReader): Uma {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.place1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.place2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.place3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.place4 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ComplexUma = {
  /**
   * Serializes ComplexUma to protobuf.
   */
  encode: function (msg: PartialDeep<ComplexUma>): Uint8Array {
    return ComplexUma._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ComplexUma from protobuf.
   */
  decode: function (bytes: ByteSource): ComplexUma {
    return ComplexUma._readMessage(
      ComplexUma.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ComplexUma with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ComplexUma>): ComplexUma {
    return {
      neg1: Uma.initialize(),
      neg3: Uma.initialize(),
      otherwise: Uma.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ComplexUma>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.neg1) {
      writer.writeMessage(1, msg.neg1, Uma._writeMessage);
    }
    if (msg.neg3) {
      writer.writeMessage(2, msg.neg3, Uma._writeMessage);
    }
    if (msg.otherwise) {
      writer.writeMessage(3, msg.otherwise, Uma._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ComplexUma,
    reader: protoscript.BinaryReader,
  ): ComplexUma {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.neg1, Uma._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.neg3, Uma._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.otherwise, Uma._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RulesetConfig = {
  /**
   * Serializes RulesetConfig to protobuf.
   */
  encode: function (msg: PartialDeep<RulesetConfig>): Uint8Array {
    return RulesetConfig._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RulesetConfig from protobuf.
   */
  decode: function (bytes: ByteSource): RulesetConfig {
    return RulesetConfig._readMessage(
      RulesetConfig.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes RulesetConfig with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RulesetConfig>): RulesetConfig {
    return {
      complexUma: ComplexUma.initialize(),
      endingPolicy: EndingPolicy._fromInt(0),
      uma: Uma.initialize(),
      umaType: UmaType._fromInt(0),
      doubleronHonbaAtamahane: false,
      doubleronRiichiAtamahane: false,
      equalizeUma: false,
      extraChomboPayments: false,
      playAdditionalRounds: false,
      riichiGoesToWinner: false,
      tonpuusen: false,
      withAbortives: false,
      withAtamahane: false,
      withButtobi: false,
      withKazoe: false,
      withKiriageMangan: false,
      withKuitan: false,
      withLeadingDealerGameOver: false,
      withMultiYakumans: false,
      withNagashiMangan: false,
      withWinningDealerHonbaSkipped: false,
      chipsValue: 0,
      chomboAmount: 0,
      gameExpirationTime: 0,
      goalPoints: 0,
      maxPenalty: 0,
      minPenalty: 0,
      oka: 0,
      penaltyStep: 0,
      replacementPlayerFixedPoints: 0,
      replacementPlayerOverrideUma: 0,
      startPoints: 0,
      startRating: 0,
      allowedYaku: [],
      yakuWithPao: [],
      withYakitori: false,
      yakitoriPenalty: 0,
      chomboEndsGame: false,
      honbaValue: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RulesetConfig>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.complexUma) {
      writer.writeMessage(1, msg.complexUma, ComplexUma._writeMessage);
    }
    if (msg.endingPolicy && EndingPolicy._toInt(msg.endingPolicy)) {
      writer.writeEnum(2, EndingPolicy._toInt(msg.endingPolicy));
    }
    if (msg.uma) {
      writer.writeMessage(3, msg.uma, Uma._writeMessage);
    }
    if (msg.umaType && UmaType._toInt(msg.umaType)) {
      writer.writeEnum(4, UmaType._toInt(msg.umaType));
    }
    if (msg.doubleronHonbaAtamahane) {
      writer.writeBool(5, msg.doubleronHonbaAtamahane);
    }
    if (msg.doubleronRiichiAtamahane) {
      writer.writeBool(6, msg.doubleronRiichiAtamahane);
    }
    if (msg.equalizeUma) {
      writer.writeBool(7, msg.equalizeUma);
    }
    if (msg.extraChomboPayments) {
      writer.writeBool(8, msg.extraChomboPayments);
    }
    if (msg.playAdditionalRounds) {
      writer.writeBool(9, msg.playAdditionalRounds);
    }
    if (msg.riichiGoesToWinner) {
      writer.writeBool(10, msg.riichiGoesToWinner);
    }
    if (msg.tonpuusen) {
      writer.writeBool(11, msg.tonpuusen);
    }
    if (msg.withAbortives) {
      writer.writeBool(12, msg.withAbortives);
    }
    if (msg.withAtamahane) {
      writer.writeBool(13, msg.withAtamahane);
    }
    if (msg.withButtobi) {
      writer.writeBool(14, msg.withButtobi);
    }
    if (msg.withKazoe) {
      writer.writeBool(15, msg.withKazoe);
    }
    if (msg.withKiriageMangan) {
      writer.writeBool(16, msg.withKiriageMangan);
    }
    if (msg.withKuitan) {
      writer.writeBool(17, msg.withKuitan);
    }
    if (msg.withLeadingDealerGameOver) {
      writer.writeBool(18, msg.withLeadingDealerGameOver);
    }
    if (msg.withMultiYakumans) {
      writer.writeBool(19, msg.withMultiYakumans);
    }
    if (msg.withNagashiMangan) {
      writer.writeBool(20, msg.withNagashiMangan);
    }
    if (msg.withWinningDealerHonbaSkipped) {
      writer.writeBool(21, msg.withWinningDealerHonbaSkipped);
    }
    if (msg.chipsValue) {
      writer.writeInt32(22, msg.chipsValue);
    }
    if (msg.chomboAmount) {
      writer.writeInt32(23, msg.chomboAmount);
    }
    if (msg.gameExpirationTime) {
      writer.writeInt32(24, msg.gameExpirationTime);
    }
    if (msg.goalPoints) {
      writer.writeInt32(25, msg.goalPoints);
    }
    if (msg.maxPenalty) {
      writer.writeInt32(26, msg.maxPenalty);
    }
    if (msg.minPenalty) {
      writer.writeInt32(27, msg.minPenalty);
    }
    if (msg.oka) {
      writer.writeInt32(28, msg.oka);
    }
    if (msg.penaltyStep) {
      writer.writeInt32(29, msg.penaltyStep);
    }
    if (msg.replacementPlayerFixedPoints) {
      writer.writeInt32(30, msg.replacementPlayerFixedPoints);
    }
    if (msg.replacementPlayerOverrideUma) {
      writer.writeInt32(31, msg.replacementPlayerOverrideUma);
    }
    if (msg.startPoints) {
      writer.writeInt32(32, msg.startPoints);
    }
    if (msg.startRating) {
      writer.writeInt32(33, msg.startRating);
    }
    if (msg.allowedYaku?.length) {
      writer.writePackedInt32(34, msg.allowedYaku);
    }
    if (msg.yakuWithPao?.length) {
      writer.writePackedInt32(35, msg.yakuWithPao);
    }
    if (msg.withYakitori) {
      writer.writeBool(36, msg.withYakitori);
    }
    if (msg.yakitoriPenalty) {
      writer.writeInt32(37, msg.yakitoriPenalty);
    }
    if (msg.chomboEndsGame) {
      writer.writeBool(38, msg.chomboEndsGame);
    }
    if (msg.honbaValue) {
      writer.writeInt32(39, msg.honbaValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RulesetConfig,
    reader: protoscript.BinaryReader,
  ): RulesetConfig {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.complexUma, ComplexUma._readMessage);
          break;
        }
        case 2: {
          msg.endingPolicy = EndingPolicy._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          reader.readMessage(msg.uma, Uma._readMessage);
          break;
        }
        case 4: {
          msg.umaType = UmaType._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.doubleronHonbaAtamahane = reader.readBool();
          break;
        }
        case 6: {
          msg.doubleronRiichiAtamahane = reader.readBool();
          break;
        }
        case 7: {
          msg.equalizeUma = reader.readBool();
          break;
        }
        case 8: {
          msg.extraChomboPayments = reader.readBool();
          break;
        }
        case 9: {
          msg.playAdditionalRounds = reader.readBool();
          break;
        }
        case 10: {
          msg.riichiGoesToWinner = reader.readBool();
          break;
        }
        case 11: {
          msg.tonpuusen = reader.readBool();
          break;
        }
        case 12: {
          msg.withAbortives = reader.readBool();
          break;
        }
        case 13: {
          msg.withAtamahane = reader.readBool();
          break;
        }
        case 14: {
          msg.withButtobi = reader.readBool();
          break;
        }
        case 15: {
          msg.withKazoe = reader.readBool();
          break;
        }
        case 16: {
          msg.withKiriageMangan = reader.readBool();
          break;
        }
        case 17: {
          msg.withKuitan = reader.readBool();
          break;
        }
        case 18: {
          msg.withLeadingDealerGameOver = reader.readBool();
          break;
        }
        case 19: {
          msg.withMultiYakumans = reader.readBool();
          break;
        }
        case 20: {
          msg.withNagashiMangan = reader.readBool();
          break;
        }
        case 21: {
          msg.withWinningDealerHonbaSkipped = reader.readBool();
          break;
        }
        case 22: {
          msg.chipsValue = reader.readInt32();
          break;
        }
        case 23: {
          msg.chomboAmount = reader.readInt32();
          break;
        }
        case 24: {
          msg.gameExpirationTime = reader.readInt32();
          break;
        }
        case 25: {
          msg.goalPoints = reader.readInt32();
          break;
        }
        case 26: {
          msg.maxPenalty = reader.readInt32();
          break;
        }
        case 27: {
          msg.minPenalty = reader.readInt32();
          break;
        }
        case 28: {
          msg.oka = reader.readInt32();
          break;
        }
        case 29: {
          msg.penaltyStep = reader.readInt32();
          break;
        }
        case 30: {
          msg.replacementPlayerFixedPoints = reader.readInt32();
          break;
        }
        case 31: {
          msg.replacementPlayerOverrideUma = reader.readInt32();
          break;
        }
        case 32: {
          msg.startPoints = reader.readInt32();
          break;
        }
        case 33: {
          msg.startRating = reader.readInt32();
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.allowedYaku.push(...reader.readPackedInt32());
          } else {
            msg.allowedYaku.push(reader.readInt32());
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.yakuWithPao.push(...reader.readPackedInt32());
          } else {
            msg.yakuWithPao.push(reader.readInt32());
          }
          break;
        }
        case 36: {
          msg.withYakitori = reader.readBool();
          break;
        }
        case 37: {
          msg.yakitoriPenalty = reader.readInt32();
          break;
        }
        case 38: {
          msg.chomboEndsGame = reader.readBool();
          break;
        }
        case 39: {
          msg.honbaValue = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GenericSuccessResponse = {
  /**
   * Serializes GenericSuccessResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GenericSuccessResponse>): Uint8Array {
    return GenericSuccessResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GenericSuccessResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GenericSuccessResponse {
    return GenericSuccessResponse._readMessage(
      GenericSuccessResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GenericSuccessResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericSuccessResponse>,
  ): GenericSuccessResponse {
    return {
      success: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericSuccessResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.success) {
      writer.writeBool(1, msg.success);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericSuccessResponse,
    reader: protoscript.BinaryReader,
  ): GenericSuccessResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.success = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GenericEventPayload = {
  /**
   * Serializes GenericEventPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GenericEventPayload>): Uint8Array {
    return GenericEventPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GenericEventPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GenericEventPayload {
    return GenericEventPayload._readMessage(
      GenericEventPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GenericEventPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericEventPayload>,
  ): GenericEventPayload {
    return {
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericEventPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericEventPayload,
    reader: protoscript.BinaryReader,
  ): GenericEventPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GenericSessionPayload = {
  /**
   * Serializes GenericSessionPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GenericSessionPayload>): Uint8Array {
    return GenericSessionPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GenericSessionPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GenericSessionPayload {
    return GenericSessionPayload._readMessage(
      GenericSessionPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GenericSessionPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericSessionPayload>,
  ): GenericSessionPayload {
    return {
      sessionHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericSessionPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericSessionPayload,
    reader: protoscript.BinaryReader,
  ): GenericSessionPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const EventTypeJSON = {
  EVENT_TYPE_UNSPECIFIED: "EVENT_TYPE_UNSPECIFIED",
  EVENT_TYPE_TOURNAMENT: "EVENT_TYPE_TOURNAMENT",
  EVENT_TYPE_LOCAL: "EVENT_TYPE_LOCAL",
  EVENT_TYPE_ONLINE: "EVENT_TYPE_ONLINE",
  /**
   * @private
   */
  _fromInt: function (i: number): EventType {
    switch (i) {
      case 0: {
        return "EVENT_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "EVENT_TYPE_TOURNAMENT";
      }
      case 2: {
        return "EVENT_TYPE_LOCAL";
      }
      case 3: {
        return "EVENT_TYPE_ONLINE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as EventType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: EventType): number {
    switch (i) {
      case "EVENT_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "EVENT_TYPE_TOURNAMENT": {
        return 1;
      }
      case "EVENT_TYPE_LOCAL": {
        return 2;
      }
      case "EVENT_TYPE_ONLINE": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TournamentGamesStatusJSON = {
  TOURNAMENT_GAMES_STATUS_UNSPECIFIED: "TOURNAMENT_GAMES_STATUS_UNSPECIFIED",
  TOURNAMENT_GAMES_STATUS_SEATING_READY:
    "TOURNAMENT_GAMES_STATUS_SEATING_READY",
  TOURNAMENT_GAMES_STATUS_STARTED: "TOURNAMENT_GAMES_STATUS_STARTED",
  /**
   * @private
   */
  _fromInt: function (i: number): TournamentGamesStatus {
    switch (i) {
      case 0: {
        return "TOURNAMENT_GAMES_STATUS_UNSPECIFIED";
      }
      case 1: {
        return "TOURNAMENT_GAMES_STATUS_SEATING_READY";
      }
      case 2: {
        return "TOURNAMENT_GAMES_STATUS_STARTED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TournamentGamesStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TournamentGamesStatus): number {
    switch (i) {
      case "TOURNAMENT_GAMES_STATUS_UNSPECIFIED": {
        return 0;
      }
      case "TOURNAMENT_GAMES_STATUS_SEATING_READY": {
        return 1;
      }
      case "TOURNAMENT_GAMES_STATUS_STARTED": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const RoundOutcomeJSON = {
  ROUND_OUTCOME_UNSPECIFIED: "ROUND_OUTCOME_UNSPECIFIED",
  ROUND_OUTCOME_RON: "ROUND_OUTCOME_RON",
  ROUND_OUTCOME_TSUMO: "ROUND_OUTCOME_TSUMO",
  ROUND_OUTCOME_DRAW: "ROUND_OUTCOME_DRAW",
  ROUND_OUTCOME_ABORT: "ROUND_OUTCOME_ABORT",
  ROUND_OUTCOME_CHOMBO: "ROUND_OUTCOME_CHOMBO",
  ROUND_OUTCOME_NAGASHI: "ROUND_OUTCOME_NAGASHI",
  ROUND_OUTCOME_MULTIRON: "ROUND_OUTCOME_MULTIRON",
  /**
   * @private
   */
  _fromInt: function (i: number): RoundOutcome {
    switch (i) {
      case 0: {
        return "ROUND_OUTCOME_UNSPECIFIED";
      }
      case 1: {
        return "ROUND_OUTCOME_RON";
      }
      case 2: {
        return "ROUND_OUTCOME_TSUMO";
      }
      case 3: {
        return "ROUND_OUTCOME_DRAW";
      }
      case 4: {
        return "ROUND_OUTCOME_ABORT";
      }
      case 5: {
        return "ROUND_OUTCOME_CHOMBO";
      }
      case 6: {
        return "ROUND_OUTCOME_NAGASHI";
      }
      case 7: {
        return "ROUND_OUTCOME_MULTIRON";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as RoundOutcome;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: RoundOutcome): number {
    switch (i) {
      case "ROUND_OUTCOME_UNSPECIFIED": {
        return 0;
      }
      case "ROUND_OUTCOME_RON": {
        return 1;
      }
      case "ROUND_OUTCOME_TSUMO": {
        return 2;
      }
      case "ROUND_OUTCOME_DRAW": {
        return 3;
      }
      case "ROUND_OUTCOME_ABORT": {
        return 4;
      }
      case "ROUND_OUTCOME_CHOMBO": {
        return 5;
      }
      case "ROUND_OUTCOME_NAGASHI": {
        return 6;
      }
      case "ROUND_OUTCOME_MULTIRON": {
        return 7;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SessionStatusJSON = {
  SESSION_STATUS_UNSPECIFIED: "SESSION_STATUS_UNSPECIFIED",
  SESSION_STATUS_INPROGRESS: "SESSION_STATUS_INPROGRESS",
  SESSION_STATUS_PREFINISHED: "SESSION_STATUS_PREFINISHED",
  SESSION_STATUS_FINISHED: "SESSION_STATUS_FINISHED",
  SESSION_STATUS_CANCELLED: "SESSION_STATUS_CANCELLED",
  SESSION_STATUS_PLANNED: "SESSION_STATUS_PLANNED",
  /**
   * @private
   */
  _fromInt: function (i: number): SessionStatus {
    switch (i) {
      case 0: {
        return "SESSION_STATUS_UNSPECIFIED";
      }
      case 1: {
        return "SESSION_STATUS_INPROGRESS";
      }
      case 2: {
        return "SESSION_STATUS_PREFINISHED";
      }
      case 3: {
        return "SESSION_STATUS_FINISHED";
      }
      case 4: {
        return "SESSION_STATUS_CANCELLED";
      }
      case 5: {
        return "SESSION_STATUS_PLANNED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SessionStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SessionStatus): number {
    switch (i) {
      case "SESSION_STATUS_UNSPECIFIED": {
        return 0;
      }
      case "SESSION_STATUS_INPROGRESS": {
        return 1;
      }
      case "SESSION_STATUS_PREFINISHED": {
        return 2;
      }
      case "SESSION_STATUS_FINISHED": {
        return 3;
      }
      case "SESSION_STATUS_CANCELLED": {
        return 4;
      }
      case "SESSION_STATUS_PLANNED": {
        return 5;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const UmaTypeJSON = {
  UMA_TYPE_UNSPECIFIED: "UMA_TYPE_UNSPECIFIED",
  UMA_TYPE_UMA_SIMPLE: "UMA_TYPE_UMA_SIMPLE",
  UMA_TYPE_UMA_COMPLEX: "UMA_TYPE_UMA_COMPLEX",
  /**
   * @private
   */
  _fromInt: function (i: number): UmaType {
    switch (i) {
      case 0: {
        return "UMA_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "UMA_TYPE_UMA_SIMPLE";
      }
      case 2: {
        return "UMA_TYPE_UMA_COMPLEX";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as UmaType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: UmaType): number {
    switch (i) {
      case "UMA_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "UMA_TYPE_UMA_SIMPLE": {
        return 1;
      }
      case "UMA_TYPE_UMA_COMPLEX": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const EndingPolicyJSON = {
  ENDING_POLICY_EP_UNSPECIFIED: "ENDING_POLICY_EP_UNSPECIFIED",
  ENDING_POLICY_EP_ONE_MORE_HAND: "ENDING_POLICY_EP_ONE_MORE_HAND",
  ENDING_POLICY_EP_END_AFTER_HAND: "ENDING_POLICY_EP_END_AFTER_HAND",
  /**
   * @private
   */
  _fromInt: function (i: number): EndingPolicy {
    switch (i) {
      case 0: {
        return "ENDING_POLICY_EP_UNSPECIFIED";
      }
      case 1: {
        return "ENDING_POLICY_EP_ONE_MORE_HAND";
      }
      case 2: {
        return "ENDING_POLICY_EP_END_AFTER_HAND";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as EndingPolicy;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: EndingPolicy): number {
    switch (i) {
      case "ENDING_POLICY_EP_UNSPECIFIED": {
        return 0;
      }
      case "ENDING_POLICY_EP_ONE_MORE_HAND": {
        return 1;
      }
      case "ENDING_POLICY_EP_END_AFTER_HAND": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PlatformTypeJSON = {
  PLATFORM_TYPE_UNSPECIFIED: "PLATFORM_TYPE_UNSPECIFIED",
  PLATFORM_TYPE_TENHOUNET: "PLATFORM_TYPE_TENHOUNET",
  PLATFORM_TYPE_MAHJONGSOUL: "PLATFORM_TYPE_MAHJONGSOUL",
  /**
   * @private
   */
  _fromInt: function (i: number): PlatformType {
    switch (i) {
      case 0: {
        return "PLATFORM_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "PLATFORM_TYPE_TENHOUNET";
      }
      case 2: {
        return "PLATFORM_TYPE_MAHJONGSOUL";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as PlatformType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: PlatformType): number {
    switch (i) {
      case "PLATFORM_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "PLATFORM_TYPE_TENHOUNET": {
        return 1;
      }
      case "PLATFORM_TYPE_MAHJONGSOUL": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const AccessRulesJSON = {
  /**
   * Serializes AccessRules to JSON.
   */
  encode: function (msg: PartialDeep<AccessRules>): string {
    return JSON.stringify(AccessRulesJSON._writeMessage(msg));
  },

  /**
   * Deserializes AccessRules from JSON.
   */
  decode: function (json: string): AccessRules {
    return AccessRulesJSON._readMessage(
      AccessRulesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes AccessRules with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AccessRules>): AccessRules {
    return {
      rules: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AccessRules>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rules) {
      const _rules_ = Object.fromEntries(
        Object.entries(msg.rules)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(AccessRulesJSON.Rules._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_rules_).length > 0) {
        json["rules"] = _rules_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: AccessRules, json: any): AccessRules {
    const _rules_ = json["rules"];
    if (_rules_) {
      msg.rules = Object.fromEntries(
        Object.entries(_rules_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(AccessRulesJSON.Rules._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Rules: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<AccessRules.Rules>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = RuleValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: AccessRules.Rules,
      json: any,
    ): AccessRules.Rules {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        RuleValueJSON._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },
};

export const RuleValueJSON = {
  /**
   * Serializes RuleValue to JSON.
   */
  encode: function (msg: PartialDeep<RuleValue>): string {
    return JSON.stringify(RuleValueJSON._writeMessage(msg));
  },

  /**
   * Deserializes RuleValue from JSON.
   */
  decode: function (json: string): RuleValue {
    return RuleValueJSON._readMessage(
      RuleValueJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RuleValue with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleValue>): RuleValue {
    return {
      numberValue: undefined,
      stringValue: undefined,
      boolValue: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleValue>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.numberValue != undefined) {
      json["numberValue"] = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json["stringValue"] = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json["boolValue"] = msg.boolValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RuleValue, json: any): RuleValue {
    const _numberValue_ = json["numberValue"] ?? json["number_value"];
    if (_numberValue_) {
      msg.numberValue = protoscript.parseNumber(_numberValue_);
    }
    const _stringValue_ = json["stringValue"] ?? json["string_value"];
    if (_stringValue_) {
      msg.stringValue = _stringValue_;
    }
    const _boolValue_ = json["boolValue"] ?? json["bool_value"];
    if (_boolValue_) {
      msg.boolValue = _boolValue_;
    }
    return msg;
  },
};

export const EventAdminJSON = {
  /**
   * Serializes EventAdmin to JSON.
   */
  encode: function (msg: PartialDeep<EventAdmin>): string {
    return JSON.stringify(EventAdminJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventAdmin from JSON.
   */
  decode: function (json: string): EventAdmin {
    return EventAdminJSON._readMessage(
      EventAdminJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventAdmin with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventAdmin>): EventAdmin {
    return {
      ruleId: 0,
      personId: 0,
      personName: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventAdmin>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ruleId) {
      json["ruleId"] = msg.ruleId;
    }
    if (msg.personId) {
      json["personId"] = msg.personId;
    }
    if (msg.personName) {
      json["personName"] = msg.personName;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EventAdmin, json: any): EventAdmin {
    const _ruleId_ = json["ruleId"] ?? json["rule_id"];
    if (_ruleId_) {
      msg.ruleId = protoscript.parseNumber(_ruleId_);
    }
    const _personId_ = json["personId"] ?? json["person_id"];
    if (_personId_) {
      msg.personId = protoscript.parseNumber(_personId_);
    }
    const _personName_ = json["personName"] ?? json["person_name"];
    if (_personName_) {
      msg.personName = _personName_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const EventRefereeJSON = {
  /**
   * Serializes EventReferee to JSON.
   */
  encode: function (msg: PartialDeep<EventReferee>): string {
    return JSON.stringify(EventRefereeJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventReferee from JSON.
   */
  decode: function (json: string): EventReferee {
    return EventRefereeJSON._readMessage(
      EventRefereeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventReferee with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventReferee>): EventReferee {
    return {
      ruleId: 0,
      personId: 0,
      personName: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventReferee>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ruleId) {
      json["ruleId"] = msg.ruleId;
    }
    if (msg.personId) {
      json["personId"] = msg.personId;
    }
    if (msg.personName) {
      json["personName"] = msg.personName;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EventReferee, json: any): EventReferee {
    const _ruleId_ = json["ruleId"] ?? json["rule_id"];
    if (_ruleId_) {
      msg.ruleId = protoscript.parseNumber(_ruleId_);
    }
    const _personId_ = json["personId"] ?? json["person_id"];
    if (_personId_) {
      msg.personId = protoscript.parseNumber(_personId_);
    }
    const _personName_ = json["personName"] ?? json["person_name"];
    if (_personName_) {
      msg.personName = _personName_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const RuleListItemJSON = {
  /**
   * Serializes RuleListItem to JSON.
   */
  encode: function (msg: PartialDeep<RuleListItem>): string {
    return JSON.stringify(RuleListItemJSON._writeMessage(msg));
  },

  /**
   * Deserializes RuleListItem from JSON.
   */
  decode: function (json: string): RuleListItem {
    return RuleListItemJSON._readMessage(
      RuleListItemJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RuleListItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItem>): RuleListItem {
    return {
      default: "",
      type: "",
      title: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItem>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.default) {
      json["default"] = msg.default;
    }
    if (msg.type) {
      json["type"] = msg.type;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RuleListItem, json: any): RuleListItem {
    const _default_ = json["default"];
    if (_default_) {
      msg.default = _default_;
    }
    const _type_ = json["type"];
    if (_type_) {
      msg.type = _type_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    return msg;
  },
};

export const EventRuleListItemJSON = {
  /**
   * Serializes EventRuleListItem to JSON.
   */
  encode: function (msg: PartialDeep<EventRuleListItem>): string {
    return JSON.stringify(EventRuleListItemJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventRuleListItem from JSON.
   */
  decode: function (json: string): EventRuleListItem {
    return EventRuleListItemJSON._readMessage(
      EventRuleListItemJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventRuleListItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventRuleListItem>): EventRuleListItem {
    return {
      isGlobal: false,
      id: 0,
      value: RuleValueJSON.initialize(),
      name: "",
      ownerTitle: "",
      allowedValues: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventRuleListItem>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.isGlobal) {
      json["isGlobal"] = msg.isGlobal;
    }
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.value) {
      const _value_ = RuleValueJSON._writeMessage(msg.value);
      if (Object.keys(_value_).length > 0) {
        json["value"] = _value_;
      }
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.ownerTitle) {
      json["ownerTitle"] = msg.ownerTitle;
    }
    if (msg.allowedValues?.length) {
      json["allowedValues"] = msg.allowedValues;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventRuleListItem,
    json: any,
  ): EventRuleListItem {
    const _isGlobal_ = json["isGlobal"] ?? json["is_global"];
    if (_isGlobal_) {
      msg.isGlobal = _isGlobal_;
    }
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _value_ = json["value"];
    if (_value_) {
      RuleValueJSON._readMessage(msg.value, _value_);
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _ownerTitle_ = json["ownerTitle"] ?? json["owner_title"];
    if (_ownerTitle_) {
      msg.ownerTitle = _ownerTitle_;
    }
    const _allowedValues_ = json["allowedValues"] ?? json["allowed_values"];
    if (_allowedValues_) {
      msg.allowedValues = _allowedValues_;
    }
    return msg;
  },
};

export const RuleListItemExJSON = {
  /**
   * Serializes RuleListItemEx to JSON.
   */
  encode: function (msg: PartialDeep<RuleListItemEx>): string {
    return JSON.stringify(RuleListItemExJSON._writeMessage(msg));
  },

  /**
   * Deserializes RuleListItemEx from JSON.
   */
  decode: function (json: string): RuleListItemEx {
    return RuleListItemExJSON._readMessage(
      RuleListItemExJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RuleListItemEx with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItemEx>): RuleListItemEx {
    return {
      id: 0,
      type: "",
      value: RuleValueJSON.initialize(),
      allowedValues: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItemEx>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.type) {
      json["type"] = msg.type;
    }
    if (msg.value) {
      const _value_ = RuleValueJSON._writeMessage(msg.value);
      if (Object.keys(_value_).length > 0) {
        json["value"] = _value_;
      }
    }
    if (msg.allowedValues?.length) {
      json["allowedValues"] = msg.allowedValues;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RuleListItemEx, json: any): RuleListItemEx {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _type_ = json["type"];
    if (_type_) {
      msg.type = _type_;
    }
    const _value_ = json["value"];
    if (_value_) {
      RuleValueJSON._readMessage(msg.value, _value_);
    }
    const _allowedValues_ = json["allowedValues"] ?? json["allowed_values"];
    if (_allowedValues_) {
      msg.allowedValues = _allowedValues_;
    }
    return msg;
  },
};

export const RuleListItemExMapJSON = {
  /**
   * Serializes RuleListItemExMap to JSON.
   */
  encode: function (msg: PartialDeep<RuleListItemExMap>): string {
    return JSON.stringify(RuleListItemExMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes RuleListItemExMap from JSON.
   */
  decode: function (json: string): RuleListItemExMap {
    return RuleListItemExMapJSON._readMessage(
      RuleListItemExMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RuleListItemExMap with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RuleListItemExMap>): RuleListItemExMap {
    return {
      rules: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RuleListItemExMap>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rules) {
      const _rules_ = Object.fromEntries(
        Object.entries(msg.rules)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(RuleListItemExMapJSON.Rules._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_rules_).length > 0) {
        json["rules"] = _rules_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RuleListItemExMap,
    json: any,
  ): RuleListItemExMap {
    const _rules_ = json["rules"];
    if (_rules_) {
      msg.rules = Object.fromEntries(
        Object.entries(_rules_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(RuleListItemExMapJSON.Rules._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Rules: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<RuleListItemExMap.Rules>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = RuleListItemExJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: RuleListItemExMap.Rules,
      json: any,
    ): RuleListItemExMap.Rules {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        RuleListItemExJSON._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },
};

export const PersonJSON = {
  /**
   * Serializes Person to JSON.
   */
  encode: function (msg: PartialDeep<Person>): string {
    return JSON.stringify(PersonJSON._writeMessage(msg));
  },

  /**
   * Deserializes Person from JSON.
   */
  decode: function (json: string): Person {
    return PersonJSON._readMessage(PersonJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Person with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Person>): Person {
    return {
      id: 0,
      city: "",
      tenhouId: "",
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Person>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.city) {
      json["city"] = msg.city;
    }
    if (msg.tenhouId) {
      json["tenhouId"] = msg.tenhouId;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Person, json: any): Person {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _city_ = json["city"];
    if (_city_) {
      msg.city = _city_;
    }
    const _tenhouId_ = json["tenhouId"] ?? json["tenhou_id"];
    if (_tenhouId_) {
      msg.tenhouId = _tenhouId_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const PersonExJSON = {
  /**
   * Serializes PersonEx to JSON.
   */
  encode: function (msg: PartialDeep<PersonEx>): string {
    return JSON.stringify(PersonExJSON._writeMessage(msg));
  },

  /**
   * Deserializes PersonEx from JSON.
   */
  decode: function (json: string): PersonEx {
    return PersonExJSON._readMessage(
      PersonExJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PersonEx with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PersonEx>): PersonEx {
    return {
      id: 0,
      city: "",
      tenhouId: "",
      title: "",
      country: "",
      email: "",
      phone: "",
      groups: [],
      hasAvatar: false,
      lastUpdate: "",
      msNickname: "",
      msAccountId: 0,
      telegramId: "",
      notifications: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PersonEx>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.city) {
      json["city"] = msg.city;
    }
    if (msg.tenhouId) {
      json["tenhouId"] = msg.tenhouId;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.country) {
      json["country"] = msg.country;
    }
    if (msg.email) {
      json["email"] = msg.email;
    }
    if (msg.phone) {
      json["phone"] = msg.phone;
    }
    if (msg.groups?.length) {
      json["groups"] = msg.groups;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    if (msg.msNickname) {
      json["msNickname"] = msg.msNickname;
    }
    if (msg.msAccountId) {
      json["msAccountId"] = msg.msAccountId;
    }
    if (msg.telegramId) {
      json["telegramId"] = msg.telegramId;
    }
    if (msg.notifications) {
      json["notifications"] = msg.notifications;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PersonEx, json: any): PersonEx {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _city_ = json["city"];
    if (_city_) {
      msg.city = _city_;
    }
    const _tenhouId_ = json["tenhouId"] ?? json["tenhou_id"];
    if (_tenhouId_) {
      msg.tenhouId = _tenhouId_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _country_ = json["country"];
    if (_country_) {
      msg.country = _country_;
    }
    const _email_ = json["email"];
    if (_email_) {
      msg.email = _email_;
    }
    const _phone_ = json["phone"];
    if (_phone_) {
      msg.phone = _phone_;
    }
    const _groups_ = json["groups"];
    if (_groups_) {
      msg.groups = _groups_.map(protoscript.parseNumber);
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    const _msNickname_ = json["msNickname"] ?? json["ms_nickname"];
    if (_msNickname_) {
      msg.msNickname = _msNickname_;
    }
    const _msAccountId_ = json["msAccountId"] ?? json["ms_account_id"];
    if (_msAccountId_) {
      msg.msAccountId = protoscript.parseNumber(_msAccountId_);
    }
    const _telegramId_ = json["telegramId"] ?? json["telegram_id"];
    if (_telegramId_) {
      msg.telegramId = _telegramId_;
    }
    const _notifications_ = json["notifications"];
    if (_notifications_) {
      msg.notifications = _notifications_;
    }
    return msg;
  },
};

export const GroupJSON = {
  /**
   * Serializes Group to JSON.
   */
  encode: function (msg: PartialDeep<Group>): string {
    return JSON.stringify(GroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes Group from JSON.
   */
  decode: function (json: string): Group {
    return GroupJSON._readMessage(GroupJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Group with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Group>): Group {
    return {
      id: 0,
      title: "",
      color: "",
      description: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Group>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Group, json: any): Group {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    return msg;
  },
};

export const CountryJSON = {
  /**
   * Serializes Country to JSON.
   */
  encode: function (msg: PartialDeep<Country>): string {
    return JSON.stringify(CountryJSON._writeMessage(msg));
  },

  /**
   * Deserializes Country from JSON.
   */
  decode: function (json: string): Country {
    return CountryJSON._readMessage(CountryJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Country with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Country>): Country {
    return {
      code: "",
      name: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Country>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.code) {
      json["code"] = msg.code;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Country, json: any): Country {
    const _code_ = json["code"];
    if (_code_) {
      msg.code = _code_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};

export const EventJSON = {
  /**
   * Serializes Event to JSON.
   */
  encode: function (msg: PartialDeep<Event>): string {
    return JSON.stringify(EventJSON._writeMessage(msg));
  },

  /**
   * Deserializes Event from JSON.
   */
  decode: function (json: string): Event {
    return EventJSON._readMessage(EventJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Event with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Event>): Event {
    return {
      id: 0,
      title: "",
      description: "",
      finished: false,
      isListed: false,
      isRatingShown: false,
      tournamentStarted: false,
      type: EventType._fromInt(0),
      isPrescripted: false,
      isTeam: false,
      hasSeries: false,
      withChips: false,
      minGamesCount: 0,
      achievementsShown: false,
      withYakitori: false,
      platformId: PlatformType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Event>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.finished) {
      json["finished"] = msg.finished;
    }
    if (msg.isListed) {
      json["isListed"] = msg.isListed;
    }
    if (msg.isRatingShown) {
      json["isRatingShown"] = msg.isRatingShown;
    }
    if (msg.tournamentStarted) {
      json["tournamentStarted"] = msg.tournamentStarted;
    }
    if (msg.type && EventTypeJSON._toInt(msg.type)) {
      json["type"] = msg.type;
    }
    if (msg.isPrescripted) {
      json["isPrescripted"] = msg.isPrescripted;
    }
    if (msg.isTeam) {
      json["isTeam"] = msg.isTeam;
    }
    if (msg.hasSeries) {
      json["hasSeries"] = msg.hasSeries;
    }
    if (msg.withChips) {
      json["withChips"] = msg.withChips;
    }
    if (msg.minGamesCount) {
      json["minGamesCount"] = msg.minGamesCount;
    }
    if (msg.achievementsShown) {
      json["achievementsShown"] = msg.achievementsShown;
    }
    if (msg.withYakitori) {
      json["withYakitori"] = msg.withYakitori;
    }
    if (msg.platformId && PlatformTypeJSON._toInt(msg.platformId)) {
      json["platformId"] = msg.platformId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Event, json: any): Event {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _finished_ = json["finished"];
    if (_finished_) {
      msg.finished = _finished_;
    }
    const _isListed_ = json["isListed"] ?? json["is_listed"];
    if (_isListed_) {
      msg.isListed = _isListed_;
    }
    const _isRatingShown_ = json["isRatingShown"] ?? json["is_rating_shown"];
    if (_isRatingShown_) {
      msg.isRatingShown = _isRatingShown_;
    }
    const _tournamentStarted_ =
      json["tournamentStarted"] ?? json["tournament_started"];
    if (_tournamentStarted_) {
      msg.tournamentStarted = _tournamentStarted_;
    }
    const _type_ = json["type"];
    if (_type_) {
      msg.type = EventType._fromInt(_type_);
    }
    const _isPrescripted_ = json["isPrescripted"] ?? json["is_prescripted"];
    if (_isPrescripted_) {
      msg.isPrescripted = _isPrescripted_;
    }
    const _isTeam_ = json["isTeam"] ?? json["is_team"];
    if (_isTeam_) {
      msg.isTeam = _isTeam_;
    }
    const _hasSeries_ = json["hasSeries"] ?? json["has_series"];
    if (_hasSeries_) {
      msg.hasSeries = _hasSeries_;
    }
    const _withChips_ = json["withChips"] ?? json["with_chips"];
    if (_withChips_) {
      msg.withChips = _withChips_;
    }
    const _minGamesCount_ = json["minGamesCount"] ?? json["min_games_count"];
    if (_minGamesCount_) {
      msg.minGamesCount = protoscript.parseNumber(_minGamesCount_);
    }
    const _achievementsShown_ =
      json["achievementsShown"] ?? json["achievements_shown"];
    if (_achievementsShown_) {
      msg.achievementsShown = _achievementsShown_;
    }
    const _withYakitori_ = json["withYakitori"] ?? json["with_yakitori"];
    if (_withYakitori_) {
      msg.withYakitori = _withYakitori_;
    }
    const _platformId_ = json["platformId"] ?? json["platform_id"];
    if (_platformId_) {
      msg.platformId = PlatformType._fromInt(_platformId_);
    }
    return msg;
  },
};

export const MyEventJSON = {
  /**
   * Serializes MyEvent to JSON.
   */
  encode: function (msg: PartialDeep<MyEvent>): string {
    return JSON.stringify(MyEventJSON._writeMessage(msg));
  },

  /**
   * Deserializes MyEvent from JSON.
   */
  decode: function (json: string): MyEvent {
    return MyEventJSON._readMessage(MyEventJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes MyEvent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MyEvent>): MyEvent {
    return {
      id: 0,
      title: "",
      description: "",
      isOnline: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<MyEvent>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.isOnline) {
      json["isOnline"] = msg.isOnline;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MyEvent, json: any): MyEvent {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _isOnline_ = json["isOnline"] ?? json["is_online"];
    if (_isOnline_) {
      msg.isOnline = _isOnline_;
    }
    return msg;
  },
};

export const GameConfigJSON = {
  /**
   * Serializes GameConfig to JSON.
   */
  encode: function (msg: PartialDeep<GameConfig>): string {
    return JSON.stringify(GameConfigJSON._writeMessage(msg));
  },

  /**
   * Deserializes GameConfig from JSON.
   */
  decode: function (json: string): GameConfig {
    return GameConfigJSON._readMessage(
      GameConfigJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GameConfig with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GameConfig>): GameConfig {
    return {
      rulesetTitle: "",
      eventTitle: "",
      eventDescription: "",
      eventStatHost: "",
      useTimer: false,
      usePenalty: false,
      gameDuration: 0,
      timezone: "",
      isOnline: false,
      isTeam: false,
      autoSeating: false,
      syncStart: false,
      syncEnd: false,
      sortByGames: false,
      allowPlayerAppend: false,
      seriesLength: 0,
      minGamesCount: 0,
      gamesStatus: TournamentGamesStatus._fromInt(0),
      hideResults: false,
      hideAddReplayButton: false,
      isPrescripted: false,
      isFinished: false,
      rulesetConfig: RulesetConfigJSON.initialize(),
      lobbyId: 0,
      allowViewOtherTables: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GameConfig>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rulesetTitle) {
      json["rulesetTitle"] = msg.rulesetTitle;
    }
    if (msg.eventTitle) {
      json["eventTitle"] = msg.eventTitle;
    }
    if (msg.eventDescription) {
      json["eventDescription"] = msg.eventDescription;
    }
    if (msg.eventStatHost) {
      json["eventStatHost"] = msg.eventStatHost;
    }
    if (msg.useTimer) {
      json["useTimer"] = msg.useTimer;
    }
    if (msg.usePenalty) {
      json["usePenalty"] = msg.usePenalty;
    }
    if (msg.gameDuration) {
      json["gameDuration"] = msg.gameDuration;
    }
    if (msg.timezone) {
      json["timezone"] = msg.timezone;
    }
    if (msg.isOnline) {
      json["isOnline"] = msg.isOnline;
    }
    if (msg.isTeam) {
      json["isTeam"] = msg.isTeam;
    }
    if (msg.autoSeating) {
      json["autoSeating"] = msg.autoSeating;
    }
    if (msg.syncStart) {
      json["syncStart"] = msg.syncStart;
    }
    if (msg.syncEnd) {
      json["syncEnd"] = msg.syncEnd;
    }
    if (msg.sortByGames) {
      json["sortByGames"] = msg.sortByGames;
    }
    if (msg.allowPlayerAppend) {
      json["allowPlayerAppend"] = msg.allowPlayerAppend;
    }
    if (msg.seriesLength) {
      json["seriesLength"] = msg.seriesLength;
    }
    if (msg.minGamesCount) {
      json["minGamesCount"] = msg.minGamesCount;
    }
    if (msg.gamesStatus && TournamentGamesStatusJSON._toInt(msg.gamesStatus)) {
      json["gamesStatus"] = msg.gamesStatus;
    }
    if (msg.hideResults) {
      json["hideResults"] = msg.hideResults;
    }
    if (msg.hideAddReplayButton) {
      json["hideAddReplayButton"] = msg.hideAddReplayButton;
    }
    if (msg.isPrescripted) {
      json["isPrescripted"] = msg.isPrescripted;
    }
    if (msg.isFinished) {
      json["isFinished"] = msg.isFinished;
    }
    if (msg.rulesetConfig) {
      const _rulesetConfig_ = RulesetConfigJSON._writeMessage(
        msg.rulesetConfig,
      );
      if (Object.keys(_rulesetConfig_).length > 0) {
        json["rulesetConfig"] = _rulesetConfig_;
      }
    }
    if (msg.lobbyId) {
      json["lobbyId"] = msg.lobbyId;
    }
    if (msg.allowViewOtherTables) {
      json["allowViewOtherTables"] = msg.allowViewOtherTables;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GameConfig, json: any): GameConfig {
    const _rulesetTitle_ = json["rulesetTitle"] ?? json["ruleset_title"];
    if (_rulesetTitle_) {
      msg.rulesetTitle = _rulesetTitle_;
    }
    const _eventTitle_ = json["eventTitle"] ?? json["event_title"];
    if (_eventTitle_) {
      msg.eventTitle = _eventTitle_;
    }
    const _eventDescription_ =
      json["eventDescription"] ?? json["event_description"];
    if (_eventDescription_) {
      msg.eventDescription = _eventDescription_;
    }
    const _eventStatHost_ = json["eventStatHost"] ?? json["event_stat_host"];
    if (_eventStatHost_) {
      msg.eventStatHost = _eventStatHost_;
    }
    const _useTimer_ = json["useTimer"] ?? json["use_timer"];
    if (_useTimer_) {
      msg.useTimer = _useTimer_;
    }
    const _usePenalty_ = json["usePenalty"] ?? json["use_penalty"];
    if (_usePenalty_) {
      msg.usePenalty = _usePenalty_;
    }
    const _gameDuration_ = json["gameDuration"] ?? json["game_duration"];
    if (_gameDuration_) {
      msg.gameDuration = protoscript.parseNumber(_gameDuration_);
    }
    const _timezone_ = json["timezone"];
    if (_timezone_) {
      msg.timezone = _timezone_;
    }
    const _isOnline_ = json["isOnline"] ?? json["is_online"];
    if (_isOnline_) {
      msg.isOnline = _isOnline_;
    }
    const _isTeam_ = json["isTeam"] ?? json["is_team"];
    if (_isTeam_) {
      msg.isTeam = _isTeam_;
    }
    const _autoSeating_ = json["autoSeating"] ?? json["auto_seating"];
    if (_autoSeating_) {
      msg.autoSeating = _autoSeating_;
    }
    const _syncStart_ = json["syncStart"] ?? json["sync_start"];
    if (_syncStart_) {
      msg.syncStart = _syncStart_;
    }
    const _syncEnd_ = json["syncEnd"] ?? json["sync_end"];
    if (_syncEnd_) {
      msg.syncEnd = _syncEnd_;
    }
    const _sortByGames_ = json["sortByGames"] ?? json["sort_by_games"];
    if (_sortByGames_) {
      msg.sortByGames = _sortByGames_;
    }
    const _allowPlayerAppend_ =
      json["allowPlayerAppend"] ?? json["allow_player_append"];
    if (_allowPlayerAppend_) {
      msg.allowPlayerAppend = _allowPlayerAppend_;
    }
    const _seriesLength_ = json["seriesLength"] ?? json["series_length"];
    if (_seriesLength_) {
      msg.seriesLength = protoscript.parseNumber(_seriesLength_);
    }
    const _minGamesCount_ = json["minGamesCount"] ?? json["min_games_count"];
    if (_minGamesCount_) {
      msg.minGamesCount = protoscript.parseNumber(_minGamesCount_);
    }
    const _gamesStatus_ = json["gamesStatus"] ?? json["games_status"];
    if (_gamesStatus_) {
      msg.gamesStatus = TournamentGamesStatus._fromInt(_gamesStatus_);
    }
    const _hideResults_ = json["hideResults"] ?? json["hide_results"];
    if (_hideResults_) {
      msg.hideResults = _hideResults_;
    }
    const _hideAddReplayButton_ =
      json["hideAddReplayButton"] ?? json["hide_add_replay_button"];
    if (_hideAddReplayButton_) {
      msg.hideAddReplayButton = _hideAddReplayButton_;
    }
    const _isPrescripted_ = json["isPrescripted"] ?? json["is_prescripted"];
    if (_isPrescripted_) {
      msg.isPrescripted = _isPrescripted_;
    }
    const _isFinished_ = json["isFinished"] ?? json["is_finished"];
    if (_isFinished_) {
      msg.isFinished = _isFinished_;
    }
    const _rulesetConfig_ = json["rulesetConfig"] ?? json["ruleset_config"];
    if (_rulesetConfig_) {
      RulesetConfigJSON._readMessage(msg.rulesetConfig, _rulesetConfig_);
    }
    const _lobbyId_ = json["lobbyId"] ?? json["lobby_id"];
    if (_lobbyId_) {
      msg.lobbyId = protoscript.parseNumber(_lobbyId_);
    }
    const _allowViewOtherTables_ =
      json["allowViewOtherTables"] ?? json["allow_view_other_tables"];
    if (_allowViewOtherTables_) {
      msg.allowViewOtherTables = _allowViewOtherTables_;
    }
    return msg;
  },
};

export const PlayerInRatingJSON = {
  /**
   * Serializes PlayerInRating to JSON.
   */
  encode: function (msg: PartialDeep<PlayerInRating>): string {
    return JSON.stringify(PlayerInRatingJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerInRating from JSON.
   */
  decode: function (json: string): PlayerInRating {
    return PlayerInRatingJSON._readMessage(
      PlayerInRatingJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerInRating with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerInRating>): PlayerInRating {
    return {
      id: 0,
      title: "",
      tenhouId: "",
      rating: 0,
      chips: 0,
      winnerZone: false,
      avgPlace: 0,
      avgScore: 0,
      gamesPlayed: 0,
      teamName: undefined,
      hasAvatar: false,
      lastUpdate: "",
      penaltiesAmount: 0,
      penaltiesCount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerInRating>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.tenhouId) {
      json["tenhouId"] = msg.tenhouId;
    }
    if (msg.rating) {
      json["rating"] = msg.rating;
    }
    if (msg.chips) {
      json["chips"] = msg.chips;
    }
    if (msg.winnerZone) {
      json["winnerZone"] = msg.winnerZone;
    }
    if (msg.avgPlace) {
      json["avgPlace"] = msg.avgPlace;
    }
    if (msg.avgScore) {
      json["avgScore"] = msg.avgScore;
    }
    if (msg.gamesPlayed) {
      json["gamesPlayed"] = msg.gamesPlayed;
    }
    if (msg.teamName != undefined) {
      json["teamName"] = msg.teamName;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    if (msg.penaltiesAmount) {
      json["penaltiesAmount"] = msg.penaltiesAmount;
    }
    if (msg.penaltiesCount) {
      json["penaltiesCount"] = msg.penaltiesCount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PlayerInRating, json: any): PlayerInRating {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _tenhouId_ = json["tenhouId"] ?? json["tenhou_id"];
    if (_tenhouId_) {
      msg.tenhouId = _tenhouId_;
    }
    const _rating_ = json["rating"];
    if (_rating_) {
      msg.rating = protoscript.parseDouble(_rating_);
    }
    const _chips_ = json["chips"];
    if (_chips_) {
      msg.chips = protoscript.parseNumber(_chips_);
    }
    const _winnerZone_ = json["winnerZone"] ?? json["winner_zone"];
    if (_winnerZone_) {
      msg.winnerZone = _winnerZone_;
    }
    const _avgPlace_ = json["avgPlace"] ?? json["avg_place"];
    if (_avgPlace_) {
      msg.avgPlace = protoscript.parseDouble(_avgPlace_);
    }
    const _avgScore_ = json["avgScore"] ?? json["avg_score"];
    if (_avgScore_) {
      msg.avgScore = protoscript.parseDouble(_avgScore_);
    }
    const _gamesPlayed_ = json["gamesPlayed"] ?? json["games_played"];
    if (_gamesPlayed_) {
      msg.gamesPlayed = protoscript.parseNumber(_gamesPlayed_);
    }
    const _teamName_ = json["teamName"] ?? json["team_name"];
    if (_teamName_) {
      msg.teamName = _teamName_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    const _penaltiesAmount_ =
      json["penaltiesAmount"] ?? json["penalties_amount"];
    if (_penaltiesAmount_) {
      msg.penaltiesAmount = protoscript.parseDouble(_penaltiesAmount_);
    }
    const _penaltiesCount_ = json["penaltiesCount"] ?? json["penalties_count"];
    if (_penaltiesCount_) {
      msg.penaltiesCount = protoscript.parseNumber(_penaltiesCount_);
    }
    return msg;
  },
};

export const PlayerJSON = {
  /**
   * Serializes Player to JSON.
   */
  encode: function (msg: PartialDeep<Player>): string {
    return JSON.stringify(PlayerJSON._writeMessage(msg));
  },

  /**
   * Deserializes Player from JSON.
   */
  decode: function (json: string): Player {
    return PlayerJSON._readMessage(PlayerJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Player with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Player>): Player {
    return {
      id: 0,
      title: "",
      tenhouId: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Player>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.tenhouId) {
      json["tenhouId"] = msg.tenhouId;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Player, json: any): Player {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _tenhouId_ = json["tenhouId"] ?? json["tenhou_id"];
    if (_tenhouId_) {
      msg.tenhouId = _tenhouId_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const FinalResultOfSessionJSON = {
  /**
   * Serializes FinalResultOfSession to JSON.
   */
  encode: function (msg: PartialDeep<FinalResultOfSession>): string {
    return JSON.stringify(FinalResultOfSessionJSON._writeMessage(msg));
  },

  /**
   * Deserializes FinalResultOfSession from JSON.
   */
  decode: function (json: string): FinalResultOfSession {
    return FinalResultOfSessionJSON._readMessage(
      FinalResultOfSessionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FinalResultOfSession with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<FinalResultOfSession>,
  ): FinalResultOfSession {
    return {
      playerId: 0,
      score: 0,
      ratingDelta: 0,
      place: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FinalResultOfSession>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.score) {
      json["score"] = msg.score;
    }
    if (msg.ratingDelta) {
      json["ratingDelta"] = msg.ratingDelta;
    }
    if (msg.place) {
      json["place"] = msg.place;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FinalResultOfSession,
    json: any,
  ): FinalResultOfSession {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _score_ = json["score"];
    if (_score_) {
      msg.score = protoscript.parseNumber(_score_);
    }
    const _ratingDelta_ = json["ratingDelta"] ?? json["rating_delta"];
    if (_ratingDelta_) {
      msg.ratingDelta = protoscript.parseDouble(_ratingDelta_);
    }
    const _place_ = json["place"];
    if (_place_) {
      msg.place = protoscript.parseNumber(_place_);
    }
    return msg;
  },
};

export const PenaltyJSON = {
  /**
   * Serializes Penalty to JSON.
   */
  encode: function (msg: PartialDeep<Penalty>): string {
    return JSON.stringify(PenaltyJSON._writeMessage(msg));
  },

  /**
   * Deserializes Penalty from JSON.
   */
  decode: function (json: string): Penalty {
    return PenaltyJSON._readMessage(PenaltyJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Penalty with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Penalty>): Penalty {
    return {
      who: 0,
      amount: 0,
      reason: undefined,
      assignedBy: 0,
      createdAt: "",
      isCancelled: false,
      cancellationReason: undefined,
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Penalty>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.who) {
      json["who"] = msg.who;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.reason != undefined) {
      json["reason"] = msg.reason;
    }
    if (msg.assignedBy) {
      json["assignedBy"] = msg.assignedBy;
    }
    if (msg.createdAt) {
      json["createdAt"] = msg.createdAt;
    }
    if (msg.isCancelled) {
      json["isCancelled"] = msg.isCancelled;
    }
    if (msg.cancellationReason != undefined) {
      json["cancellationReason"] = msg.cancellationReason;
    }
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Penalty, json: any): Penalty {
    const _who_ = json["who"];
    if (_who_) {
      msg.who = protoscript.parseNumber(_who_);
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = protoscript.parseNumber(_amount_);
    }
    const _reason_ = json["reason"];
    if (_reason_) {
      msg.reason = _reason_;
    }
    const _assignedBy_ = json["assignedBy"] ?? json["assigned_by"];
    if (_assignedBy_) {
      msg.assignedBy = protoscript.parseNumber(_assignedBy_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = _createdAt_;
    }
    const _isCancelled_ = json["isCancelled"] ?? json["is_cancelled"];
    if (_isCancelled_) {
      msg.isCancelled = _isCancelled_;
    }
    const _cancellationReason_ =
      json["cancellationReason"] ?? json["cancellation_reason"];
    if (_cancellationReason_) {
      msg.cancellationReason = _cancellationReason_;
    }
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    return msg;
  },
};

export const RonResultJSON = {
  /**
   * Serializes RonResult to JSON.
   */
  encode: function (msg: PartialDeep<RonResult>): string {
    return JSON.stringify(RonResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes RonResult from JSON.
   */
  decode: function (json: string): RonResult {
    return RonResultJSON._readMessage(
      RonResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RonResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RonResult>): RonResult {
    return {
      roundIndex: 0,
      honba: 0,
      winnerId: 0,
      loserId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      riichiBets: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RonResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.winnerId) {
      json["winnerId"] = msg.winnerId;
    }
    if (msg.loserId) {
      json["loserId"] = msg.loserId;
    }
    if (msg.paoPlayerId) {
      json["paoPlayerId"] = msg.paoPlayerId;
    }
    if (msg.han) {
      json["han"] = msg.han;
    }
    if (msg.fu) {
      json["fu"] = msg.fu;
    }
    if (msg.yaku?.length) {
      json["yaku"] = msg.yaku;
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.dora) {
      json["dora"] = msg.dora;
    }
    if (msg.uradora) {
      json["uradora"] = msg.uradora;
    }
    if (msg.kandora) {
      json["kandora"] = msg.kandora;
    }
    if (msg.kanuradora) {
      json["kanuradora"] = msg.kanuradora;
    }
    if (msg.openHand) {
      json["openHand"] = msg.openHand;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RonResult, json: any): RonResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _winnerId_ = json["winnerId"] ?? json["winner_id"];
    if (_winnerId_) {
      msg.winnerId = protoscript.parseNumber(_winnerId_);
    }
    const _loserId_ = json["loserId"] ?? json["loser_id"];
    if (_loserId_) {
      msg.loserId = protoscript.parseNumber(_loserId_);
    }
    const _paoPlayerId_ = json["paoPlayerId"] ?? json["pao_player_id"];
    if (_paoPlayerId_) {
      msg.paoPlayerId = protoscript.parseNumber(_paoPlayerId_);
    }
    const _han_ = json["han"];
    if (_han_) {
      msg.han = protoscript.parseNumber(_han_);
    }
    const _fu_ = json["fu"];
    if (_fu_) {
      msg.fu = protoscript.parseNumber(_fu_);
    }
    const _yaku_ = json["yaku"];
    if (_yaku_) {
      msg.yaku = _yaku_.map(protoscript.parseNumber);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    const _dora_ = json["dora"];
    if (_dora_) {
      msg.dora = protoscript.parseNumber(_dora_);
    }
    const _uradora_ = json["uradora"];
    if (_uradora_) {
      msg.uradora = protoscript.parseNumber(_uradora_);
    }
    const _kandora_ = json["kandora"];
    if (_kandora_) {
      msg.kandora = protoscript.parseNumber(_kandora_);
    }
    const _kanuradora_ = json["kanuradora"];
    if (_kanuradora_) {
      msg.kanuradora = protoscript.parseNumber(_kanuradora_);
    }
    const _openHand_ = json["openHand"] ?? json["open_hand"];
    if (_openHand_) {
      msg.openHand = _openHand_;
    }
    return msg;
  },
};

export const MultironWinJSON = {
  /**
   * Serializes MultironWin to JSON.
   */
  encode: function (msg: PartialDeep<MultironWin>): string {
    return JSON.stringify(MultironWinJSON._writeMessage(msg));
  },

  /**
   * Deserializes MultironWin from JSON.
   */
  decode: function (json: string): MultironWin {
    return MultironWinJSON._readMessage(
      MultironWinJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MultironWin with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MultironWin>): MultironWin {
    return {
      winnerId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MultironWin>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.winnerId) {
      json["winnerId"] = msg.winnerId;
    }
    if (msg.paoPlayerId) {
      json["paoPlayerId"] = msg.paoPlayerId;
    }
    if (msg.han) {
      json["han"] = msg.han;
    }
    if (msg.fu) {
      json["fu"] = msg.fu;
    }
    if (msg.yaku?.length) {
      json["yaku"] = msg.yaku;
    }
    if (msg.dora) {
      json["dora"] = msg.dora;
    }
    if (msg.uradora) {
      json["uradora"] = msg.uradora;
    }
    if (msg.kandora) {
      json["kandora"] = msg.kandora;
    }
    if (msg.kanuradora) {
      json["kanuradora"] = msg.kanuradora;
    }
    if (msg.openHand) {
      json["openHand"] = msg.openHand;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MultironWin, json: any): MultironWin {
    const _winnerId_ = json["winnerId"] ?? json["winner_id"];
    if (_winnerId_) {
      msg.winnerId = protoscript.parseNumber(_winnerId_);
    }
    const _paoPlayerId_ = json["paoPlayerId"] ?? json["pao_player_id"];
    if (_paoPlayerId_) {
      msg.paoPlayerId = protoscript.parseNumber(_paoPlayerId_);
    }
    const _han_ = json["han"];
    if (_han_) {
      msg.han = protoscript.parseNumber(_han_);
    }
    const _fu_ = json["fu"];
    if (_fu_) {
      msg.fu = protoscript.parseNumber(_fu_);
    }
    const _yaku_ = json["yaku"];
    if (_yaku_) {
      msg.yaku = _yaku_.map(protoscript.parseNumber);
    }
    const _dora_ = json["dora"];
    if (_dora_) {
      msg.dora = protoscript.parseNumber(_dora_);
    }
    const _uradora_ = json["uradora"];
    if (_uradora_) {
      msg.uradora = protoscript.parseNumber(_uradora_);
    }
    const _kandora_ = json["kandora"];
    if (_kandora_) {
      msg.kandora = protoscript.parseNumber(_kandora_);
    }
    const _kanuradora_ = json["kanuradora"];
    if (_kanuradora_) {
      msg.kanuradora = protoscript.parseNumber(_kanuradora_);
    }
    const _openHand_ = json["openHand"] ?? json["open_hand"];
    if (_openHand_) {
      msg.openHand = _openHand_;
    }
    return msg;
  },
};

export const MultironResultJSON = {
  /**
   * Serializes MultironResult to JSON.
   */
  encode: function (msg: PartialDeep<MultironResult>): string {
    return JSON.stringify(MultironResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes MultironResult from JSON.
   */
  decode: function (json: string): MultironResult {
    return MultironResultJSON._readMessage(
      MultironResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MultironResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MultironResult>): MultironResult {
    return {
      roundIndex: 0,
      honba: 0,
      loserId: 0,
      multiRon: 0,
      wins: [],
      riichiBets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MultironResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.loserId) {
      json["loserId"] = msg.loserId;
    }
    if (msg.multiRon) {
      json["multiRon"] = msg.multiRon;
    }
    if (msg.wins?.length) {
      json["wins"] = msg.wins.map(MultironWinJSON._writeMessage);
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MultironResult, json: any): MultironResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _loserId_ = json["loserId"] ?? json["loser_id"];
    if (_loserId_) {
      msg.loserId = protoscript.parseNumber(_loserId_);
    }
    const _multiRon_ = json["multiRon"] ?? json["multi_ron"];
    if (_multiRon_) {
      msg.multiRon = protoscript.parseNumber(_multiRon_);
    }
    const _wins_ = json["wins"];
    if (_wins_) {
      for (const item of _wins_) {
        const m = MultironWinJSON.initialize();
        MultironWinJSON._readMessage(m, item);
        msg.wins.push(m);
      }
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const TsumoResultJSON = {
  /**
   * Serializes TsumoResult to JSON.
   */
  encode: function (msg: PartialDeep<TsumoResult>): string {
    return JSON.stringify(TsumoResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes TsumoResult from JSON.
   */
  decode: function (json: string): TsumoResult {
    return TsumoResultJSON._readMessage(
      TsumoResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TsumoResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TsumoResult>): TsumoResult {
    return {
      roundIndex: 0,
      honba: 0,
      winnerId: 0,
      paoPlayerId: 0,
      han: 0,
      fu: 0,
      yaku: [],
      riichiBets: [],
      dora: 0,
      uradora: 0,
      kandora: 0,
      kanuradora: 0,
      openHand: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TsumoResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.winnerId) {
      json["winnerId"] = msg.winnerId;
    }
    if (msg.paoPlayerId) {
      json["paoPlayerId"] = msg.paoPlayerId;
    }
    if (msg.han) {
      json["han"] = msg.han;
    }
    if (msg.fu) {
      json["fu"] = msg.fu;
    }
    if (msg.yaku?.length) {
      json["yaku"] = msg.yaku;
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.dora) {
      json["dora"] = msg.dora;
    }
    if (msg.uradora) {
      json["uradora"] = msg.uradora;
    }
    if (msg.kandora) {
      json["kandora"] = msg.kandora;
    }
    if (msg.kanuradora) {
      json["kanuradora"] = msg.kanuradora;
    }
    if (msg.openHand) {
      json["openHand"] = msg.openHand;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TsumoResult, json: any): TsumoResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _winnerId_ = json["winnerId"] ?? json["winner_id"];
    if (_winnerId_) {
      msg.winnerId = protoscript.parseNumber(_winnerId_);
    }
    const _paoPlayerId_ = json["paoPlayerId"] ?? json["pao_player_id"];
    if (_paoPlayerId_) {
      msg.paoPlayerId = protoscript.parseNumber(_paoPlayerId_);
    }
    const _han_ = json["han"];
    if (_han_) {
      msg.han = protoscript.parseNumber(_han_);
    }
    const _fu_ = json["fu"];
    if (_fu_) {
      msg.fu = protoscript.parseNumber(_fu_);
    }
    const _yaku_ = json["yaku"];
    if (_yaku_) {
      msg.yaku = _yaku_.map(protoscript.parseNumber);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    const _dora_ = json["dora"];
    if (_dora_) {
      msg.dora = protoscript.parseNumber(_dora_);
    }
    const _uradora_ = json["uradora"];
    if (_uradora_) {
      msg.uradora = protoscript.parseNumber(_uradora_);
    }
    const _kandora_ = json["kandora"];
    if (_kandora_) {
      msg.kandora = protoscript.parseNumber(_kandora_);
    }
    const _kanuradora_ = json["kanuradora"];
    if (_kanuradora_) {
      msg.kanuradora = protoscript.parseNumber(_kanuradora_);
    }
    const _openHand_ = json["openHand"] ?? json["open_hand"];
    if (_openHand_) {
      msg.openHand = _openHand_;
    }
    return msg;
  },
};

export const DrawResultJSON = {
  /**
   * Serializes DrawResult to JSON.
   */
  encode: function (msg: PartialDeep<DrawResult>): string {
    return JSON.stringify(DrawResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes DrawResult from JSON.
   */
  decode: function (json: string): DrawResult {
    return DrawResultJSON._readMessage(
      DrawResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DrawResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DrawResult>): DrawResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      tempai: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DrawResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.tempai?.length) {
      json["tempai"] = msg.tempai;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: DrawResult, json: any): DrawResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    const _tempai_ = json["tempai"];
    if (_tempai_) {
      msg.tempai = _tempai_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const AbortResultJSON = {
  /**
   * Serializes AbortResult to JSON.
   */
  encode: function (msg: PartialDeep<AbortResult>): string {
    return JSON.stringify(AbortResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes AbortResult from JSON.
   */
  decode: function (json: string): AbortResult {
    return AbortResultJSON._readMessage(
      AbortResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes AbortResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AbortResult>): AbortResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AbortResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: AbortResult, json: any): AbortResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const ChomboResultJSON = {
  /**
   * Serializes ChomboResult to JSON.
   */
  encode: function (msg: PartialDeep<ChomboResult>): string {
    return JSON.stringify(ChomboResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChomboResult from JSON.
   */
  decode: function (json: string): ChomboResult {
    return ChomboResultJSON._readMessage(
      ChomboResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ChomboResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ChomboResult>): ChomboResult {
    return {
      roundIndex: 0,
      honba: 0,
      loserId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ChomboResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.loserId) {
      json["loserId"] = msg.loserId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChomboResult, json: any): ChomboResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _loserId_ = json["loserId"] ?? json["loser_id"];
    if (_loserId_) {
      msg.loserId = protoscript.parseNumber(_loserId_);
    }
    return msg;
  },
};

export const NagashiResultJSON = {
  /**
   * Serializes NagashiResult to JSON.
   */
  encode: function (msg: PartialDeep<NagashiResult>): string {
    return JSON.stringify(NagashiResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes NagashiResult from JSON.
   */
  decode: function (json: string): NagashiResult {
    return NagashiResultJSON._readMessage(
      NagashiResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes NagashiResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<NagashiResult>): NagashiResult {
    return {
      roundIndex: 0,
      honba: 0,
      riichiBets: [],
      tempai: [],
      nagashi: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NagashiResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiBets?.length) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.tempai?.length) {
      json["tempai"] = msg.tempai;
    }
    if (msg.nagashi?.length) {
      json["nagashi"] = msg.nagashi;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: NagashiResult, json: any): NagashiResult {
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = _riichiBets_.map(protoscript.parseNumber);
    }
    const _tempai_ = json["tempai"];
    if (_tempai_) {
      msg.tempai = _tempai_.map(protoscript.parseNumber);
    }
    const _nagashi_ = json["nagashi"];
    if (_nagashi_) {
      msg.nagashi = _nagashi_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const RoundJSON = {
  /**
   * Serializes Round to JSON.
   */
  encode: function (msg: PartialDeep<Round>): string {
    return JSON.stringify(RoundJSON._writeMessage(msg));
  },

  /**
   * Deserializes Round from JSON.
   */
  decode: function (json: string): Round {
    return RoundJSON._readMessage(RoundJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Round with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Round>): Round {
    return {
      ron: undefined,
      tsumo: undefined,
      multiron: undefined,
      draw: undefined,
      abort: undefined,
      chombo: undefined,
      nagashi: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Round>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ron != undefined) {
      const _ron_ = RonResultJSON._writeMessage(msg.ron);
      json["ron"] = _ron_;
    }
    if (msg.tsumo != undefined) {
      const _tsumo_ = TsumoResultJSON._writeMessage(msg.tsumo);
      json["tsumo"] = _tsumo_;
    }
    if (msg.multiron != undefined) {
      const _multiron_ = MultironResultJSON._writeMessage(msg.multiron);
      json["multiron"] = _multiron_;
    }
    if (msg.draw != undefined) {
      const _draw_ = DrawResultJSON._writeMessage(msg.draw);
      json["draw"] = _draw_;
    }
    if (msg.abort != undefined) {
      const _abort_ = AbortResultJSON._writeMessage(msg.abort);
      json["abort"] = _abort_;
    }
    if (msg.chombo != undefined) {
      const _chombo_ = ChomboResultJSON._writeMessage(msg.chombo);
      json["chombo"] = _chombo_;
    }
    if (msg.nagashi != undefined) {
      const _nagashi_ = NagashiResultJSON._writeMessage(msg.nagashi);
      json["nagashi"] = _nagashi_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Round, json: any): Round {
    const _ron_ = json["ron"];
    if (_ron_) {
      msg.ron = RonResultJSON.initialize();
      RonResultJSON._readMessage(msg.ron, _ron_);
    }
    const _tsumo_ = json["tsumo"];
    if (_tsumo_) {
      msg.tsumo = TsumoResultJSON.initialize();
      TsumoResultJSON._readMessage(msg.tsumo, _tsumo_);
    }
    const _multiron_ = json["multiron"];
    if (_multiron_) {
      msg.multiron = MultironResultJSON.initialize();
      MultironResultJSON._readMessage(msg.multiron, _multiron_);
    }
    const _draw_ = json["draw"];
    if (_draw_) {
      msg.draw = DrawResultJSON.initialize();
      DrawResultJSON._readMessage(msg.draw, _draw_);
    }
    const _abort_ = json["abort"];
    if (_abort_) {
      msg.abort = AbortResultJSON.initialize();
      AbortResultJSON._readMessage(msg.abort, _abort_);
    }
    const _chombo_ = json["chombo"];
    if (_chombo_) {
      msg.chombo = ChomboResultJSON.initialize();
      ChomboResultJSON._readMessage(msg.chombo, _chombo_);
    }
    const _nagashi_ = json["nagashi"];
    if (_nagashi_) {
      msg.nagashi = NagashiResultJSON.initialize();
      NagashiResultJSON._readMessage(msg.nagashi, _nagashi_);
    }
    return msg;
  },
};

export const GameResultJSON = {
  /**
   * Serializes GameResult to JSON.
   */
  encode: function (msg: PartialDeep<GameResult>): string {
    return JSON.stringify(GameResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes GameResult from JSON.
   */
  decode: function (json: string): GameResult {
    return GameResultJSON._readMessage(
      GameResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GameResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GameResult>): GameResult {
    return {
      sessionHash: "",
      date: undefined,
      replayLink: "",
      players: [],
      finalResults: [],
      rounds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GameResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.date != undefined) {
      json["date"] = msg.date;
    }
    if (msg.replayLink) {
      json["replayLink"] = msg.replayLink;
    }
    if (msg.players?.length) {
      json["players"] = msg.players;
    }
    if (msg.finalResults?.length) {
      json["finalResults"] = msg.finalResults.map(
        FinalResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.rounds?.length) {
      json["rounds"] = msg.rounds.map(RoundJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GameResult, json: any): GameResult {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _date_ = json["date"];
    if (_date_) {
      msg.date = _date_;
    }
    const _replayLink_ = json["replayLink"] ?? json["replay_link"];
    if (_replayLink_) {
      msg.replayLink = _replayLink_;
    }
    const _players_ = json["players"];
    if (_players_) {
      msg.players = _players_.map(protoscript.parseNumber);
    }
    const _finalResults_ = json["finalResults"] ?? json["final_results"];
    if (_finalResults_) {
      for (const item of _finalResults_) {
        const m = FinalResultOfSessionJSON.initialize();
        FinalResultOfSessionJSON._readMessage(m, item);
        msg.finalResults.push(m);
      }
    }
    const _rounds_ = json["rounds"];
    if (_rounds_) {
      for (const item of _rounds_) {
        const m = RoundJSON.initialize();
        RoundJSON._readMessage(m, item);
        msg.rounds.push(m);
      }
    }
    return msg;
  },
};

export const PlayerPlaceInSeriesJSON = {
  /**
   * Serializes PlayerPlaceInSeries to JSON.
   */
  encode: function (msg: PartialDeep<PlayerPlaceInSeries>): string {
    return JSON.stringify(PlayerPlaceInSeriesJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerPlaceInSeries from JSON.
   */
  decode: function (json: string): PlayerPlaceInSeries {
    return PlayerPlaceInSeriesJSON._readMessage(
      PlayerPlaceInSeriesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerPlaceInSeries with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayerPlaceInSeries>,
  ): PlayerPlaceInSeries {
    return {
      sessionHash: "",
      place: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerPlaceInSeries>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.place) {
      json["place"] = msg.place;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerPlaceInSeries,
    json: any,
  ): PlayerPlaceInSeries {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _place_ = json["place"];
    if (_place_) {
      msg.place = protoscript.parseNumber(_place_);
    }
    return msg;
  },
};

export const SeriesResultJSON = {
  /**
   * Serializes SeriesResult to JSON.
   */
  encode: function (msg: PartialDeep<SeriesResult>): string {
    return JSON.stringify(SeriesResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes SeriesResult from JSON.
   */
  decode: function (json: string): SeriesResult {
    return SeriesResultJSON._readMessage(
      SeriesResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeriesResult with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SeriesResult>): SeriesResult {
    return {
      player: PlayerJSON.initialize(),
      bestSeries: [],
      bestSeriesScores: 0,
      bestSeriesPlaces: 0,
      bestSeriesAvgPlace: "",
      currentSeries: [],
      currentSeriesScores: 0,
      currentSeriesPlaces: 0,
      currentSeriesAvgPlace: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeriesResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.player) {
      const _player_ = PlayerJSON._writeMessage(msg.player);
      if (Object.keys(_player_).length > 0) {
        json["player"] = _player_;
      }
    }
    if (msg.bestSeries?.length) {
      json["bestSeries"] = msg.bestSeries.map(
        PlayerPlaceInSeriesJSON._writeMessage,
      );
    }
    if (msg.bestSeriesScores) {
      json["bestSeriesScores"] = msg.bestSeriesScores;
    }
    if (msg.bestSeriesPlaces) {
      json["bestSeriesPlaces"] = msg.bestSeriesPlaces;
    }
    if (msg.bestSeriesAvgPlace) {
      json["bestSeriesAvgPlace"] = msg.bestSeriesAvgPlace;
    }
    if (msg.currentSeries?.length) {
      json["currentSeries"] = msg.currentSeries.map(
        PlayerPlaceInSeriesJSON._writeMessage,
      );
    }
    if (msg.currentSeriesScores) {
      json["currentSeriesScores"] = msg.currentSeriesScores;
    }
    if (msg.currentSeriesPlaces) {
      json["currentSeriesPlaces"] = msg.currentSeriesPlaces;
    }
    if (msg.currentSeriesAvgPlace) {
      json["currentSeriesAvgPlace"] = msg.currentSeriesAvgPlace;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SeriesResult, json: any): SeriesResult {
    const _player_ = json["player"];
    if (_player_) {
      PlayerJSON._readMessage(msg.player, _player_);
    }
    const _bestSeries_ = json["bestSeries"] ?? json["best_series"];
    if (_bestSeries_) {
      for (const item of _bestSeries_) {
        const m = PlayerPlaceInSeriesJSON.initialize();
        PlayerPlaceInSeriesJSON._readMessage(m, item);
        msg.bestSeries.push(m);
      }
    }
    const _bestSeriesScores_ =
      json["bestSeriesScores"] ?? json["best_series_scores"];
    if (_bestSeriesScores_) {
      msg.bestSeriesScores = protoscript.parseDouble(_bestSeriesScores_);
    }
    const _bestSeriesPlaces_ =
      json["bestSeriesPlaces"] ?? json["best_series_places"];
    if (_bestSeriesPlaces_) {
      msg.bestSeriesPlaces = protoscript.parseNumber(_bestSeriesPlaces_);
    }
    const _bestSeriesAvgPlace_ =
      json["bestSeriesAvgPlace"] ?? json["best_series_avg_place"];
    if (_bestSeriesAvgPlace_) {
      msg.bestSeriesAvgPlace = _bestSeriesAvgPlace_;
    }
    const _currentSeries_ = json["currentSeries"] ?? json["current_series"];
    if (_currentSeries_) {
      for (const item of _currentSeries_) {
        const m = PlayerPlaceInSeriesJSON.initialize();
        PlayerPlaceInSeriesJSON._readMessage(m, item);
        msg.currentSeries.push(m);
      }
    }
    const _currentSeriesScores_ =
      json["currentSeriesScores"] ?? json["current_series_scores"];
    if (_currentSeriesScores_) {
      msg.currentSeriesScores = protoscript.parseDouble(_currentSeriesScores_);
    }
    const _currentSeriesPlaces_ =
      json["currentSeriesPlaces"] ?? json["current_series_places"];
    if (_currentSeriesPlaces_) {
      msg.currentSeriesPlaces = protoscript.parseNumber(_currentSeriesPlaces_);
    }
    const _currentSeriesAvgPlace_ =
      json["currentSeriesAvgPlace"] ?? json["current_series_avg_place"];
    if (_currentSeriesAvgPlace_) {
      msg.currentSeriesAvgPlace = _currentSeriesAvgPlace_;
    }
    return msg;
  },
};

export const ReplacementPlayerJSON = {
  /**
   * Serializes ReplacementPlayer to JSON.
   */
  encode: function (msg: PartialDeep<ReplacementPlayer>): string {
    return JSON.stringify(ReplacementPlayerJSON._writeMessage(msg));
  },

  /**
   * Deserializes ReplacementPlayer from JSON.
   */
  decode: function (json: string): ReplacementPlayer {
    return ReplacementPlayerJSON._readMessage(
      ReplacementPlayerJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ReplacementPlayer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ReplacementPlayer>): ReplacementPlayer {
    return {
      id: 0,
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ReplacementPlayer>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ReplacementPlayer,
    json: any,
  ): ReplacementPlayer {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const PlayerInSessionJSON = {
  /**
   * Serializes PlayerInSession to JSON.
   */
  encode: function (msg: PartialDeep<PlayerInSession>): string {
    return JSON.stringify(PlayerInSessionJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerInSession from JSON.
   */
  decode: function (json: string): PlayerInSession {
    return PlayerInSessionJSON._readMessage(
      PlayerInSessionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerInSession with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerInSession>): PlayerInSession {
    return {
      id: 0,
      title: "",
      score: 0,
      replacedBy: undefined,
      ratingDelta: 0,
      hasAvatar: false,
      lastUpdate: "",
      yakitori: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerInSession>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.score) {
      json["score"] = msg.score;
    }
    if (msg.replacedBy != undefined) {
      const _replacedBy_ = ReplacementPlayerJSON._writeMessage(msg.replacedBy);
      json["replacedBy"] = _replacedBy_;
    }
    if (msg.ratingDelta) {
      json["ratingDelta"] = msg.ratingDelta;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    if (msg.yakitori) {
      json["yakitori"] = msg.yakitori;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PlayerInSession, json: any): PlayerInSession {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _score_ = json["score"];
    if (_score_) {
      msg.score = protoscript.parseNumber(_score_);
    }
    const _replacedBy_ = json["replacedBy"] ?? json["replaced_by"];
    if (_replacedBy_) {
      msg.replacedBy = ReplacementPlayerJSON.initialize();
      ReplacementPlayerJSON._readMessage(msg.replacedBy, _replacedBy_);
    }
    const _ratingDelta_ = json["ratingDelta"] ?? json["rating_delta"];
    if (_ratingDelta_) {
      msg.ratingDelta = protoscript.parseDouble(_ratingDelta_);
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    const _yakitori_ = json["yakitori"];
    if (_yakitori_) {
      msg.yakitori = _yakitori_;
    }
    return msg;
  },
};

export const RegisteredPlayerJSON = {
  /**
   * Serializes RegisteredPlayer to JSON.
   */
  encode: function (msg: PartialDeep<RegisteredPlayer>): string {
    return JSON.stringify(RegisteredPlayerJSON._writeMessage(msg));
  },

  /**
   * Deserializes RegisteredPlayer from JSON.
   */
  decode: function (json: string): RegisteredPlayer {
    return RegisteredPlayerJSON._readMessage(
      RegisteredPlayerJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RegisteredPlayer with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RegisteredPlayer>): RegisteredPlayer {
    return {
      id: 0,
      title: "",
      localId: undefined,
      teamName: undefined,
      tenhouId: "",
      ignoreSeating: false,
      replacedBy: undefined,
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RegisteredPlayer>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.localId != undefined) {
      json["localId"] = msg.localId;
    }
    if (msg.teamName != undefined) {
      json["teamName"] = msg.teamName;
    }
    if (msg.tenhouId) {
      json["tenhouId"] = msg.tenhouId;
    }
    if (msg.ignoreSeating) {
      json["ignoreSeating"] = msg.ignoreSeating;
    }
    if (msg.replacedBy != undefined) {
      const _replacedBy_ = ReplacementPlayerJSON._writeMessage(msg.replacedBy);
      json["replacedBy"] = _replacedBy_;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RegisteredPlayer, json: any): RegisteredPlayer {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _localId_ = json["localId"] ?? json["local_id"];
    if (_localId_) {
      msg.localId = protoscript.parseNumber(_localId_);
    }
    const _teamName_ = json["teamName"] ?? json["team_name"];
    if (_teamName_) {
      msg.teamName = _teamName_;
    }
    const _tenhouId_ = json["tenhouId"] ?? json["tenhou_id"];
    if (_tenhouId_) {
      msg.tenhouId = _tenhouId_;
    }
    const _ignoreSeating_ = json["ignoreSeating"] ?? json["ignore_seating"];
    if (_ignoreSeating_) {
      msg.ignoreSeating = _ignoreSeating_;
    }
    const _replacedBy_ = json["replacedBy"] ?? json["replaced_by"];
    if (_replacedBy_) {
      msg.replacedBy = ReplacementPlayerJSON.initialize();
      ReplacementPlayerJSON._readMessage(msg.replacedBy, _replacedBy_);
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const SessionHistoryResultJSON = {
  /**
   * Serializes SessionHistoryResult to JSON.
   */
  encode: function (msg: PartialDeep<SessionHistoryResult>): string {
    return JSON.stringify(SessionHistoryResultJSON._writeMessage(msg));
  },

  /**
   * Deserializes SessionHistoryResult from JSON.
   */
  decode: function (json: string): SessionHistoryResult {
    return SessionHistoryResultJSON._readMessage(
      SessionHistoryResultJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SessionHistoryResult with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SessionHistoryResult>,
  ): SessionHistoryResult {
    return {
      sessionHash: "",
      eventId: 0,
      playerId: 0,
      score: 0,
      ratingDelta: 0,
      place: 0,
      title: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionHistoryResult>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.score) {
      json["score"] = msg.score;
    }
    if (msg.ratingDelta) {
      json["ratingDelta"] = msg.ratingDelta;
    }
    if (msg.place) {
      json["place"] = msg.place;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SessionHistoryResult,
    json: any,
  ): SessionHistoryResult {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _score_ = json["score"];
    if (_score_) {
      msg.score = protoscript.parseNumber(_score_);
    }
    const _ratingDelta_ = json["ratingDelta"] ?? json["rating_delta"];
    if (_ratingDelta_) {
      msg.ratingDelta = protoscript.parseDouble(_ratingDelta_);
    }
    const _place_ = json["place"];
    if (_place_) {
      msg.place = protoscript.parseNumber(_place_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const SessionHistoryResultTableJSON = {
  /**
   * Serializes SessionHistoryResultTable to JSON.
   */
  encode: function (msg: PartialDeep<SessionHistoryResultTable>): string {
    return JSON.stringify(SessionHistoryResultTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes SessionHistoryResultTable from JSON.
   */
  decode: function (json: string): SessionHistoryResultTable {
    return SessionHistoryResultTableJSON._readMessage(
      SessionHistoryResultTableJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SessionHistoryResultTable with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SessionHistoryResultTable>,
  ): SessionHistoryResultTable {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionHistoryResultTable>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(SessionHistoryResultJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SessionHistoryResultTable,
    json: any,
  ): SessionHistoryResultTable {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = SessionHistoryResultJSON.initialize();
        SessionHistoryResultJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const PlacesSummaryItemJSON = {
  /**
   * Serializes PlacesSummaryItem to JSON.
   */
  encode: function (msg: PartialDeep<PlacesSummaryItem>): string {
    return JSON.stringify(PlacesSummaryItemJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlacesSummaryItem from JSON.
   */
  decode: function (json: string): PlacesSummaryItem {
    return PlacesSummaryItemJSON._readMessage(
      PlacesSummaryItemJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlacesSummaryItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlacesSummaryItem>): PlacesSummaryItem {
    return {
      place: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlacesSummaryItem>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.place) {
      json["place"] = msg.place;
    }
    if (msg.count) {
      json["count"] = msg.count;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlacesSummaryItem,
    json: any,
  ): PlacesSummaryItem {
    const _place_ = json["place"];
    if (_place_) {
      msg.place = protoscript.parseNumber(_place_);
    }
    const _count_ = json["count"];
    if (_count_) {
      msg.count = protoscript.parseNumber(_count_);
    }
    return msg;
  },
};

export const PlayerWinSummaryJSON = {
  /**
   * Serializes PlayerWinSummary to JSON.
   */
  encode: function (msg: PartialDeep<PlayerWinSummary>): string {
    return JSON.stringify(PlayerWinSummaryJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerWinSummary from JSON.
   */
  decode: function (json: string): PlayerWinSummary {
    return PlayerWinSummaryJSON._readMessage(
      PlayerWinSummaryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerWinSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerWinSummary>): PlayerWinSummary {
    return {
      ron: 0,
      tsumo: 0,
      chombo: 0,
      feed: 0,
      tsumofeed: 0,
      winsWithOpen: 0,
      winsWithRiichi: 0,
      winsWithDama: 0,
      unforcedFeedToOpen: 0,
      unforcedFeedToRiichi: 0,
      unforcedFeedToDama: 0,
      draw: 0,
      drawTempai: 0,
      pointsWon: 0,
      pointsLostRon: 0,
      pointsLostTsumo: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerWinSummary>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ron) {
      json["ron"] = msg.ron;
    }
    if (msg.tsumo) {
      json["tsumo"] = msg.tsumo;
    }
    if (msg.chombo) {
      json["chombo"] = msg.chombo;
    }
    if (msg.feed) {
      json["feed"] = msg.feed;
    }
    if (msg.tsumofeed) {
      json["tsumofeed"] = msg.tsumofeed;
    }
    if (msg.winsWithOpen) {
      json["winsWithOpen"] = msg.winsWithOpen;
    }
    if (msg.winsWithRiichi) {
      json["winsWithRiichi"] = msg.winsWithRiichi;
    }
    if (msg.winsWithDama) {
      json["winsWithDama"] = msg.winsWithDama;
    }
    if (msg.unforcedFeedToOpen) {
      json["unforcedFeedToOpen"] = msg.unforcedFeedToOpen;
    }
    if (msg.unforcedFeedToRiichi) {
      json["unforcedFeedToRiichi"] = msg.unforcedFeedToRiichi;
    }
    if (msg.unforcedFeedToDama) {
      json["unforcedFeedToDama"] = msg.unforcedFeedToDama;
    }
    if (msg.draw) {
      json["draw"] = msg.draw;
    }
    if (msg.drawTempai) {
      json["drawTempai"] = msg.drawTempai;
    }
    if (msg.pointsWon) {
      json["pointsWon"] = msg.pointsWon;
    }
    if (msg.pointsLostRon) {
      json["pointsLostRon"] = msg.pointsLostRon;
    }
    if (msg.pointsLostTsumo) {
      json["pointsLostTsumo"] = msg.pointsLostTsumo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PlayerWinSummary, json: any): PlayerWinSummary {
    const _ron_ = json["ron"];
    if (_ron_) {
      msg.ron = protoscript.parseNumber(_ron_);
    }
    const _tsumo_ = json["tsumo"];
    if (_tsumo_) {
      msg.tsumo = protoscript.parseNumber(_tsumo_);
    }
    const _chombo_ = json["chombo"];
    if (_chombo_) {
      msg.chombo = protoscript.parseNumber(_chombo_);
    }
    const _feed_ = json["feed"];
    if (_feed_) {
      msg.feed = protoscript.parseNumber(_feed_);
    }
    const _tsumofeed_ = json["tsumofeed"];
    if (_tsumofeed_) {
      msg.tsumofeed = protoscript.parseNumber(_tsumofeed_);
    }
    const _winsWithOpen_ = json["winsWithOpen"] ?? json["wins_with_open"];
    if (_winsWithOpen_) {
      msg.winsWithOpen = protoscript.parseNumber(_winsWithOpen_);
    }
    const _winsWithRiichi_ = json["winsWithRiichi"] ?? json["wins_with_riichi"];
    if (_winsWithRiichi_) {
      msg.winsWithRiichi = protoscript.parseNumber(_winsWithRiichi_);
    }
    const _winsWithDama_ = json["winsWithDama"] ?? json["wins_with_dama"];
    if (_winsWithDama_) {
      msg.winsWithDama = protoscript.parseNumber(_winsWithDama_);
    }
    const _unforcedFeedToOpen_ =
      json["unforcedFeedToOpen"] ?? json["unforced_feed_to_open"];
    if (_unforcedFeedToOpen_) {
      msg.unforcedFeedToOpen = protoscript.parseNumber(_unforcedFeedToOpen_);
    }
    const _unforcedFeedToRiichi_ =
      json["unforcedFeedToRiichi"] ?? json["unforced_feed_to_riichi"];
    if (_unforcedFeedToRiichi_) {
      msg.unforcedFeedToRiichi = protoscript.parseNumber(
        _unforcedFeedToRiichi_,
      );
    }
    const _unforcedFeedToDama_ =
      json["unforcedFeedToDama"] ?? json["unforced_feed_to_dama"];
    if (_unforcedFeedToDama_) {
      msg.unforcedFeedToDama = protoscript.parseNumber(_unforcedFeedToDama_);
    }
    const _draw_ = json["draw"];
    if (_draw_) {
      msg.draw = protoscript.parseNumber(_draw_);
    }
    const _drawTempai_ = json["drawTempai"] ?? json["draw_tempai"];
    if (_drawTempai_) {
      msg.drawTempai = protoscript.parseNumber(_drawTempai_);
    }
    const _pointsWon_ = json["pointsWon"] ?? json["points_won"];
    if (_pointsWon_) {
      msg.pointsWon = protoscript.parseNumber(_pointsWon_);
    }
    const _pointsLostRon_ = json["pointsLostRon"] ?? json["points_lost_ron"];
    if (_pointsLostRon_) {
      msg.pointsLostRon = protoscript.parseNumber(_pointsLostRon_);
    }
    const _pointsLostTsumo_ =
      json["pointsLostTsumo"] ?? json["points_lost_tsumo"];
    if (_pointsLostTsumo_) {
      msg.pointsLostTsumo = protoscript.parseNumber(_pointsLostTsumo_);
    }
    return msg;
  },
};

export const HandValueStatJSON = {
  /**
   * Serializes HandValueStat to JSON.
   */
  encode: function (msg: PartialDeep<HandValueStat>): string {
    return JSON.stringify(HandValueStatJSON._writeMessage(msg));
  },

  /**
   * Deserializes HandValueStat from JSON.
   */
  decode: function (json: string): HandValueStat {
    return HandValueStatJSON._readMessage(
      HandValueStatJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes HandValueStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<HandValueStat>): HandValueStat {
    return {
      hanCount: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<HandValueStat>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.hanCount) {
      json["hanCount"] = msg.hanCount;
    }
    if (msg.count) {
      json["count"] = msg.count;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: HandValueStat, json: any): HandValueStat {
    const _hanCount_ = json["hanCount"] ?? json["han_count"];
    if (_hanCount_) {
      msg.hanCount = protoscript.parseNumber(_hanCount_);
    }
    const _count_ = json["count"];
    if (_count_) {
      msg.count = protoscript.parseNumber(_count_);
    }
    return msg;
  },
};

export const YakuStatJSON = {
  /**
   * Serializes YakuStat to JSON.
   */
  encode: function (msg: PartialDeep<YakuStat>): string {
    return JSON.stringify(YakuStatJSON._writeMessage(msg));
  },

  /**
   * Deserializes YakuStat from JSON.
   */
  decode: function (json: string): YakuStat {
    return YakuStatJSON._readMessage(
      YakuStatJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes YakuStat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<YakuStat>): YakuStat {
    return {
      yakuId: 0,
      count: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<YakuStat>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.yakuId) {
      json["yakuId"] = msg.yakuId;
    }
    if (msg.count) {
      json["count"] = msg.count;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: YakuStat, json: any): YakuStat {
    const _yakuId_ = json["yakuId"] ?? json["yaku_id"];
    if (_yakuId_) {
      msg.yakuId = protoscript.parseNumber(_yakuId_);
    }
    const _count_ = json["count"];
    if (_count_) {
      msg.count = protoscript.parseNumber(_count_);
    }
    return msg;
  },
};

export const RiichiSummaryJSON = {
  /**
   * Serializes RiichiSummary to JSON.
   */
  encode: function (msg: PartialDeep<RiichiSummary>): string {
    return JSON.stringify(RiichiSummaryJSON._writeMessage(msg));
  },

  /**
   * Deserializes RiichiSummary from JSON.
   */
  decode: function (json: string): RiichiSummary {
    return RiichiSummaryJSON._readMessage(
      RiichiSummaryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RiichiSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RiichiSummary>): RiichiSummary {
    return {
      riichiWon: 0,
      riichiLost: 0,
      feedUnderRiichi: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RiichiSummary>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.riichiWon) {
      json["riichiWon"] = msg.riichiWon;
    }
    if (msg.riichiLost) {
      json["riichiLost"] = msg.riichiLost;
    }
    if (msg.feedUnderRiichi) {
      json["feedUnderRiichi"] = msg.feedUnderRiichi;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RiichiSummary, json: any): RiichiSummary {
    const _riichiWon_ = json["riichiWon"] ?? json["riichi_won"];
    if (_riichiWon_) {
      msg.riichiWon = protoscript.parseNumber(_riichiWon_);
    }
    const _riichiLost_ = json["riichiLost"] ?? json["riichi_lost"];
    if (_riichiLost_) {
      msg.riichiLost = protoscript.parseNumber(_riichiLost_);
    }
    const _feedUnderRiichi_ =
      json["feedUnderRiichi"] ?? json["feed_under_riichi"];
    if (_feedUnderRiichi_) {
      msg.feedUnderRiichi = protoscript.parseNumber(_feedUnderRiichi_);
    }
    return msg;
  },
};

export const DoraSummaryJSON = {
  /**
   * Serializes DoraSummary to JSON.
   */
  encode: function (msg: PartialDeep<DoraSummary>): string {
    return JSON.stringify(DoraSummaryJSON._writeMessage(msg));
  },

  /**
   * Deserializes DoraSummary from JSON.
   */
  decode: function (json: string): DoraSummary {
    return DoraSummaryJSON._readMessage(
      DoraSummaryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DoraSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DoraSummary>): DoraSummary {
    return {
      count: 0,
      average: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DoraSummary>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.count) {
      json["count"] = msg.count;
    }
    if (msg.average) {
      json["average"] = msg.average;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: DoraSummary, json: any): DoraSummary {
    const _count_ = json["count"];
    if (_count_) {
      msg.count = protoscript.parseNumber(_count_);
    }
    const _average_ = json["average"];
    if (_average_) {
      msg.average = protoscript.parseDouble(_average_);
    }
    return msg;
  },
};

export const IntermediateResultOfSessionJSON = {
  /**
   * Serializes IntermediateResultOfSession to JSON.
   */
  encode: function (msg: PartialDeep<IntermediateResultOfSession>): string {
    return JSON.stringify(IntermediateResultOfSessionJSON._writeMessage(msg));
  },

  /**
   * Deserializes IntermediateResultOfSession from JSON.
   */
  decode: function (json: string): IntermediateResultOfSession {
    return IntermediateResultOfSessionJSON._readMessage(
      IntermediateResultOfSessionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes IntermediateResultOfSession with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<IntermediateResultOfSession>,
  ): IntermediateResultOfSession {
    return {
      playerId: 0,
      score: 0,
      chomboCount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<IntermediateResultOfSession>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.score) {
      json["score"] = msg.score;
    }
    if (msg.chomboCount) {
      json["chomboCount"] = msg.chomboCount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: IntermediateResultOfSession,
    json: any,
  ): IntermediateResultOfSession {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _score_ = json["score"];
    if (_score_) {
      msg.score = protoscript.parseNumber(_score_);
    }
    const _chomboCount_ = json["chomboCount"] ?? json["chombo_count"];
    if (_chomboCount_) {
      msg.chomboCount = protoscript.parseNumber(_chomboCount_);
    }
    return msg;
  },
};

export const PaymentLogItemJSON = {
  /**
   * Serializes PaymentLogItem to JSON.
   */
  encode: function (msg: PartialDeep<PaymentLogItem>): string {
    return JSON.stringify(PaymentLogItemJSON._writeMessage(msg));
  },

  /**
   * Deserializes PaymentLogItem from JSON.
   */
  decode: function (json: string): PaymentLogItem {
    return PaymentLogItemJSON._readMessage(
      PaymentLogItemJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PaymentLogItem with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PaymentLogItem>): PaymentLogItem {
    return {
      from: undefined,
      to: undefined,
      amount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PaymentLogItem>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.from != undefined) {
      json["from"] = msg.from;
    }
    if (msg.to != undefined) {
      json["to"] = msg.to;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PaymentLogItem, json: any): PaymentLogItem {
    const _from_ = json["from"];
    if (_from_) {
      msg.from = protoscript.parseNumber(_from_);
    }
    const _to_ = json["to"];
    if (_to_) {
      msg.to = protoscript.parseNumber(_to_);
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = protoscript.parseNumber(_amount_);
    }
    return msg;
  },
};

export const PaymentLogJSON = {
  /**
   * Serializes PaymentLog to JSON.
   */
  encode: function (msg: PartialDeep<PaymentLog>): string {
    return JSON.stringify(PaymentLogJSON._writeMessage(msg));
  },

  /**
   * Deserializes PaymentLog from JSON.
   */
  decode: function (json: string): PaymentLog {
    return PaymentLogJSON._readMessage(
      PaymentLogJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PaymentLog with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PaymentLog>): PaymentLog {
    return {
      direct: [],
      riichi: [],
      honba: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PaymentLog>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.direct?.length) {
      json["direct"] = msg.direct.map(PaymentLogItemJSON._writeMessage);
    }
    if (msg.riichi?.length) {
      json["riichi"] = msg.riichi.map(PaymentLogItemJSON._writeMessage);
    }
    if (msg.honba?.length) {
      json["honba"] = msg.honba.map(PaymentLogItemJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PaymentLog, json: any): PaymentLog {
    const _direct_ = json["direct"];
    if (_direct_) {
      for (const item of _direct_) {
        const m = PaymentLogItemJSON.initialize();
        PaymentLogItemJSON._readMessage(m, item);
        msg.direct.push(m);
      }
    }
    const _riichi_ = json["riichi"];
    if (_riichi_) {
      for (const item of _riichi_) {
        const m = PaymentLogItemJSON.initialize();
        PaymentLogItemJSON._readMessage(m, item);
        msg.riichi.push(m);
      }
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      for (const item of _honba_) {
        const m = PaymentLogItemJSON.initialize();
        PaymentLogItemJSON._readMessage(m, item);
        msg.honba.push(m);
      }
    }
    return msg;
  },
};

export const RoundStateJSON = {
  /**
   * Serializes RoundState to JSON.
   */
  encode: function (msg: PartialDeep<RoundState>): string {
    return JSON.stringify(RoundStateJSON._writeMessage(msg));
  },

  /**
   * Deserializes RoundState from JSON.
   */
  decode: function (json: string): RoundState {
    return RoundStateJSON._readMessage(
      RoundStateJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RoundState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RoundState>): RoundState {
    return {
      sessionHash: "",
      dealer: 0,
      roundIndex: 0,
      riichi: 0,
      honba: 0,
      riichiIds: [],
      scores: [],
      scoresDelta: [],
      payments: PaymentLogJSON.initialize(),
      round: RoundJSON.initialize(),
      outcome: RoundOutcome._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RoundState>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.dealer) {
      json["dealer"] = msg.dealer;
    }
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.riichi) {
      json["riichi"] = msg.riichi;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiIds?.length) {
      json["riichiIds"] = msg.riichiIds;
    }
    if (msg.scores?.length) {
      json["scores"] = msg.scores.map(
        IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.scoresDelta?.length) {
      json["scoresDelta"] = msg.scoresDelta.map(
        IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.payments) {
      const _payments_ = PaymentLogJSON._writeMessage(msg.payments);
      if (Object.keys(_payments_).length > 0) {
        json["payments"] = _payments_;
      }
    }
    if (msg.round) {
      const _round_ = RoundJSON._writeMessage(msg.round);
      if (Object.keys(_round_).length > 0) {
        json["round"] = _round_;
      }
    }
    if (msg.outcome && RoundOutcomeJSON._toInt(msg.outcome)) {
      json["outcome"] = msg.outcome;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RoundState, json: any): RoundState {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _dealer_ = json["dealer"];
    if (_dealer_) {
      msg.dealer = protoscript.parseNumber(_dealer_);
    }
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _riichi_ = json["riichi"];
    if (_riichi_) {
      msg.riichi = protoscript.parseNumber(_riichi_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _riichiIds_ = json["riichiIds"] ?? json["riichi_ids"];
    if (_riichiIds_) {
      msg.riichiIds = _riichiIds_.map(protoscript.parseNumber);
    }
    const _scores_ = json["scores"];
    if (_scores_) {
      for (const item of _scores_) {
        const m = IntermediateResultOfSessionJSON.initialize();
        IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scores.push(m);
      }
    }
    const _scoresDelta_ = json["scoresDelta"] ?? json["scores_delta"];
    if (_scoresDelta_) {
      for (const item of _scoresDelta_) {
        const m = IntermediateResultOfSessionJSON.initialize();
        IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scoresDelta.push(m);
      }
    }
    const _payments_ = json["payments"];
    if (_payments_) {
      PaymentLogJSON._readMessage(msg.payments, _payments_);
    }
    const _round_ = json["round"];
    if (_round_) {
      RoundJSON._readMessage(msg.round, _round_);
    }
    const _outcome_ = json["outcome"];
    if (_outcome_) {
      msg.outcome = RoundOutcome._fromInt(_outcome_);
    }
    return msg;
  },
};

export const EventDataJSON = {
  /**
   * Serializes EventData to JSON.
   */
  encode: function (msg: PartialDeep<EventData>): string {
    return JSON.stringify(EventDataJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventData from JSON.
   */
  decode: function (json: string): EventData {
    return EventDataJSON._readMessage(
      EventDataJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventData with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EventData>): EventData {
    return {
      type: undefined,
      title: "",
      description: "",
      duration: 0,
      timezone: "",
      lobbyId: 0,
      seriesLength: 0,
      minGames: 0,
      isTeam: false,
      isPrescripted: false,
      autostart: 0,
      rulesetConfig: RulesetConfigJSON.initialize(),
      isListed: false,
      isRatingShown: false,
      achievementsShown: false,
      allowViewOtherTables: false,
      platformId: PlatformType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventData>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.type != undefined) {
      json["type"] = msg.type;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.duration) {
      json["duration"] = msg.duration;
    }
    if (msg.timezone) {
      json["timezone"] = msg.timezone;
    }
    if (msg.lobbyId) {
      json["lobbyId"] = msg.lobbyId;
    }
    if (msg.seriesLength) {
      json["seriesLength"] = msg.seriesLength;
    }
    if (msg.minGames) {
      json["minGames"] = msg.minGames;
    }
    if (msg.isTeam) {
      json["isTeam"] = msg.isTeam;
    }
    if (msg.isPrescripted) {
      json["isPrescripted"] = msg.isPrescripted;
    }
    if (msg.autostart) {
      json["autostart"] = msg.autostart;
    }
    if (msg.rulesetConfig) {
      const _rulesetConfig_ = RulesetConfigJSON._writeMessage(
        msg.rulesetConfig,
      );
      if (Object.keys(_rulesetConfig_).length > 0) {
        json["rulesetConfig"] = _rulesetConfig_;
      }
    }
    if (msg.isListed) {
      json["isListed"] = msg.isListed;
    }
    if (msg.isRatingShown) {
      json["isRatingShown"] = msg.isRatingShown;
    }
    if (msg.achievementsShown) {
      json["achievementsShown"] = msg.achievementsShown;
    }
    if (msg.allowViewOtherTables) {
      json["allowViewOtherTables"] = msg.allowViewOtherTables;
    }
    if (msg.platformId && PlatformTypeJSON._toInt(msg.platformId)) {
      json["platformId"] = msg.platformId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EventData, json: any): EventData {
    const _type_ = json["type"];
    if (_type_) {
      msg.type = EventType._fromInt(_type_);
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _duration_ = json["duration"];
    if (_duration_) {
      msg.duration = protoscript.parseNumber(_duration_);
    }
    const _timezone_ = json["timezone"];
    if (_timezone_) {
      msg.timezone = _timezone_;
    }
    const _lobbyId_ = json["lobbyId"] ?? json["lobby_id"];
    if (_lobbyId_) {
      msg.lobbyId = protoscript.parseNumber(_lobbyId_);
    }
    const _seriesLength_ = json["seriesLength"] ?? json["series_length"];
    if (_seriesLength_) {
      msg.seriesLength = protoscript.parseNumber(_seriesLength_);
    }
    const _minGames_ = json["minGames"] ?? json["min_games"];
    if (_minGames_) {
      msg.minGames = protoscript.parseNumber(_minGames_);
    }
    const _isTeam_ = json["isTeam"] ?? json["is_team"];
    if (_isTeam_) {
      msg.isTeam = _isTeam_;
    }
    const _isPrescripted_ = json["isPrescripted"] ?? json["is_prescripted"];
    if (_isPrescripted_) {
      msg.isPrescripted = _isPrescripted_;
    }
    const _autostart_ = json["autostart"];
    if (_autostart_) {
      msg.autostart = protoscript.parseNumber(_autostart_);
    }
    const _rulesetConfig_ = json["rulesetConfig"] ?? json["ruleset_config"];
    if (_rulesetConfig_) {
      RulesetConfigJSON._readMessage(msg.rulesetConfig, _rulesetConfig_);
    }
    const _isListed_ = json["isListed"] ?? json["is_listed"];
    if (_isListed_) {
      msg.isListed = _isListed_;
    }
    const _isRatingShown_ = json["isRatingShown"] ?? json["is_rating_shown"];
    if (_isRatingShown_) {
      msg.isRatingShown = _isRatingShown_;
    }
    const _achievementsShown_ =
      json["achievementsShown"] ?? json["achievements_shown"];
    if (_achievementsShown_) {
      msg.achievementsShown = _achievementsShown_;
    }
    const _allowViewOtherTables_ =
      json["allowViewOtherTables"] ?? json["allow_view_other_tables"];
    if (_allowViewOtherTables_) {
      msg.allowViewOtherTables = _allowViewOtherTables_;
    }
    const _platformId_ = json["platformId"] ?? json["platform_id"];
    if (_platformId_) {
      msg.platformId = PlatformType._fromInt(_platformId_);
    }
    return msg;
  },
};

export const TableStateJSON = {
  /**
   * Serializes TableState to JSON.
   */
  encode: function (msg: PartialDeep<TableState>): string {
    return JSON.stringify(TableStateJSON._writeMessage(msg));
  },

  /**
   * Deserializes TableState from JSON.
   */
  decode: function (json: string): TableState {
    return TableStateJSON._readMessage(
      TableStateJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TableState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TableState>): TableState {
    return {
      status: SessionStatus._fromInt(0),
      mayDefinalize: false,
      sessionHash: "",
      tableIndex: undefined,
      lastRound: undefined,
      currentRoundIndex: 0,
      scores: [],
      players: [],
      extraTime: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TableState>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status && SessionStatusJSON._toInt(msg.status)) {
      json["status"] = msg.status;
    }
    if (msg.mayDefinalize) {
      json["mayDefinalize"] = msg.mayDefinalize;
    }
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.tableIndex != undefined) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.lastRound != undefined) {
      const _lastRound_ = RoundJSON._writeMessage(msg.lastRound);
      json["lastRound"] = _lastRound_;
    }
    if (msg.currentRoundIndex) {
      json["currentRoundIndex"] = msg.currentRoundIndex;
    }
    if (msg.scores?.length) {
      json["scores"] = msg.scores.map(
        IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(RegisteredPlayerJSON._writeMessage);
    }
    if (msg.extraTime != undefined) {
      json["extraTime"] = msg.extraTime;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TableState, json: any): TableState {
    const _status_ = json["status"];
    if (_status_) {
      msg.status = SessionStatus._fromInt(_status_);
    }
    const _mayDefinalize_ = json["mayDefinalize"] ?? json["may_definalize"];
    if (_mayDefinalize_) {
      msg.mayDefinalize = _mayDefinalize_;
    }
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _tableIndex_ = json["tableIndex"] ?? json["table_index"];
    if (_tableIndex_) {
      msg.tableIndex = protoscript.parseNumber(_tableIndex_);
    }
    const _lastRound_ = json["lastRound"] ?? json["last_round"];
    if (_lastRound_) {
      msg.lastRound = RoundJSON.initialize();
      RoundJSON._readMessage(msg.lastRound, _lastRound_);
    }
    const _currentRoundIndex_ =
      json["currentRoundIndex"] ?? json["current_round_index"];
    if (_currentRoundIndex_) {
      msg.currentRoundIndex = protoscript.parseNumber(_currentRoundIndex_);
    }
    const _scores_ = json["scores"];
    if (_scores_) {
      for (const item of _scores_) {
        const m = IntermediateResultOfSessionJSON.initialize();
        IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scores.push(m);
      }
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = RegisteredPlayerJSON.initialize();
        RegisteredPlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _extraTime_ = json["extraTime"] ?? json["extra_time"];
    if (_extraTime_) {
      msg.extraTime = protoscript.parseNumber(_extraTime_);
    }
    return msg;
  },
};

export const AchievementJSON = {
  /**
   * Serializes Achievement to JSON.
   */
  encode: function (msg: PartialDeep<Achievement>): string {
    return JSON.stringify(AchievementJSON._writeMessage(msg));
  },

  /**
   * Deserializes Achievement from JSON.
   */
  decode: function (json: string): Achievement {
    return AchievementJSON._readMessage(
      AchievementJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Achievement with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Achievement>): Achievement {
    return {
      achievementId: "",
      achievementData: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Achievement>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.achievementId) {
      json["achievementId"] = msg.achievementId;
    }
    if (msg.achievementData) {
      json["achievementData"] = msg.achievementData;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Achievement, json: any): Achievement {
    const _achievementId_ = json["achievementId"] ?? json["achievement_id"];
    if (_achievementId_) {
      msg.achievementId = _achievementId_;
    }
    const _achievementData_ =
      json["achievementData"] ?? json["achievement_data"];
    if (_achievementData_) {
      msg.achievementData = _achievementData_;
    }
    return msg;
  },
};

export const LocalIdMappingJSON = {
  /**
   * Serializes LocalIdMapping to JSON.
   */
  encode: function (msg: PartialDeep<LocalIdMapping>): string {
    return JSON.stringify(LocalIdMappingJSON._writeMessage(msg));
  },

  /**
   * Deserializes LocalIdMapping from JSON.
   */
  decode: function (json: string): LocalIdMapping {
    return LocalIdMappingJSON._readMessage(
      LocalIdMappingJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes LocalIdMapping with all fields set to their default value.
   */
  initialize: function (msg?: Partial<LocalIdMapping>): LocalIdMapping {
    return {
      playerId: 0,
      localId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<LocalIdMapping>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.localId) {
      json["localId"] = msg.localId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: LocalIdMapping, json: any): LocalIdMapping {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _localId_ = json["localId"] ?? json["local_id"];
    if (_localId_) {
      msg.localId = protoscript.parseNumber(_localId_);
    }
    return msg;
  },
};

export const TeamMappingJSON = {
  /**
   * Serializes TeamMapping to JSON.
   */
  encode: function (msg: PartialDeep<TeamMapping>): string {
    return JSON.stringify(TeamMappingJSON._writeMessage(msg));
  },

  /**
   * Deserializes TeamMapping from JSON.
   */
  decode: function (json: string): TeamMapping {
    return TeamMappingJSON._readMessage(
      TeamMappingJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TeamMapping with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TeamMapping>): TeamMapping {
    return {
      playerId: 0,
      teamName: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TeamMapping>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.teamName) {
      json["teamName"] = msg.teamName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TeamMapping, json: any): TeamMapping {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _teamName_ = json["teamName"] ?? json["team_name"];
    if (_teamName_) {
      msg.teamName = _teamName_;
    }
    return msg;
  },
};

export const PlayerSeatingJSON = {
  /**
   * Serializes PlayerSeating to JSON.
   */
  encode: function (msg: PartialDeep<PlayerSeating>): string {
    return JSON.stringify(PlayerSeatingJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerSeating from JSON.
   */
  decode: function (json: string): PlayerSeating {
    return PlayerSeatingJSON._readMessage(
      PlayerSeatingJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerSeating with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerSeating>): PlayerSeating {
    return {
      order: 0,
      playerId: 0,
      sessionId: 0,
      tableIndex: 0,
      rating: 0,
      playerTitle: "",
      hasAvatar: false,
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerSeating>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.order) {
      json["order"] = msg.order;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.sessionId) {
      json["sessionId"] = msg.sessionId;
    }
    if (msg.tableIndex) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.rating) {
      json["rating"] = msg.rating;
    }
    if (msg.playerTitle) {
      json["playerTitle"] = msg.playerTitle;
    }
    if (msg.hasAvatar) {
      json["hasAvatar"] = msg.hasAvatar;
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PlayerSeating, json: any): PlayerSeating {
    const _order_ = json["order"];
    if (_order_) {
      msg.order = protoscript.parseNumber(_order_);
    }
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _sessionId_ = json["sessionId"] ?? json["session_id"];
    if (_sessionId_) {
      msg.sessionId = protoscript.parseNumber(_sessionId_);
    }
    const _tableIndex_ = json["tableIndex"] ?? json["table_index"];
    if (_tableIndex_) {
      msg.tableIndex = protoscript.parseNumber(_tableIndex_);
    }
    const _rating_ = json["rating"];
    if (_rating_) {
      msg.rating = protoscript.parseDouble(_rating_);
    }
    const _playerTitle_ = json["playerTitle"] ?? json["player_title"];
    if (_playerTitle_) {
      msg.playerTitle = _playerTitle_;
    }
    const _hasAvatar_ = json["hasAvatar"] ?? json["has_avatar"];
    if (_hasAvatar_) {
      msg.hasAvatar = _hasAvatar_;
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const PlayerSeatingSwissJSON = {
  /**
   * Serializes PlayerSeatingSwiss to JSON.
   */
  encode: function (msg: PartialDeep<PlayerSeatingSwiss>): string {
    return JSON.stringify(PlayerSeatingSwissJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayerSeatingSwiss from JSON.
   */
  decode: function (json: string): PlayerSeatingSwiss {
    return PlayerSeatingSwissJSON._readMessage(
      PlayerSeatingSwissJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayerSeatingSwiss with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PlayerSeatingSwiss>): PlayerSeatingSwiss {
    return {
      playerId: 0,
      rating: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayerSeatingSwiss>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.rating) {
      json["rating"] = msg.rating;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayerSeatingSwiss,
    json: any,
  ): PlayerSeatingSwiss {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _rating_ = json["rating"];
    if (_rating_) {
      msg.rating = protoscript.parseDouble(_rating_);
    }
    return msg;
  },
};

export const TableItemSwissJSON = {
  /**
   * Serializes TableItemSwiss to JSON.
   */
  encode: function (msg: PartialDeep<TableItemSwiss>): string {
    return JSON.stringify(TableItemSwissJSON._writeMessage(msg));
  },

  /**
   * Deserializes TableItemSwiss from JSON.
   */
  decode: function (json: string): TableItemSwiss {
    return TableItemSwissJSON._readMessage(
      TableItemSwissJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TableItemSwiss with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TableItemSwiss>): TableItemSwiss {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TableItemSwiss>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players?.length) {
      json["players"] = msg.players.map(PlayerSeatingSwissJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TableItemSwiss, json: any): TableItemSwiss {
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = PlayerSeatingSwissJSON.initialize();
        PlayerSeatingSwissJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const PrescriptedTableJSON = {
  /**
   * Serializes PrescriptedTable to JSON.
   */
  encode: function (msg: PartialDeep<PrescriptedTable>): string {
    return JSON.stringify(PrescriptedTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes PrescriptedTable from JSON.
   */
  decode: function (json: string): PrescriptedTable {
    return PrescriptedTableJSON._readMessage(
      PrescriptedTableJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PrescriptedTable with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PrescriptedTable>): PrescriptedTable {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PrescriptedTable>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players?.length) {
      json["players"] = msg.players.map(RegisteredPlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: PrescriptedTable, json: any): PrescriptedTable {
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = RegisteredPlayerJSON.initialize();
        RegisteredPlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const ChomboJSON = {
  /**
   * Serializes Chombo to JSON.
   */
  encode: function (msg: PartialDeep<Chombo>): string {
    return JSON.stringify(ChomboJSON._writeMessage(msg));
  },

  /**
   * Deserializes Chombo from JSON.
   */
  decode: function (json: string): Chombo {
    return ChomboJSON._readMessage(ChomboJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Chombo with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Chombo>): Chombo {
    return {
      playerId: 0,
      amount: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Chombo>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Chombo, json: any): Chombo {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = protoscript.parseDouble(_amount_);
    }
    return msg;
  },
};

export const SessionStateJSON = {
  /**
   * Serializes SessionState to JSON.
   */
  encode: function (msg: PartialDeep<SessionState>): string {
    return JSON.stringify(SessionStateJSON._writeMessage(msg));
  },

  /**
   * Deserializes SessionState from JSON.
   */
  decode: function (json: string): SessionState {
    return SessionStateJSON._readMessage(
      SessionStateJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SessionState with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SessionState>): SessionState {
    return {
      dealer: 0,
      roundIndex: 0,
      riichiCount: 0,
      honbaCount: 0,
      scores: [],
      finished: false,
      lastHandStarted: false,
      chombo: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SessionState>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dealer) {
      json["dealer"] = msg.dealer;
    }
    if (msg.roundIndex) {
      json["roundIndex"] = msg.roundIndex;
    }
    if (msg.riichiCount) {
      json["riichiCount"] = msg.riichiCount;
    }
    if (msg.honbaCount) {
      json["honbaCount"] = msg.honbaCount;
    }
    if (msg.scores?.length) {
      json["scores"] = msg.scores.map(
        IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.finished) {
      json["finished"] = msg.finished;
    }
    if (msg.lastHandStarted) {
      json["lastHandStarted"] = msg.lastHandStarted;
    }
    if (msg.chombo?.length) {
      json["chombo"] = msg.chombo.map(ChomboJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SessionState, json: any): SessionState {
    const _dealer_ = json["dealer"];
    if (_dealer_) {
      msg.dealer = protoscript.parseNumber(_dealer_);
    }
    const _roundIndex_ = json["roundIndex"] ?? json["round_index"];
    if (_roundIndex_) {
      msg.roundIndex = protoscript.parseNumber(_roundIndex_);
    }
    const _riichiCount_ = json["riichiCount"] ?? json["riichi_count"];
    if (_riichiCount_) {
      msg.riichiCount = protoscript.parseNumber(_riichiCount_);
    }
    const _honbaCount_ = json["honbaCount"] ?? json["honba_count"];
    if (_honbaCount_) {
      msg.honbaCount = protoscript.parseNumber(_honbaCount_);
    }
    const _scores_ = json["scores"];
    if (_scores_) {
      for (const item of _scores_) {
        const m = IntermediateResultOfSessionJSON.initialize();
        IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scores.push(m);
      }
    }
    const _finished_ = json["finished"];
    if (_finished_) {
      msg.finished = _finished_;
    }
    const _lastHandStarted_ =
      json["lastHandStarted"] ?? json["last_hand_started"];
    if (_lastHandStarted_) {
      msg.lastHandStarted = _lastHandStarted_;
    }
    const _chombo_ = json["chombo"];
    if (_chombo_) {
      for (const item of _chombo_) {
        const m = ChomboJSON.initialize();
        ChomboJSON._readMessage(m, item);
        msg.chombo.push(m);
      }
    }
    return msg;
  },
};

export const UmaJSON = {
  /**
   * Serializes Uma to JSON.
   */
  encode: function (msg: PartialDeep<Uma>): string {
    return JSON.stringify(UmaJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uma from JSON.
   */
  decode: function (json: string): Uma {
    return UmaJSON._readMessage(UmaJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Uma with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Uma>): Uma {
    return {
      place1: 0,
      place2: 0,
      place3: 0,
      place4: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Uma>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.place1) {
      json["place1"] = msg.place1;
    }
    if (msg.place2) {
      json["place2"] = msg.place2;
    }
    if (msg.place3) {
      json["place3"] = msg.place3;
    }
    if (msg.place4) {
      json["place4"] = msg.place4;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uma, json: any): Uma {
    const _place1_ = json["place1"];
    if (_place1_) {
      msg.place1 = protoscript.parseNumber(_place1_);
    }
    const _place2_ = json["place2"];
    if (_place2_) {
      msg.place2 = protoscript.parseNumber(_place2_);
    }
    const _place3_ = json["place3"];
    if (_place3_) {
      msg.place3 = protoscript.parseNumber(_place3_);
    }
    const _place4_ = json["place4"];
    if (_place4_) {
      msg.place4 = protoscript.parseNumber(_place4_);
    }
    return msg;
  },
};

export const ComplexUmaJSON = {
  /**
   * Serializes ComplexUma to JSON.
   */
  encode: function (msg: PartialDeep<ComplexUma>): string {
    return JSON.stringify(ComplexUmaJSON._writeMessage(msg));
  },

  /**
   * Deserializes ComplexUma from JSON.
   */
  decode: function (json: string): ComplexUma {
    return ComplexUmaJSON._readMessage(
      ComplexUmaJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ComplexUma with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ComplexUma>): ComplexUma {
    return {
      neg1: UmaJSON.initialize(),
      neg3: UmaJSON.initialize(),
      otherwise: UmaJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ComplexUma>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.neg1) {
      const _neg1_ = UmaJSON._writeMessage(msg.neg1);
      if (Object.keys(_neg1_).length > 0) {
        json["neg1"] = _neg1_;
      }
    }
    if (msg.neg3) {
      const _neg3_ = UmaJSON._writeMessage(msg.neg3);
      if (Object.keys(_neg3_).length > 0) {
        json["neg3"] = _neg3_;
      }
    }
    if (msg.otherwise) {
      const _otherwise_ = UmaJSON._writeMessage(msg.otherwise);
      if (Object.keys(_otherwise_).length > 0) {
        json["otherwise"] = _otherwise_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ComplexUma, json: any): ComplexUma {
    const _neg1_ = json["neg1"];
    if (_neg1_) {
      UmaJSON._readMessage(msg.neg1, _neg1_);
    }
    const _neg3_ = json["neg3"];
    if (_neg3_) {
      UmaJSON._readMessage(msg.neg3, _neg3_);
    }
    const _otherwise_ = json["otherwise"];
    if (_otherwise_) {
      UmaJSON._readMessage(msg.otherwise, _otherwise_);
    }
    return msg;
  },
};

export const RulesetConfigJSON = {
  /**
   * Serializes RulesetConfig to JSON.
   */
  encode: function (msg: PartialDeep<RulesetConfig>): string {
    return JSON.stringify(RulesetConfigJSON._writeMessage(msg));
  },

  /**
   * Deserializes RulesetConfig from JSON.
   */
  decode: function (json: string): RulesetConfig {
    return RulesetConfigJSON._readMessage(
      RulesetConfigJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RulesetConfig with all fields set to their default value.
   */
  initialize: function (msg?: Partial<RulesetConfig>): RulesetConfig {
    return {
      complexUma: ComplexUmaJSON.initialize(),
      endingPolicy: EndingPolicy._fromInt(0),
      uma: UmaJSON.initialize(),
      umaType: UmaType._fromInt(0),
      doubleronHonbaAtamahane: false,
      doubleronRiichiAtamahane: false,
      equalizeUma: false,
      extraChomboPayments: false,
      playAdditionalRounds: false,
      riichiGoesToWinner: false,
      tonpuusen: false,
      withAbortives: false,
      withAtamahane: false,
      withButtobi: false,
      withKazoe: false,
      withKiriageMangan: false,
      withKuitan: false,
      withLeadingDealerGameOver: false,
      withMultiYakumans: false,
      withNagashiMangan: false,
      withWinningDealerHonbaSkipped: false,
      chipsValue: 0,
      chomboAmount: 0,
      gameExpirationTime: 0,
      goalPoints: 0,
      maxPenalty: 0,
      minPenalty: 0,
      oka: 0,
      penaltyStep: 0,
      replacementPlayerFixedPoints: 0,
      replacementPlayerOverrideUma: 0,
      startPoints: 0,
      startRating: 0,
      allowedYaku: [],
      yakuWithPao: [],
      withYakitori: false,
      yakitoriPenalty: 0,
      chomboEndsGame: false,
      honbaValue: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RulesetConfig>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.complexUma) {
      const _complexUma_ = ComplexUmaJSON._writeMessage(msg.complexUma);
      if (Object.keys(_complexUma_).length > 0) {
        json["complexUma"] = _complexUma_;
      }
    }
    if (msg.endingPolicy && EndingPolicyJSON._toInt(msg.endingPolicy)) {
      json["endingPolicy"] = msg.endingPolicy;
    }
    if (msg.uma) {
      const _uma_ = UmaJSON._writeMessage(msg.uma);
      if (Object.keys(_uma_).length > 0) {
        json["uma"] = _uma_;
      }
    }
    if (msg.umaType && UmaTypeJSON._toInt(msg.umaType)) {
      json["umaType"] = msg.umaType;
    }
    if (msg.doubleronHonbaAtamahane) {
      json["doubleronHonbaAtamahane"] = msg.doubleronHonbaAtamahane;
    }
    if (msg.doubleronRiichiAtamahane) {
      json["doubleronRiichiAtamahane"] = msg.doubleronRiichiAtamahane;
    }
    if (msg.equalizeUma) {
      json["equalizeUma"] = msg.equalizeUma;
    }
    if (msg.extraChomboPayments) {
      json["extraChomboPayments"] = msg.extraChomboPayments;
    }
    if (msg.playAdditionalRounds) {
      json["playAdditionalRounds"] = msg.playAdditionalRounds;
    }
    if (msg.riichiGoesToWinner) {
      json["riichiGoesToWinner"] = msg.riichiGoesToWinner;
    }
    if (msg.tonpuusen) {
      json["tonpuusen"] = msg.tonpuusen;
    }
    if (msg.withAbortives) {
      json["withAbortives"] = msg.withAbortives;
    }
    if (msg.withAtamahane) {
      json["withAtamahane"] = msg.withAtamahane;
    }
    if (msg.withButtobi) {
      json["withButtobi"] = msg.withButtobi;
    }
    if (msg.withKazoe) {
      json["withKazoe"] = msg.withKazoe;
    }
    if (msg.withKiriageMangan) {
      json["withKiriageMangan"] = msg.withKiriageMangan;
    }
    if (msg.withKuitan) {
      json["withKuitan"] = msg.withKuitan;
    }
    if (msg.withLeadingDealerGameOver) {
      json["withLeadingDealerGameOver"] = msg.withLeadingDealerGameOver;
    }
    if (msg.withMultiYakumans) {
      json["withMultiYakumans"] = msg.withMultiYakumans;
    }
    if (msg.withNagashiMangan) {
      json["withNagashiMangan"] = msg.withNagashiMangan;
    }
    if (msg.withWinningDealerHonbaSkipped) {
      json["withWinningDealerHonbaSkipped"] = msg.withWinningDealerHonbaSkipped;
    }
    if (msg.chipsValue) {
      json["chipsValue"] = msg.chipsValue;
    }
    if (msg.chomboAmount) {
      json["chomboAmount"] = msg.chomboAmount;
    }
    if (msg.gameExpirationTime) {
      json["gameExpirationTime"] = msg.gameExpirationTime;
    }
    if (msg.goalPoints) {
      json["goalPoints"] = msg.goalPoints;
    }
    if (msg.maxPenalty) {
      json["maxPenalty"] = msg.maxPenalty;
    }
    if (msg.minPenalty) {
      json["minPenalty"] = msg.minPenalty;
    }
    if (msg.oka) {
      json["oka"] = msg.oka;
    }
    if (msg.penaltyStep) {
      json["penaltyStep"] = msg.penaltyStep;
    }
    if (msg.replacementPlayerFixedPoints) {
      json["replacementPlayerFixedPoints"] = msg.replacementPlayerFixedPoints;
    }
    if (msg.replacementPlayerOverrideUma) {
      json["replacementPlayerOverrideUma"] = msg.replacementPlayerOverrideUma;
    }
    if (msg.startPoints) {
      json["startPoints"] = msg.startPoints;
    }
    if (msg.startRating) {
      json["startRating"] = msg.startRating;
    }
    if (msg.allowedYaku?.length) {
      json["allowedYaku"] = msg.allowedYaku;
    }
    if (msg.yakuWithPao?.length) {
      json["yakuWithPao"] = msg.yakuWithPao;
    }
    if (msg.withYakitori) {
      json["withYakitori"] = msg.withYakitori;
    }
    if (msg.yakitoriPenalty) {
      json["yakitoriPenalty"] = msg.yakitoriPenalty;
    }
    if (msg.chomboEndsGame) {
      json["chomboEndsGame"] = msg.chomboEndsGame;
    }
    if (msg.honbaValue) {
      json["honbaValue"] = msg.honbaValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: RulesetConfig, json: any): RulesetConfig {
    const _complexUma_ = json["complexUma"] ?? json["complex_uma"];
    if (_complexUma_) {
      ComplexUmaJSON._readMessage(msg.complexUma, _complexUma_);
    }
    const _endingPolicy_ = json["endingPolicy"] ?? json["ending_policy"];
    if (_endingPolicy_) {
      msg.endingPolicy = EndingPolicy._fromInt(_endingPolicy_);
    }
    const _uma_ = json["uma"];
    if (_uma_) {
      UmaJSON._readMessage(msg.uma, _uma_);
    }
    const _umaType_ = json["umaType"] ?? json["uma_type"];
    if (_umaType_) {
      msg.umaType = UmaType._fromInt(_umaType_);
    }
    const _doubleronHonbaAtamahane_ =
      json["doubleronHonbaAtamahane"] ?? json["doubleron_honba_atamahane"];
    if (_doubleronHonbaAtamahane_) {
      msg.doubleronHonbaAtamahane = _doubleronHonbaAtamahane_;
    }
    const _doubleronRiichiAtamahane_ =
      json["doubleronRiichiAtamahane"] ?? json["doubleron_riichi_atamahane"];
    if (_doubleronRiichiAtamahane_) {
      msg.doubleronRiichiAtamahane = _doubleronRiichiAtamahane_;
    }
    const _equalizeUma_ = json["equalizeUma"] ?? json["equalize_uma"];
    if (_equalizeUma_) {
      msg.equalizeUma = _equalizeUma_;
    }
    const _extraChomboPayments_ =
      json["extraChomboPayments"] ?? json["extra_chombo_payments"];
    if (_extraChomboPayments_) {
      msg.extraChomboPayments = _extraChomboPayments_;
    }
    const _playAdditionalRounds_ =
      json["playAdditionalRounds"] ?? json["play_additional_rounds"];
    if (_playAdditionalRounds_) {
      msg.playAdditionalRounds = _playAdditionalRounds_;
    }
    const _riichiGoesToWinner_ =
      json["riichiGoesToWinner"] ?? json["riichi_goes_to_winner"];
    if (_riichiGoesToWinner_) {
      msg.riichiGoesToWinner = _riichiGoesToWinner_;
    }
    const _tonpuusen_ = json["tonpuusen"];
    if (_tonpuusen_) {
      msg.tonpuusen = _tonpuusen_;
    }
    const _withAbortives_ = json["withAbortives"] ?? json["with_abortives"];
    if (_withAbortives_) {
      msg.withAbortives = _withAbortives_;
    }
    const _withAtamahane_ = json["withAtamahane"] ?? json["with_atamahane"];
    if (_withAtamahane_) {
      msg.withAtamahane = _withAtamahane_;
    }
    const _withButtobi_ = json["withButtobi"] ?? json["with_buttobi"];
    if (_withButtobi_) {
      msg.withButtobi = _withButtobi_;
    }
    const _withKazoe_ = json["withKazoe"] ?? json["with_kazoe"];
    if (_withKazoe_) {
      msg.withKazoe = _withKazoe_;
    }
    const _withKiriageMangan_ =
      json["withKiriageMangan"] ?? json["with_kiriage_mangan"];
    if (_withKiriageMangan_) {
      msg.withKiriageMangan = _withKiriageMangan_;
    }
    const _withKuitan_ = json["withKuitan"] ?? json["with_kuitan"];
    if (_withKuitan_) {
      msg.withKuitan = _withKuitan_;
    }
    const _withLeadingDealerGameOver_ =
      json["withLeadingDealerGameOver"] ??
      json["with_leading_dealer_game_over"];
    if (_withLeadingDealerGameOver_) {
      msg.withLeadingDealerGameOver = _withLeadingDealerGameOver_;
    }
    const _withMultiYakumans_ =
      json["withMultiYakumans"] ?? json["with_multi_yakumans"];
    if (_withMultiYakumans_) {
      msg.withMultiYakumans = _withMultiYakumans_;
    }
    const _withNagashiMangan_ =
      json["withNagashiMangan"] ?? json["with_nagashi_mangan"];
    if (_withNagashiMangan_) {
      msg.withNagashiMangan = _withNagashiMangan_;
    }
    const _withWinningDealerHonbaSkipped_ =
      json["withWinningDealerHonbaSkipped"] ??
      json["with_winning_dealer_honba_skipped"];
    if (_withWinningDealerHonbaSkipped_) {
      msg.withWinningDealerHonbaSkipped = _withWinningDealerHonbaSkipped_;
    }
    const _chipsValue_ = json["chipsValue"] ?? json["chips_value"];
    if (_chipsValue_) {
      msg.chipsValue = protoscript.parseNumber(_chipsValue_);
    }
    const _chomboAmount_ = json["chomboAmount"] ?? json["chombo_amount"];
    if (_chomboAmount_) {
      msg.chomboAmount = protoscript.parseNumber(_chomboAmount_);
    }
    const _gameExpirationTime_ =
      json["gameExpirationTime"] ?? json["game_expiration_time"];
    if (_gameExpirationTime_) {
      msg.gameExpirationTime = protoscript.parseNumber(_gameExpirationTime_);
    }
    const _goalPoints_ = json["goalPoints"] ?? json["goal_points"];
    if (_goalPoints_) {
      msg.goalPoints = protoscript.parseNumber(_goalPoints_);
    }
    const _maxPenalty_ = json["maxPenalty"] ?? json["max_penalty"];
    if (_maxPenalty_) {
      msg.maxPenalty = protoscript.parseNumber(_maxPenalty_);
    }
    const _minPenalty_ = json["minPenalty"] ?? json["min_penalty"];
    if (_minPenalty_) {
      msg.minPenalty = protoscript.parseNumber(_minPenalty_);
    }
    const _oka_ = json["oka"];
    if (_oka_) {
      msg.oka = protoscript.parseNumber(_oka_);
    }
    const _penaltyStep_ = json["penaltyStep"] ?? json["penalty_step"];
    if (_penaltyStep_) {
      msg.penaltyStep = protoscript.parseNumber(_penaltyStep_);
    }
    const _replacementPlayerFixedPoints_ =
      json["replacementPlayerFixedPoints"] ??
      json["replacement_player_fixed_points"];
    if (_replacementPlayerFixedPoints_) {
      msg.replacementPlayerFixedPoints = protoscript.parseNumber(
        _replacementPlayerFixedPoints_,
      );
    }
    const _replacementPlayerOverrideUma_ =
      json["replacementPlayerOverrideUma"] ??
      json["replacement_player_override_uma"];
    if (_replacementPlayerOverrideUma_) {
      msg.replacementPlayerOverrideUma = protoscript.parseNumber(
        _replacementPlayerOverrideUma_,
      );
    }
    const _startPoints_ = json["startPoints"] ?? json["start_points"];
    if (_startPoints_) {
      msg.startPoints = protoscript.parseNumber(_startPoints_);
    }
    const _startRating_ = json["startRating"] ?? json["start_rating"];
    if (_startRating_) {
      msg.startRating = protoscript.parseNumber(_startRating_);
    }
    const _allowedYaku_ = json["allowedYaku"] ?? json["allowed_yaku"];
    if (_allowedYaku_) {
      msg.allowedYaku = _allowedYaku_.map(protoscript.parseNumber);
    }
    const _yakuWithPao_ = json["yakuWithPao"] ?? json["yaku_with_pao"];
    if (_yakuWithPao_) {
      msg.yakuWithPao = _yakuWithPao_.map(protoscript.parseNumber);
    }
    const _withYakitori_ = json["withYakitori"] ?? json["with_yakitori"];
    if (_withYakitori_) {
      msg.withYakitori = _withYakitori_;
    }
    const _yakitoriPenalty_ =
      json["yakitoriPenalty"] ?? json["yakitori_penalty"];
    if (_yakitoriPenalty_) {
      msg.yakitoriPenalty = protoscript.parseNumber(_yakitoriPenalty_);
    }
    const _chomboEndsGame_ = json["chomboEndsGame"] ?? json["chombo_ends_game"];
    if (_chomboEndsGame_) {
      msg.chomboEndsGame = _chomboEndsGame_;
    }
    const _honbaValue_ = json["honbaValue"] ?? json["honba_value"];
    if (_honbaValue_) {
      msg.honbaValue = protoscript.parseNumber(_honbaValue_);
    }
    return msg;
  },
};

export const GenericSuccessResponseJSON = {
  /**
   * Serializes GenericSuccessResponse to JSON.
   */
  encode: function (msg: PartialDeep<GenericSuccessResponse>): string {
    return JSON.stringify(GenericSuccessResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GenericSuccessResponse from JSON.
   */
  decode: function (json: string): GenericSuccessResponse {
    return GenericSuccessResponseJSON._readMessage(
      GenericSuccessResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GenericSuccessResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericSuccessResponse>,
  ): GenericSuccessResponse {
    return {
      success: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericSuccessResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.success) {
      json["success"] = msg.success;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericSuccessResponse,
    json: any,
  ): GenericSuccessResponse {
    const _success_ = json["success"];
    if (_success_) {
      msg.success = _success_;
    }
    return msg;
  },
};

export const GenericEventPayloadJSON = {
  /**
   * Serializes GenericEventPayload to JSON.
   */
  encode: function (msg: PartialDeep<GenericEventPayload>): string {
    return JSON.stringify(GenericEventPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GenericEventPayload from JSON.
   */
  decode: function (json: string): GenericEventPayload {
    return GenericEventPayloadJSON._readMessage(
      GenericEventPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GenericEventPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericEventPayload>,
  ): GenericEventPayload {
    return {
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericEventPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericEventPayload,
    json: any,
  ): GenericEventPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const GenericSessionPayloadJSON = {
  /**
   * Serializes GenericSessionPayload to JSON.
   */
  encode: function (msg: PartialDeep<GenericSessionPayload>): string {
    return JSON.stringify(GenericSessionPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GenericSessionPayload from JSON.
   */
  decode: function (json: string): GenericSessionPayload {
    return GenericSessionPayloadJSON._readMessage(
      GenericSessionPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GenericSessionPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GenericSessionPayload>,
  ): GenericSessionPayload {
    return {
      sessionHash: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GenericSessionPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GenericSessionPayload,
    json: any,
  ): GenericSessionPayload {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    return msg;
  },
};
