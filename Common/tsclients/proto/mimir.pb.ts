// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: proto/mimir.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as protoAtoms from "./atoms.pb";

//========================================//
//                 Types                  //
//========================================//

export interface EventsGetRulesetsPayload {}

export interface EventsGetRulesetsResponse {
  rulesets: protoAtoms.RulesetConfig[];
  rulesetIds: string[];
  rulesetTitles: string[];
}

export interface EventsGetTimezonesPayload {
  addr: string;
}

export interface EventsGetTimezonesResponse {
  preferredByIp: string;
  timezones: string[];
}

export interface EventsGetCountriesPayload {
  addr: string;
}

export interface EventsGetCountriesResponse {
  preferredByIp: string;
  countries: protoAtoms.Country[];
}

export interface EventsGetEventsPayload {
  limit: number;
  offset: number;
  filterUnlisted: boolean;
  filter: string;
}

export interface EventsGetEventsResponse {
  total: number;
  events: protoAtoms.Event[];
}

export interface EventsGetEventsByIdPayload {
  ids: number[];
}

export interface EventsGetEventsByIdResponse {
  events: protoAtoms.Event[];
}

export interface PlayersGetMyEventsPayload {}

export interface PlayersGetMyEventsResponse {
  events: protoAtoms.MyEvent[];
}

export interface EventsGetRatingTablePayload {
  eventIdList: number[];
  orderBy: string;
  order: string;
  /**
   * @deprecated
   */
  withPrefinished?: boolean | null | undefined;
  onlyMinGames?: boolean | null | undefined;
}

export interface EventsGetRatingTableResponse {
  list: protoAtoms.PlayerInRating[];
}

export interface EventsGetLastGamesPayload {
  eventIdList: number[];
  limit: number;
  offset: number;
  orderBy?: string | null | undefined;
  order?: string | null | undefined;
}

export interface EventsGetLastGamesResponse {
  games: protoAtoms.GameResult[];
  players: protoAtoms.Player[];
  totalGames: number;
}

export interface EventsGetGameResponse {
  game: protoAtoms.GameResult;
  players: protoAtoms.Player[];
}

export interface EventsGetGamesSeriesResponse {
  results: protoAtoms.SeriesResult[];
}

export interface PlayersGetCurrentSessionsPayload {
  playerId: number;
  eventId: number;
}

export interface CurrentSession {
  sessionHash: string;
  status: string;
  tableIndex?: number | null | undefined;
  players: protoAtoms.PlayerInSession[];
  timerState: EventsGetTimerStateResponse;
}

export interface PlayersGetCurrentSessionsResponse {
  sessions: CurrentSession[];
}

export interface EventsGetAllRegisteredPlayersPayload {
  eventIds: number[];
}

export interface EventsGetAllRegisteredPlayersResponse {
  players: protoAtoms.RegisteredPlayer[];
}

export interface EventsGetTimerStateResponse {
  started: boolean;
  finished: boolean;
  timeRemaining: number;
  waitingForTimer: boolean;
  haveAutostart: boolean;
  autostartTimer: boolean;
  hideSeatingAfter: number;
}

export interface GamesGetSessionOverviewResponse {
  id: number;
  eventId: number;
  tableIndex?: number | null | undefined;
  players: protoAtoms.PlayerInSession[];
  state: protoAtoms.SessionState;
  timerState: EventsGetTimerStateResponse;
}

export interface PlayersGetPlayerStatsPayload {
  playerId: number;
  eventIdList: number[];
}

export interface PlayersGetPlayerStatsResponse {
  ratingHistory: number[];
  scoreHistory: protoAtoms.SessionHistoryResultTable[];
  playersInfo: protoAtoms.Player[];
  placesSummary: protoAtoms.PlacesSummaryItem[];
  totalPlayedGames: number;
  totalPlayedRounds: number;
  winSummary: protoAtoms.PlayerWinSummary;
  handsValueSummary: protoAtoms.HandValueStat[];
  yakuSummary: protoAtoms.YakuStat[];
  riichiSummary: protoAtoms.RiichiSummary;
  doraStat: protoAtoms.DoraSummary;
  lastUpdate: string;
}

export interface GamesAddRoundPayload {
  sessionHash: string;
  roundData: protoAtoms.Round;
}

export interface GamesAddRoundResponse {
  scores: protoAtoms.IntermediateResultOfSession[];
  /**
   * current round number
   */
  round: number;
  honba: number;
  /**
   * on the table from previous round
   */
  riichiBets: number;
  /**
   * if game has been finished prematurely (e.g. by timeout)
   */
  prematurelyFinished: boolean;
  /**
   * True if round has just changed useful to determine if current
   * 4e or 4s is first one, no matter what honba count is. (Possible
   * situation: draw in 3s or 3e, so first 4e or 4s has honba).
   */
  roundJustChanged: boolean;
  isFinished: boolean;
  /**
   * True if ending policy is "oneMoreHand" AND this hand was started.
   */
  lastHandStarted: boolean;
  /**
   * Outcome of previously recorded round. Useful to determine if
   * certain rules should be applied in current case, e.g., agariyame
   * should not be applied on chombo or abortive draw.
   */
  lastOutcome?: protoAtoms.RoundOutcome | null | undefined;
}

export interface GamesPreviewRoundPayload {
  sessionHash: string;
  roundData: protoAtoms.Round;
}

export interface GamesPreviewRoundResponse {
  state: protoAtoms.RoundState;
}

export interface GamesAddOnlineReplayPayload {
  eventId: number;
  link: string;
}

export interface GamesAddOnlineReplayResponse {
  game: protoAtoms.GameResult;
  players: protoAtoms.Player[];
}

export interface PlayersGetLastResultsPayload {
  playerId: number;
  eventId: number;
}

export interface PlayersGetLastResultsResponse {
  results: protoAtoms.SessionHistoryResult[];
}

export interface PlayersGetLastRoundPayload {
  playerId: number;
  eventId: number;
}

export interface PlayersGetLastRoundResponse {
  round: protoAtoms.RoundState;
}

export interface PlayersGetAllRoundsResponse {
  rounds: protoAtoms.RoundState[];
}

export interface PlayersGetLastRoundByHashResponse {
  round: protoAtoms.RoundState;
}

export interface EventsGetEventForEditPayload {
  id: number;
}

export interface EventsGetEventForEditResponse {
  id: number;
  event: protoAtoms.EventData;
  finished: boolean;
}

export interface EventsUpdateEventPayload {
  id: number;
  event: protoAtoms.EventData;
}

export interface EventsGetTablesStatePayload {
  eventId: number;
  omitLastRound: boolean;
}

export interface EventsGetTablesStateResponse {
  tables: protoAtoms.TableState[];
}

export interface EventsRegisterPlayerPayload {
  playerId: number;
  eventId: number;
}

export interface EventsUnregisterPlayerPayload {
  playerId: number;
  eventId: number;
}

export interface EventsUpdatePlayerSeatingFlagPayload {
  playerId: number;
  eventId: number;
  ignoreSeating: boolean;
}

export interface EventsGetAchievementsPayload {
  achievementsList: string[];
  eventId: number;
}

export interface EventsGetAchievementsResponse {
  achievements: protoAtoms.Achievement[];
  lastUpdate: string;
}

export interface EventsUpdatePlayersLocalIdsPayload {
  eventId: number;
  idsToLocalIds: protoAtoms.LocalIdMapping[];
}

export interface EventsUpdatePlayerReplacementPayload {
  playerId: number;
  eventId: number;
  replacementId: number;
}

export interface EventsUpdatePlayersTeamsPayload {
  eventId: number;
  idsToTeamNames: protoAtoms.TeamMapping[];
}

export interface GamesStartGamePayload {
  eventId: number;
  players: number[];
}

export interface GamesDropLastRoundPayload {
  sessionHash: string;
  intermediateResults: protoAtoms.IntermediateResultOfSession[];
}

export interface GamesAddPenaltyPayload {
  eventId: number;
  playerId: number;
  amount: number;
  reason: string;
}

export interface GamesAddPenaltyGamePayload {
  eventId: number;
  players: number[];
}

export interface PlayersGetPlayerPayload {
  id: number;
}

export interface PlayersGetPlayerResponse {
  players: protoAtoms.Player;
}

export interface EventsGetCurrentSeatingResponse {
  seating: protoAtoms.PlayerSeating[];
}

export interface SeatingMakeShuffledSeatingPayload {
  eventId: number;
  groupsCount: number;
  seed: number;
}

export interface SeatingGenerateSwissSeatingPayload {
  eventId: number;
  substituteReplacementPlayers: boolean;
}

export interface SeatingGenerateSwissSeatingResponse {
  tables: protoAtoms.TableItemSwiss[];
}

export interface SeatingMakeIntervalSeatingPayload {
  eventId: number;
  step: number;
}

export interface SeatingMakePrescriptedSeatingPayload {
  eventId: number;
  randomizeAtTables: boolean;
}

export interface SeatingGetNextPrescriptedSeatingResponse {
  tables: protoAtoms.PrescriptedTable[];
}

export interface EventsGetPrescriptedEventConfigResponse {
  eventId: number;
  nextSessionIndex: number;
  prescript?: string | null | undefined;
  errors: string[];
}

export interface EventsUpdatePrescriptedEventConfigPayload {
  eventId: number;
  nextSessionIndex: number;
  prescript: string;
}

export interface EventsGetStartingTimerResponse {
  timer: number;
}

export interface ClearStatCachePayload {
  playerId: number;
}

export interface TypedGamesAddOnlineReplayPayload {
  eventId: number;
  platformId: number;
  contentType: number;
  logTimestamp: number;
  replayHash: string;
  content: string;
}

export interface CallRefereePayload {
  tableIndex: number;
  eventId: number;
}

export interface PenaltiesResponse {
  penalties: protoAtoms.Penalty[];
  referees: protoAtoms.Player[];
}

export interface CancelPenaltyPayload {
  penaltyId: number;
  reason?: string | null | undefined;
}

export interface AddExtraTimePayload {
  sessionHashList: string[];
  extraTime: number;
}

export interface GetCurrentStatePayload {
  eventId: number;
  playerId: number;
}

export interface GetCurrentStateResponse {
  sessions: CurrentSession[];
  config: protoAtoms.GameConfig;
}

export interface ChomboResponse {
  chombos: protoAtoms.Chombo[];
  players: protoAtoms.Player[];
}

//========================================//
//         Mimir Protobuf Client          //
//========================================//

export async function GetRulesets(
  eventsGetRulesetsPayload: EventsGetRulesetsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetRulesetsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetRulesets",
    EventsGetRulesetsPayload.encode(eventsGetRulesetsPayload),
    config,
  );
  return EventsGetRulesetsResponse.decode(response);
}

export async function GetTimezones(
  eventsGetTimezonesPayload: EventsGetTimezonesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetTimezonesResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetTimezones",
    EventsGetTimezonesPayload.encode(eventsGetTimezonesPayload),
    config,
  );
  return EventsGetTimezonesResponse.decode(response);
}

export async function GetCountries(
  eventsGetCountriesPayload: EventsGetCountriesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetCountriesResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetCountries",
    EventsGetCountriesPayload.encode(eventsGetCountriesPayload),
    config,
  );
  return EventsGetCountriesResponse.decode(response);
}

export async function GetEvents(
  eventsGetEventsPayload: EventsGetEventsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetEvents",
    EventsGetEventsPayload.encode(eventsGetEventsPayload),
    config,
  );
  return EventsGetEventsResponse.decode(response);
}

export async function GetEventsById(
  eventsGetEventsByIdPayload: EventsGetEventsByIdPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventsByIdResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetEventsById",
    EventsGetEventsByIdPayload.encode(eventsGetEventsByIdPayload),
    config,
  );
  return EventsGetEventsByIdResponse.decode(response);
}

export async function GetMyEvents(
  playersGetMyEventsPayload: PlayersGetMyEventsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetMyEventsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetMyEvents",
    PlayersGetMyEventsPayload.encode(playersGetMyEventsPayload),
    config,
  );
  return PlayersGetMyEventsResponse.decode(response);
}

export async function GetGameConfig(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GameConfig> {
  const response = await PBrequest(
    "/common.Mimir/GetGameConfig",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GameConfig.decode(response);
}

export async function GetRatingTable(
  eventsGetRatingTablePayload: EventsGetRatingTablePayload,
  config?: ClientConfiguration,
): Promise<EventsGetRatingTableResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetRatingTable",
    EventsGetRatingTablePayload.encode(eventsGetRatingTablePayload),
    config,
  );
  return EventsGetRatingTableResponse.decode(response);
}

export async function GetLastGames(
  eventsGetLastGamesPayload: EventsGetLastGamesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetLastGamesResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetLastGames",
    EventsGetLastGamesPayload.encode(eventsGetLastGamesPayload),
    config,
  );
  return EventsGetLastGamesResponse.decode(response);
}

export async function GetGame(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<EventsGetGameResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetGame",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return EventsGetGameResponse.decode(response);
}

export async function GetGamesSeries(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetGamesSeriesResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetGamesSeries",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return EventsGetGamesSeriesResponse.decode(response);
}

export async function GetCurrentSessions(
  playersGetCurrentSessionsPayload: PlayersGetCurrentSessionsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetCurrentSessionsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetCurrentSessions",
    PlayersGetCurrentSessionsPayload.encode(playersGetCurrentSessionsPayload),
    config,
  );
  return PlayersGetCurrentSessionsResponse.decode(response);
}

export async function GetAllRegisteredPlayers(
  eventsGetAllRegisteredPlayersPayload: EventsGetAllRegisteredPlayersPayload,
  config?: ClientConfiguration,
): Promise<EventsGetAllRegisteredPlayersResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetAllRegisteredPlayers",
    EventsGetAllRegisteredPlayersPayload.encode(
      eventsGetAllRegisteredPlayersPayload,
    ),
    config,
  );
  return EventsGetAllRegisteredPlayersResponse.decode(response);
}

export async function GetTimerState(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetTimerStateResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetTimerState",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return EventsGetTimerStateResponse.decode(response);
}

export async function GetSessionOverview(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<GamesGetSessionOverviewResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetSessionOverview",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return GamesGetSessionOverviewResponse.decode(response);
}

export async function GetPlayerStats(
  playersGetPlayerStatsPayload: PlayersGetPlayerStatsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetPlayerStatsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetPlayerStats",
    PlayersGetPlayerStatsPayload.encode(playersGetPlayerStatsPayload),
    config,
  );
  return PlayersGetPlayerStatsResponse.decode(response);
}

export async function AddRound(
  gamesAddRoundPayload: GamesAddRoundPayload,
  config?: ClientConfiguration,
): Promise<GamesAddRoundResponse> {
  const response = await PBrequest(
    "/common.Mimir/AddRound",
    GamesAddRoundPayload.encode(gamesAddRoundPayload),
    config,
  );
  return GamesAddRoundResponse.decode(response);
}

export async function PreviewRound(
  gamesPreviewRoundPayload: GamesPreviewRoundPayload,
  config?: ClientConfiguration,
): Promise<GamesPreviewRoundResponse> {
  const response = await PBrequest(
    "/common.Mimir/PreviewRound",
    GamesPreviewRoundPayload.encode(gamesPreviewRoundPayload),
    config,
  );
  return GamesPreviewRoundResponse.decode(response);
}

export async function AddOnlineReplay(
  gamesAddOnlineReplayPayload: GamesAddOnlineReplayPayload,
  config?: ClientConfiguration,
): Promise<GamesAddOnlineReplayResponse> {
  const response = await PBrequest(
    "/common.Mimir/AddOnlineReplay",
    GamesAddOnlineReplayPayload.encode(gamesAddOnlineReplayPayload),
    config,
  );
  return GamesAddOnlineReplayResponse.decode(response);
}

export async function GetLastResults(
  playersGetLastResultsPayload: PlayersGetLastResultsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastResultsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetLastResults",
    PlayersGetLastResultsPayload.encode(playersGetLastResultsPayload),
    config,
  );
  return PlayersGetLastResultsResponse.decode(response);
}

export async function GetLastRound(
  playersGetLastRoundPayload: PlayersGetLastRoundPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastRoundResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetLastRound",
    PlayersGetLastRoundPayload.encode(playersGetLastRoundPayload),
    config,
  );
  return PlayersGetLastRoundResponse.decode(response);
}

export async function GetAllRounds(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetAllRoundsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetAllRounds",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return PlayersGetAllRoundsResponse.decode(response);
}

export async function GetLastRoundByHash(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastRoundByHashResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetLastRoundByHash",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return PlayersGetLastRoundByHashResponse.decode(response);
}

export async function GetEventForEdit(
  eventsGetEventForEditPayload: EventsGetEventForEditPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventForEditResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetEventForEdit",
    EventsGetEventForEditPayload.encode(eventsGetEventForEditPayload),
    config,
  );
  return EventsGetEventForEditResponse.decode(response);
}

export async function RebuildScoring(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/RebuildScoring",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function CreateEvent(
  eventData: protoAtoms.EventData,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericEventPayload> {
  const response = await PBrequest(
    "/common.Mimir/CreateEvent",
    protoAtoms.EventData.encode(eventData),
    config,
  );
  return protoAtoms.GenericEventPayload.decode(response);
}

export async function UpdateEvent(
  eventsUpdateEventPayload: EventsUpdateEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdateEvent",
    EventsUpdateEventPayload.encode(eventsUpdateEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function FinishEvent(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/FinishEvent",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ToggleListed(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ToggleListed",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function GetTablesState(
  eventsGetTablesStatePayload: EventsGetTablesStatePayload,
  config?: ClientConfiguration,
): Promise<EventsGetTablesStateResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetTablesState",
    EventsGetTablesStatePayload.encode(eventsGetTablesStatePayload),
    config,
  );
  return EventsGetTablesStateResponse.decode(response);
}

export async function StartTimer(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/StartTimer",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function RegisterPlayer(
  eventsRegisterPlayerPayload: EventsRegisterPlayerPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/RegisterPlayer",
    EventsRegisterPlayerPayload.encode(eventsRegisterPlayerPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function UnregisterPlayer(
  eventsUnregisterPlayerPayload: EventsUnregisterPlayerPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UnregisterPlayer",
    EventsUnregisterPlayerPayload.encode(eventsUnregisterPlayerPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function UpdatePlayerSeatingFlag(
  eventsUpdatePlayerSeatingFlagPayload: EventsUpdatePlayerSeatingFlagPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdatePlayerSeatingFlag",
    EventsUpdatePlayerSeatingFlagPayload.encode(
      eventsUpdatePlayerSeatingFlagPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function GetAchievements(
  eventsGetAchievementsPayload: EventsGetAchievementsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetAchievementsResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetAchievements",
    EventsGetAchievementsPayload.encode(eventsGetAchievementsPayload),
    config,
  );
  return EventsGetAchievementsResponse.decode(response);
}

export async function ToggleHideResults(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ToggleHideResults",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ToggleHideAchievements(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ToggleHideAchievements",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function UpdatePlayersLocalIds(
  eventsUpdatePlayersLocalIdsPayload: EventsUpdatePlayersLocalIdsPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdatePlayersLocalIds",
    EventsUpdatePlayersLocalIdsPayload.encode(
      eventsUpdatePlayersLocalIdsPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function UpdatePlayerReplacement(
  eventsUpdatePlayerReplacementPayload: EventsUpdatePlayerReplacementPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdatePlayerReplacement",
    EventsUpdatePlayerReplacementPayload.encode(
      eventsUpdatePlayerReplacementPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function UpdatePlayersTeams(
  eventsUpdatePlayersTeamsPayload: EventsUpdatePlayersTeamsPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdatePlayersTeams",
    EventsUpdatePlayersTeamsPayload.encode(eventsUpdatePlayersTeamsPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function StartGame(
  gamesStartGamePayload: GamesStartGamePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSessionPayload> {
  const response = await PBrequest(
    "/common.Mimir/StartGame",
    GamesStartGamePayload.encode(gamesStartGamePayload),
    config,
  );
  return protoAtoms.GenericSessionPayload.decode(response);
}

export async function EndGame(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/EndGame",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function CancelGame(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/CancelGame",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function FinalizeSession(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/FinalizeSession",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function DropLastRound(
  gamesDropLastRoundPayload: GamesDropLastRoundPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/DropLastRound",
    GamesDropLastRoundPayload.encode(gamesDropLastRoundPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function DefinalizeGame(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/DefinalizeGame",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function AddPenalty(
  gamesAddPenaltyPayload: GamesAddPenaltyPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/AddPenalty",
    GamesAddPenaltyPayload.encode(gamesAddPenaltyPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function AddPenaltyGame(
  gamesAddPenaltyGamePayload: GamesAddPenaltyGamePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSessionPayload> {
  const response = await PBrequest(
    "/common.Mimir/AddPenaltyGame",
    GamesAddPenaltyGamePayload.encode(gamesAddPenaltyGamePayload),
    config,
  );
  return protoAtoms.GenericSessionPayload.decode(response);
}

export async function GetPlayer(
  playersGetPlayerPayload: PlayersGetPlayerPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetPlayerResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetPlayer",
    PlayersGetPlayerPayload.encode(playersGetPlayerPayload),
    config,
  );
  return PlayersGetPlayerResponse.decode(response);
}

export async function GetCurrentSeating(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetCurrentSeatingResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetCurrentSeating",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return EventsGetCurrentSeatingResponse.decode(response);
}

export async function MakeShuffledSeating(
  seatingMakeShuffledSeatingPayload: SeatingMakeShuffledSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/MakeShuffledSeating",
    SeatingMakeShuffledSeatingPayload.encode(seatingMakeShuffledSeatingPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function MakeSwissSeating(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/MakeSwissSeating",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ResetSeating(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ResetSeating",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function GenerateSwissSeating(
  seatingGenerateSwissSeatingPayload: SeatingGenerateSwissSeatingPayload,
  config?: ClientConfiguration,
): Promise<SeatingGenerateSwissSeatingResponse> {
  const response = await PBrequest(
    "/common.Mimir/GenerateSwissSeating",
    SeatingGenerateSwissSeatingPayload.encode(
      seatingGenerateSwissSeatingPayload,
    ),
    config,
  );
  return SeatingGenerateSwissSeatingResponse.decode(response);
}

export async function MakeIntervalSeating(
  seatingMakeIntervalSeatingPayload: SeatingMakeIntervalSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/MakeIntervalSeating",
    SeatingMakeIntervalSeatingPayload.encode(seatingMakeIntervalSeatingPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function MakePrescriptedSeating(
  seatingMakePrescriptedSeatingPayload: SeatingMakePrescriptedSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/MakePrescriptedSeating",
    SeatingMakePrescriptedSeatingPayload.encode(
      seatingMakePrescriptedSeatingPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function GetNextPrescriptedSeating(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<SeatingGetNextPrescriptedSeatingResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetNextPrescriptedSeating",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return SeatingGetNextPrescriptedSeatingResponse.decode(response);
}

export async function GetPrescriptedEventConfig(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetPrescriptedEventConfigResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetPrescriptedEventConfig",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return EventsGetPrescriptedEventConfigResponse.decode(response);
}

export async function UpdatePrescriptedEventConfig(
  eventsUpdatePrescriptedEventConfigPayload: EventsUpdatePrescriptedEventConfigPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/UpdatePrescriptedEventConfig",
    EventsUpdatePrescriptedEventConfigPayload.encode(
      eventsUpdatePrescriptedEventConfigPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function InitStartingTimer(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/InitStartingTimer",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function GetStartingTimer(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetStartingTimerResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetStartingTimer",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return EventsGetStartingTimerResponse.decode(response);
}

export async function ClearStatCache(
  clearStatCachePayload: ClearStatCachePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ClearStatCache",
    ClearStatCachePayload.encode(clearStatCachePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ForceFinishGame(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/ForceFinishGame",
    protoAtoms.GenericSessionPayload.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function AddTypedOnlineReplay(
  typedGamesAddOnlineReplayPayload: TypedGamesAddOnlineReplayPayload,
  config?: ClientConfiguration,
): Promise<GamesAddOnlineReplayResponse> {
  const response = await PBrequest(
    "/common.Mimir/AddTypedOnlineReplay",
    TypedGamesAddOnlineReplayPayload.encode(typedGamesAddOnlineReplayPayload),
    config,
  );
  return GamesAddOnlineReplayResponse.decode(response);
}

export async function NotifyPlayersSessionStartsSoon(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/NotifyPlayersSessionStartsSoon",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function CallReferee(
  callRefereePayload: CallRefereePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/CallReferee",
    CallRefereePayload.encode(callRefereePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function RecalcAchievements(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/RecalcAchievements",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function RecalcPlayerStats(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/RecalcPlayerStats",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ListPenalties(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<PenaltiesResponse> {
  const response = await PBrequest(
    "/common.Mimir/ListPenalties",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return PenaltiesResponse.decode(response);
}

export async function CancelPenalty(
  cancelPenaltyPayload: CancelPenaltyPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/CancelPenalty",
    CancelPenaltyPayload.encode(cancelPenaltyPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function AddExtraTime(
  addExtraTimePayload: AddExtraTimePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await PBrequest(
    "/common.Mimir/AddExtraTime",
    AddExtraTimePayload.encode(addExtraTimePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponse.decode(response);
}

export async function ListMyPenalties(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<PenaltiesResponse> {
  const response = await PBrequest(
    "/common.Mimir/ListMyPenalties",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return PenaltiesResponse.decode(response);
}

export async function ListChombo(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<ChomboResponse> {
  const response = await PBrequest(
    "/common.Mimir/ListChombo",
    protoAtoms.GenericEventPayload.encode(genericEventPayload),
    config,
  );
  return ChomboResponse.decode(response);
}

export async function GetCurrentStateForPlayer(
  getCurrentStatePayload: GetCurrentStatePayload,
  config?: ClientConfiguration,
): Promise<GetCurrentStateResponse> {
  const response = await PBrequest(
    "/common.Mimir/GetCurrentStateForPlayer",
    GetCurrentStatePayload.encode(getCurrentStatePayload),
    config,
  );
  return GetCurrentStateResponse.decode(response);
}

//========================================//
//           Mimir JSON Client            //
//========================================//

export async function GetRulesetsJSON(
  eventsGetRulesetsPayload: EventsGetRulesetsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetRulesetsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetRulesets",
    EventsGetRulesetsPayloadJSON.encode(eventsGetRulesetsPayload),
    config,
  );
  return EventsGetRulesetsResponseJSON.decode(response);
}

export async function GetTimezonesJSON(
  eventsGetTimezonesPayload: EventsGetTimezonesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetTimezonesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetTimezones",
    EventsGetTimezonesPayloadJSON.encode(eventsGetTimezonesPayload),
    config,
  );
  return EventsGetTimezonesResponseJSON.decode(response);
}

export async function GetCountriesJSON(
  eventsGetCountriesPayload: EventsGetCountriesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetCountriesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetCountries",
    EventsGetCountriesPayloadJSON.encode(eventsGetCountriesPayload),
    config,
  );
  return EventsGetCountriesResponseJSON.decode(response);
}

export async function GetEventsJSON(
  eventsGetEventsPayload: EventsGetEventsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetEvents",
    EventsGetEventsPayloadJSON.encode(eventsGetEventsPayload),
    config,
  );
  return EventsGetEventsResponseJSON.decode(response);
}

export async function GetEventsByIdJSON(
  eventsGetEventsByIdPayload: EventsGetEventsByIdPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventsByIdResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetEventsById",
    EventsGetEventsByIdPayloadJSON.encode(eventsGetEventsByIdPayload),
    config,
  );
  return EventsGetEventsByIdResponseJSON.decode(response);
}

export async function GetMyEventsJSON(
  playersGetMyEventsPayload: PlayersGetMyEventsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetMyEventsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetMyEvents",
    PlayersGetMyEventsPayloadJSON.encode(playersGetMyEventsPayload),
    config,
  );
  return PlayersGetMyEventsResponseJSON.decode(response);
}

export async function GetGameConfigJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GameConfig> {
  const response = await JSONrequest(
    "/common.Mimir/GetGameConfig",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GameConfigJSON.decode(response);
}

export async function GetRatingTableJSON(
  eventsGetRatingTablePayload: EventsGetRatingTablePayload,
  config?: ClientConfiguration,
): Promise<EventsGetRatingTableResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetRatingTable",
    EventsGetRatingTablePayloadJSON.encode(eventsGetRatingTablePayload),
    config,
  );
  return EventsGetRatingTableResponseJSON.decode(response);
}

export async function GetLastGamesJSON(
  eventsGetLastGamesPayload: EventsGetLastGamesPayload,
  config?: ClientConfiguration,
): Promise<EventsGetLastGamesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetLastGames",
    EventsGetLastGamesPayloadJSON.encode(eventsGetLastGamesPayload),
    config,
  );
  return EventsGetLastGamesResponseJSON.decode(response);
}

export async function GetGameJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<EventsGetGameResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetGame",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return EventsGetGameResponseJSON.decode(response);
}

export async function GetGamesSeriesJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetGamesSeriesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetGamesSeries",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return EventsGetGamesSeriesResponseJSON.decode(response);
}

export async function GetCurrentSessionsJSON(
  playersGetCurrentSessionsPayload: PlayersGetCurrentSessionsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetCurrentSessionsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetCurrentSessions",
    PlayersGetCurrentSessionsPayloadJSON.encode(
      playersGetCurrentSessionsPayload,
    ),
    config,
  );
  return PlayersGetCurrentSessionsResponseJSON.decode(response);
}

export async function GetAllRegisteredPlayersJSON(
  eventsGetAllRegisteredPlayersPayload: EventsGetAllRegisteredPlayersPayload,
  config?: ClientConfiguration,
): Promise<EventsGetAllRegisteredPlayersResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetAllRegisteredPlayers",
    EventsGetAllRegisteredPlayersPayloadJSON.encode(
      eventsGetAllRegisteredPlayersPayload,
    ),
    config,
  );
  return EventsGetAllRegisteredPlayersResponseJSON.decode(response);
}

export async function GetTimerStateJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetTimerStateResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetTimerState",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return EventsGetTimerStateResponseJSON.decode(response);
}

export async function GetSessionOverviewJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<GamesGetSessionOverviewResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetSessionOverview",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return GamesGetSessionOverviewResponseJSON.decode(response);
}

export async function GetPlayerStatsJSON(
  playersGetPlayerStatsPayload: PlayersGetPlayerStatsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetPlayerStatsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetPlayerStats",
    PlayersGetPlayerStatsPayloadJSON.encode(playersGetPlayerStatsPayload),
    config,
  );
  return PlayersGetPlayerStatsResponseJSON.decode(response);
}

export async function AddRoundJSON(
  gamesAddRoundPayload: GamesAddRoundPayload,
  config?: ClientConfiguration,
): Promise<GamesAddRoundResponse> {
  const response = await JSONrequest(
    "/common.Mimir/AddRound",
    GamesAddRoundPayloadJSON.encode(gamesAddRoundPayload),
    config,
  );
  return GamesAddRoundResponseJSON.decode(response);
}

export async function PreviewRoundJSON(
  gamesPreviewRoundPayload: GamesPreviewRoundPayload,
  config?: ClientConfiguration,
): Promise<GamesPreviewRoundResponse> {
  const response = await JSONrequest(
    "/common.Mimir/PreviewRound",
    GamesPreviewRoundPayloadJSON.encode(gamesPreviewRoundPayload),
    config,
  );
  return GamesPreviewRoundResponseJSON.decode(response);
}

export async function AddOnlineReplayJSON(
  gamesAddOnlineReplayPayload: GamesAddOnlineReplayPayload,
  config?: ClientConfiguration,
): Promise<GamesAddOnlineReplayResponse> {
  const response = await JSONrequest(
    "/common.Mimir/AddOnlineReplay",
    GamesAddOnlineReplayPayloadJSON.encode(gamesAddOnlineReplayPayload),
    config,
  );
  return GamesAddOnlineReplayResponseJSON.decode(response);
}

export async function GetLastResultsJSON(
  playersGetLastResultsPayload: PlayersGetLastResultsPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastResultsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetLastResults",
    PlayersGetLastResultsPayloadJSON.encode(playersGetLastResultsPayload),
    config,
  );
  return PlayersGetLastResultsResponseJSON.decode(response);
}

export async function GetLastRoundJSON(
  playersGetLastRoundPayload: PlayersGetLastRoundPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastRoundResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetLastRound",
    PlayersGetLastRoundPayloadJSON.encode(playersGetLastRoundPayload),
    config,
  );
  return PlayersGetLastRoundResponseJSON.decode(response);
}

export async function GetAllRoundsJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetAllRoundsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetAllRounds",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return PlayersGetAllRoundsResponseJSON.decode(response);
}

export async function GetLastRoundByHashJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetLastRoundByHashResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetLastRoundByHash",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return PlayersGetLastRoundByHashResponseJSON.decode(response);
}

export async function GetEventForEditJSON(
  eventsGetEventForEditPayload: EventsGetEventForEditPayload,
  config?: ClientConfiguration,
): Promise<EventsGetEventForEditResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetEventForEdit",
    EventsGetEventForEditPayloadJSON.encode(eventsGetEventForEditPayload),
    config,
  );
  return EventsGetEventForEditResponseJSON.decode(response);
}

export async function RebuildScoringJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/RebuildScoring",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function CreateEventJSON(
  eventData: protoAtoms.EventData,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericEventPayload> {
  const response = await JSONrequest(
    "/common.Mimir/CreateEvent",
    protoAtoms.EventDataJSON.encode(eventData),
    config,
  );
  return protoAtoms.GenericEventPayloadJSON.decode(response);
}

export async function UpdateEventJSON(
  eventsUpdateEventPayload: EventsUpdateEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdateEvent",
    EventsUpdateEventPayloadJSON.encode(eventsUpdateEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function FinishEventJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/FinishEvent",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ToggleListedJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ToggleListed",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function GetTablesStateJSON(
  eventsGetTablesStatePayload: EventsGetTablesStatePayload,
  config?: ClientConfiguration,
): Promise<EventsGetTablesStateResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetTablesState",
    EventsGetTablesStatePayloadJSON.encode(eventsGetTablesStatePayload),
    config,
  );
  return EventsGetTablesStateResponseJSON.decode(response);
}

export async function StartTimerJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/StartTimer",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function RegisterPlayerJSON(
  eventsRegisterPlayerPayload: EventsRegisterPlayerPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/RegisterPlayer",
    EventsRegisterPlayerPayloadJSON.encode(eventsRegisterPlayerPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function UnregisterPlayerJSON(
  eventsUnregisterPlayerPayload: EventsUnregisterPlayerPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UnregisterPlayer",
    EventsUnregisterPlayerPayloadJSON.encode(eventsUnregisterPlayerPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function UpdatePlayerSeatingFlagJSON(
  eventsUpdatePlayerSeatingFlagPayload: EventsUpdatePlayerSeatingFlagPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdatePlayerSeatingFlag",
    EventsUpdatePlayerSeatingFlagPayloadJSON.encode(
      eventsUpdatePlayerSeatingFlagPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function GetAchievementsJSON(
  eventsGetAchievementsPayload: EventsGetAchievementsPayload,
  config?: ClientConfiguration,
): Promise<EventsGetAchievementsResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetAchievements",
    EventsGetAchievementsPayloadJSON.encode(eventsGetAchievementsPayload),
    config,
  );
  return EventsGetAchievementsResponseJSON.decode(response);
}

export async function ToggleHideResultsJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ToggleHideResults",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ToggleHideAchievementsJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ToggleHideAchievements",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function UpdatePlayersLocalIdsJSON(
  eventsUpdatePlayersLocalIdsPayload: EventsUpdatePlayersLocalIdsPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdatePlayersLocalIds",
    EventsUpdatePlayersLocalIdsPayloadJSON.encode(
      eventsUpdatePlayersLocalIdsPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function UpdatePlayerReplacementJSON(
  eventsUpdatePlayerReplacementPayload: EventsUpdatePlayerReplacementPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdatePlayerReplacement",
    EventsUpdatePlayerReplacementPayloadJSON.encode(
      eventsUpdatePlayerReplacementPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function UpdatePlayersTeamsJSON(
  eventsUpdatePlayersTeamsPayload: EventsUpdatePlayersTeamsPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdatePlayersTeams",
    EventsUpdatePlayersTeamsPayloadJSON.encode(eventsUpdatePlayersTeamsPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function StartGameJSON(
  gamesStartGamePayload: GamesStartGamePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSessionPayload> {
  const response = await JSONrequest(
    "/common.Mimir/StartGame",
    GamesStartGamePayloadJSON.encode(gamesStartGamePayload),
    config,
  );
  return protoAtoms.GenericSessionPayloadJSON.decode(response);
}

export async function EndGameJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/EndGame",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function CancelGameJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/CancelGame",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function FinalizeSessionJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/FinalizeSession",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function DropLastRoundJSON(
  gamesDropLastRoundPayload: GamesDropLastRoundPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/DropLastRound",
    GamesDropLastRoundPayloadJSON.encode(gamesDropLastRoundPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function DefinalizeGameJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/DefinalizeGame",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function AddPenaltyJSON(
  gamesAddPenaltyPayload: GamesAddPenaltyPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/AddPenalty",
    GamesAddPenaltyPayloadJSON.encode(gamesAddPenaltyPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function AddPenaltyGameJSON(
  gamesAddPenaltyGamePayload: GamesAddPenaltyGamePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSessionPayload> {
  const response = await JSONrequest(
    "/common.Mimir/AddPenaltyGame",
    GamesAddPenaltyGamePayloadJSON.encode(gamesAddPenaltyGamePayload),
    config,
  );
  return protoAtoms.GenericSessionPayloadJSON.decode(response);
}

export async function GetPlayerJSON(
  playersGetPlayerPayload: PlayersGetPlayerPayload,
  config?: ClientConfiguration,
): Promise<PlayersGetPlayerResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetPlayer",
    PlayersGetPlayerPayloadJSON.encode(playersGetPlayerPayload),
    config,
  );
  return PlayersGetPlayerResponseJSON.decode(response);
}

export async function GetCurrentSeatingJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetCurrentSeatingResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetCurrentSeating",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return EventsGetCurrentSeatingResponseJSON.decode(response);
}

export async function MakeShuffledSeatingJSON(
  seatingMakeShuffledSeatingPayload: SeatingMakeShuffledSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/MakeShuffledSeating",
    SeatingMakeShuffledSeatingPayloadJSON.encode(
      seatingMakeShuffledSeatingPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function MakeSwissSeatingJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/MakeSwissSeating",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ResetSeatingJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ResetSeating",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function GenerateSwissSeatingJSON(
  seatingGenerateSwissSeatingPayload: SeatingGenerateSwissSeatingPayload,
  config?: ClientConfiguration,
): Promise<SeatingGenerateSwissSeatingResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GenerateSwissSeating",
    SeatingGenerateSwissSeatingPayloadJSON.encode(
      seatingGenerateSwissSeatingPayload,
    ),
    config,
  );
  return SeatingGenerateSwissSeatingResponseJSON.decode(response);
}

export async function MakeIntervalSeatingJSON(
  seatingMakeIntervalSeatingPayload: SeatingMakeIntervalSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/MakeIntervalSeating",
    SeatingMakeIntervalSeatingPayloadJSON.encode(
      seatingMakeIntervalSeatingPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function MakePrescriptedSeatingJSON(
  seatingMakePrescriptedSeatingPayload: SeatingMakePrescriptedSeatingPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/MakePrescriptedSeating",
    SeatingMakePrescriptedSeatingPayloadJSON.encode(
      seatingMakePrescriptedSeatingPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function GetNextPrescriptedSeatingJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<SeatingGetNextPrescriptedSeatingResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetNextPrescriptedSeating",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return SeatingGetNextPrescriptedSeatingResponseJSON.decode(response);
}

export async function GetPrescriptedEventConfigJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetPrescriptedEventConfigResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetPrescriptedEventConfig",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return EventsGetPrescriptedEventConfigResponseJSON.decode(response);
}

export async function UpdatePrescriptedEventConfigJSON(
  eventsUpdatePrescriptedEventConfigPayload: EventsUpdatePrescriptedEventConfigPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/UpdatePrescriptedEventConfig",
    EventsUpdatePrescriptedEventConfigPayloadJSON.encode(
      eventsUpdatePrescriptedEventConfigPayload,
    ),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function InitStartingTimerJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/InitStartingTimer",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function GetStartingTimerJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<EventsGetStartingTimerResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetStartingTimer",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return EventsGetStartingTimerResponseJSON.decode(response);
}

export async function ClearStatCacheJSON(
  clearStatCachePayload: ClearStatCachePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ClearStatCache",
    ClearStatCachePayloadJSON.encode(clearStatCachePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ForceFinishGameJSON(
  genericSessionPayload: protoAtoms.GenericSessionPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ForceFinishGame",
    protoAtoms.GenericSessionPayloadJSON.encode(genericSessionPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function AddTypedOnlineReplayJSON(
  typedGamesAddOnlineReplayPayload: TypedGamesAddOnlineReplayPayload,
  config?: ClientConfiguration,
): Promise<GamesAddOnlineReplayResponse> {
  const response = await JSONrequest(
    "/common.Mimir/AddTypedOnlineReplay",
    TypedGamesAddOnlineReplayPayloadJSON.encode(
      typedGamesAddOnlineReplayPayload,
    ),
    config,
  );
  return GamesAddOnlineReplayResponseJSON.decode(response);
}

export async function NotifyPlayersSessionStartsSoonJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/NotifyPlayersSessionStartsSoon",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function CallRefereeJSON(
  callRefereePayload: CallRefereePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/CallReferee",
    CallRefereePayloadJSON.encode(callRefereePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function RecalcAchievementsJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/RecalcAchievements",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function RecalcPlayerStatsJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/RecalcPlayerStats",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ListPenaltiesJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<PenaltiesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ListPenalties",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return PenaltiesResponseJSON.decode(response);
}

export async function CancelPenaltyJSON(
  cancelPenaltyPayload: CancelPenaltyPayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/CancelPenalty",
    CancelPenaltyPayloadJSON.encode(cancelPenaltyPayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function AddExtraTimeJSON(
  addExtraTimePayload: AddExtraTimePayload,
  config?: ClientConfiguration,
): Promise<protoAtoms.GenericSuccessResponse> {
  const response = await JSONrequest(
    "/common.Mimir/AddExtraTime",
    AddExtraTimePayloadJSON.encode(addExtraTimePayload),
    config,
  );
  return protoAtoms.GenericSuccessResponseJSON.decode(response);
}

export async function ListMyPenaltiesJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<PenaltiesResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ListMyPenalties",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return PenaltiesResponseJSON.decode(response);
}

export async function ListChomboJSON(
  genericEventPayload: protoAtoms.GenericEventPayload,
  config?: ClientConfiguration,
): Promise<ChomboResponse> {
  const response = await JSONrequest(
    "/common.Mimir/ListChombo",
    protoAtoms.GenericEventPayloadJSON.encode(genericEventPayload),
    config,
  );
  return ChomboResponseJSON.decode(response);
}

export async function GetCurrentStateForPlayerJSON(
  getCurrentStatePayload: GetCurrentStatePayload,
  config?: ClientConfiguration,
): Promise<GetCurrentStateResponse> {
  const response = await JSONrequest(
    "/common.Mimir/GetCurrentStateForPlayer",
    GetCurrentStatePayloadJSON.encode(getCurrentStatePayload),
    config,
  );
  return GetCurrentStateResponseJSON.decode(response);
}

//========================================//
//                 Mimir                  //
//========================================//

export interface Mimir<Context = unknown> {
  GetRulesets: (
    eventsGetRulesetsPayload: EventsGetRulesetsPayload,
    context: Context,
  ) => Promise<EventsGetRulesetsResponse> | EventsGetRulesetsResponse;
  GetTimezones: (
    eventsGetTimezonesPayload: EventsGetTimezonesPayload,
    context: Context,
  ) => Promise<EventsGetTimezonesResponse> | EventsGetTimezonesResponse;
  GetCountries: (
    eventsGetCountriesPayload: EventsGetCountriesPayload,
    context: Context,
  ) => Promise<EventsGetCountriesResponse> | EventsGetCountriesResponse;
  GetEvents: (
    eventsGetEventsPayload: EventsGetEventsPayload,
    context: Context,
  ) => Promise<EventsGetEventsResponse> | EventsGetEventsResponse;
  GetEventsById: (
    eventsGetEventsByIdPayload: EventsGetEventsByIdPayload,
    context: Context,
  ) => Promise<EventsGetEventsByIdResponse> | EventsGetEventsByIdResponse;
  GetMyEvents: (
    playersGetMyEventsPayload: PlayersGetMyEventsPayload,
    context: Context,
  ) => Promise<PlayersGetMyEventsResponse> | PlayersGetMyEventsResponse;
  GetGameConfig: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<protoAtoms.GameConfig> | protoAtoms.GameConfig;
  GetRatingTable: (
    eventsGetRatingTablePayload: EventsGetRatingTablePayload,
    context: Context,
  ) => Promise<EventsGetRatingTableResponse> | EventsGetRatingTableResponse;
  GetLastGames: (
    eventsGetLastGamesPayload: EventsGetLastGamesPayload,
    context: Context,
  ) => Promise<EventsGetLastGamesResponse> | EventsGetLastGamesResponse;
  GetGame: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) => Promise<EventsGetGameResponse> | EventsGetGameResponse;
  GetGamesSeries: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<EventsGetGamesSeriesResponse> | EventsGetGamesSeriesResponse;
  GetCurrentSessions: (
    playersGetCurrentSessionsPayload: PlayersGetCurrentSessionsPayload,
    context: Context,
  ) =>
    | Promise<PlayersGetCurrentSessionsResponse>
    | PlayersGetCurrentSessionsResponse;
  GetAllRegisteredPlayers: (
    eventsGetAllRegisteredPlayersPayload: EventsGetAllRegisteredPlayersPayload,
    context: Context,
  ) =>
    | Promise<EventsGetAllRegisteredPlayersResponse>
    | EventsGetAllRegisteredPlayersResponse;
  GetTimerState: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<EventsGetTimerStateResponse> | EventsGetTimerStateResponse;
  GetSessionOverview: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<GamesGetSessionOverviewResponse>
    | GamesGetSessionOverviewResponse;
  GetPlayerStats: (
    playersGetPlayerStatsPayload: PlayersGetPlayerStatsPayload,
    context: Context,
  ) => Promise<PlayersGetPlayerStatsResponse> | PlayersGetPlayerStatsResponse;
  AddRound: (
    gamesAddRoundPayload: GamesAddRoundPayload,
    context: Context,
  ) => Promise<GamesAddRoundResponse> | GamesAddRoundResponse;
  PreviewRound: (
    gamesPreviewRoundPayload: GamesPreviewRoundPayload,
    context: Context,
  ) => Promise<GamesPreviewRoundResponse> | GamesPreviewRoundResponse;
  AddOnlineReplay: (
    gamesAddOnlineReplayPayload: GamesAddOnlineReplayPayload,
    context: Context,
  ) => Promise<GamesAddOnlineReplayResponse> | GamesAddOnlineReplayResponse;
  GetLastResults: (
    playersGetLastResultsPayload: PlayersGetLastResultsPayload,
    context: Context,
  ) => Promise<PlayersGetLastResultsResponse> | PlayersGetLastResultsResponse;
  GetLastRound: (
    playersGetLastRoundPayload: PlayersGetLastRoundPayload,
    context: Context,
  ) => Promise<PlayersGetLastRoundResponse> | PlayersGetLastRoundResponse;
  GetAllRounds: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) => Promise<PlayersGetAllRoundsResponse> | PlayersGetAllRoundsResponse;
  GetLastRoundByHash: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<PlayersGetLastRoundByHashResponse>
    | PlayersGetLastRoundByHashResponse;
  GetEventForEdit: (
    eventsGetEventForEditPayload: EventsGetEventForEditPayload,
    context: Context,
  ) => Promise<EventsGetEventForEditResponse> | EventsGetEventForEditResponse;
  RebuildScoring: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  CreateEvent: (
    eventData: protoAtoms.EventData,
    context: Context,
  ) => Promise<protoAtoms.GenericEventPayload> | protoAtoms.GenericEventPayload;
  UpdateEvent: (
    eventsUpdateEventPayload: EventsUpdateEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  FinishEvent: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ToggleListed: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  GetTablesState: (
    eventsGetTablesStatePayload: EventsGetTablesStatePayload,
    context: Context,
  ) => Promise<EventsGetTablesStateResponse> | EventsGetTablesStateResponse;
  StartTimer: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  RegisterPlayer: (
    eventsRegisterPlayerPayload: EventsRegisterPlayerPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  UnregisterPlayer: (
    eventsUnregisterPlayerPayload: EventsUnregisterPlayerPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  UpdatePlayerSeatingFlag: (
    eventsUpdatePlayerSeatingFlagPayload: EventsUpdatePlayerSeatingFlagPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  GetAchievements: (
    eventsGetAchievementsPayload: EventsGetAchievementsPayload,
    context: Context,
  ) => Promise<EventsGetAchievementsResponse> | EventsGetAchievementsResponse;
  ToggleHideResults: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ToggleHideAchievements: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  UpdatePlayersLocalIds: (
    eventsUpdatePlayersLocalIdsPayload: EventsUpdatePlayersLocalIdsPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  UpdatePlayerReplacement: (
    eventsUpdatePlayerReplacementPayload: EventsUpdatePlayerReplacementPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  UpdatePlayersTeams: (
    eventsUpdatePlayersTeamsPayload: EventsUpdatePlayersTeamsPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  StartGame: (
    gamesStartGamePayload: GamesStartGamePayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSessionPayload>
    | protoAtoms.GenericSessionPayload;
  EndGame: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  CancelGame: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  FinalizeSession: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  DropLastRound: (
    gamesDropLastRoundPayload: GamesDropLastRoundPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  DefinalizeGame: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  AddPenalty: (
    gamesAddPenaltyPayload: GamesAddPenaltyPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  AddPenaltyGame: (
    gamesAddPenaltyGamePayload: GamesAddPenaltyGamePayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSessionPayload>
    | protoAtoms.GenericSessionPayload;
  GetPlayer: (
    playersGetPlayerPayload: PlayersGetPlayerPayload,
    context: Context,
  ) => Promise<PlayersGetPlayerResponse> | PlayersGetPlayerResponse;
  GetCurrentSeating: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<EventsGetCurrentSeatingResponse>
    | EventsGetCurrentSeatingResponse;
  MakeShuffledSeating: (
    seatingMakeShuffledSeatingPayload: SeatingMakeShuffledSeatingPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  MakeSwissSeating: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ResetSeating: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  GenerateSwissSeating: (
    seatingGenerateSwissSeatingPayload: SeatingGenerateSwissSeatingPayload,
    context: Context,
  ) =>
    | Promise<SeatingGenerateSwissSeatingResponse>
    | SeatingGenerateSwissSeatingResponse;
  MakeIntervalSeating: (
    seatingMakeIntervalSeatingPayload: SeatingMakeIntervalSeatingPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  MakePrescriptedSeating: (
    seatingMakePrescriptedSeatingPayload: SeatingMakePrescriptedSeatingPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  GetNextPrescriptedSeating: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<SeatingGetNextPrescriptedSeatingResponse>
    | SeatingGetNextPrescriptedSeatingResponse;
  GetPrescriptedEventConfig: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<EventsGetPrescriptedEventConfigResponse>
    | EventsGetPrescriptedEventConfigResponse;
  UpdatePrescriptedEventConfig: (
    eventsUpdatePrescriptedEventConfigPayload: EventsUpdatePrescriptedEventConfigPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  InitStartingTimer: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  GetStartingTimer: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<EventsGetStartingTimerResponse> | EventsGetStartingTimerResponse;
  ClearStatCache: (
    clearStatCachePayload: ClearStatCachePayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ForceFinishGame: (
    genericSessionPayload: protoAtoms.GenericSessionPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  AddTypedOnlineReplay: (
    typedGamesAddOnlineReplayPayload: TypedGamesAddOnlineReplayPayload,
    context: Context,
  ) => Promise<GamesAddOnlineReplayResponse> | GamesAddOnlineReplayResponse;
  NotifyPlayersSessionStartsSoon: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  CallReferee: (
    callRefereePayload: CallRefereePayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  RecalcAchievements: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  RecalcPlayerStats: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ListPenalties: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<PenaltiesResponse> | PenaltiesResponse;
  CancelPenalty: (
    cancelPenaltyPayload: CancelPenaltyPayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  AddExtraTime: (
    addExtraTimePayload: AddExtraTimePayload,
    context: Context,
  ) =>
    | Promise<protoAtoms.GenericSuccessResponse>
    | protoAtoms.GenericSuccessResponse;
  ListMyPenalties: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<PenaltiesResponse> | PenaltiesResponse;
  ListChombo: (
    genericEventPayload: protoAtoms.GenericEventPayload,
    context: Context,
  ) => Promise<ChomboResponse> | ChomboResponse;
  GetCurrentStateForPlayer: (
    getCurrentStatePayload: GetCurrentStatePayload,
    context: Context,
  ) => Promise<GetCurrentStateResponse> | GetCurrentStateResponse;
}

export function createMimir<Context>(service: Mimir<Context>) {
  return {
    name: "common.Mimir",
    methods: {
      GetRulesets: {
        name: "GetRulesets",
        handler: service.GetRulesets,
        input: {
          protobuf: EventsGetRulesetsPayload,
          json: EventsGetRulesetsPayloadJSON,
        },
        output: {
          protobuf: EventsGetRulesetsResponse,
          json: EventsGetRulesetsResponseJSON,
        },
      },
      GetTimezones: {
        name: "GetTimezones",
        handler: service.GetTimezones,
        input: {
          protobuf: EventsGetTimezonesPayload,
          json: EventsGetTimezonesPayloadJSON,
        },
        output: {
          protobuf: EventsGetTimezonesResponse,
          json: EventsGetTimezonesResponseJSON,
        },
      },
      GetCountries: {
        name: "GetCountries",
        handler: service.GetCountries,
        input: {
          protobuf: EventsGetCountriesPayload,
          json: EventsGetCountriesPayloadJSON,
        },
        output: {
          protobuf: EventsGetCountriesResponse,
          json: EventsGetCountriesResponseJSON,
        },
      },
      GetEvents: {
        name: "GetEvents",
        handler: service.GetEvents,
        input: {
          protobuf: EventsGetEventsPayload,
          json: EventsGetEventsPayloadJSON,
        },
        output: {
          protobuf: EventsGetEventsResponse,
          json: EventsGetEventsResponseJSON,
        },
      },
      GetEventsById: {
        name: "GetEventsById",
        handler: service.GetEventsById,
        input: {
          protobuf: EventsGetEventsByIdPayload,
          json: EventsGetEventsByIdPayloadJSON,
        },
        output: {
          protobuf: EventsGetEventsByIdResponse,
          json: EventsGetEventsByIdResponseJSON,
        },
      },
      GetMyEvents: {
        name: "GetMyEvents",
        handler: service.GetMyEvents,
        input: {
          protobuf: PlayersGetMyEventsPayload,
          json: PlayersGetMyEventsPayloadJSON,
        },
        output: {
          protobuf: PlayersGetMyEventsResponse,
          json: PlayersGetMyEventsResponseJSON,
        },
      },
      GetGameConfig: {
        name: "GetGameConfig",
        handler: service.GetGameConfig,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GameConfig,
          json: protoAtoms.GameConfigJSON,
        },
      },
      GetRatingTable: {
        name: "GetRatingTable",
        handler: service.GetRatingTable,
        input: {
          protobuf: EventsGetRatingTablePayload,
          json: EventsGetRatingTablePayloadJSON,
        },
        output: {
          protobuf: EventsGetRatingTableResponse,
          json: EventsGetRatingTableResponseJSON,
        },
      },
      GetLastGames: {
        name: "GetLastGames",
        handler: service.GetLastGames,
        input: {
          protobuf: EventsGetLastGamesPayload,
          json: EventsGetLastGamesPayloadJSON,
        },
        output: {
          protobuf: EventsGetLastGamesResponse,
          json: EventsGetLastGamesResponseJSON,
        },
      },
      GetGame: {
        name: "GetGame",
        handler: service.GetGame,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: EventsGetGameResponse,
          json: EventsGetGameResponseJSON,
        },
      },
      GetGamesSeries: {
        name: "GetGamesSeries",
        handler: service.GetGamesSeries,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: EventsGetGamesSeriesResponse,
          json: EventsGetGamesSeriesResponseJSON,
        },
      },
      GetCurrentSessions: {
        name: "GetCurrentSessions",
        handler: service.GetCurrentSessions,
        input: {
          protobuf: PlayersGetCurrentSessionsPayload,
          json: PlayersGetCurrentSessionsPayloadJSON,
        },
        output: {
          protobuf: PlayersGetCurrentSessionsResponse,
          json: PlayersGetCurrentSessionsResponseJSON,
        },
      },
      GetAllRegisteredPlayers: {
        name: "GetAllRegisteredPlayers",
        handler: service.GetAllRegisteredPlayers,
        input: {
          protobuf: EventsGetAllRegisteredPlayersPayload,
          json: EventsGetAllRegisteredPlayersPayloadJSON,
        },
        output: {
          protobuf: EventsGetAllRegisteredPlayersResponse,
          json: EventsGetAllRegisteredPlayersResponseJSON,
        },
      },
      GetTimerState: {
        name: "GetTimerState",
        handler: service.GetTimerState,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: EventsGetTimerStateResponse,
          json: EventsGetTimerStateResponseJSON,
        },
      },
      GetSessionOverview: {
        name: "GetSessionOverview",
        handler: service.GetSessionOverview,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: GamesGetSessionOverviewResponse,
          json: GamesGetSessionOverviewResponseJSON,
        },
      },
      GetPlayerStats: {
        name: "GetPlayerStats",
        handler: service.GetPlayerStats,
        input: {
          protobuf: PlayersGetPlayerStatsPayload,
          json: PlayersGetPlayerStatsPayloadJSON,
        },
        output: {
          protobuf: PlayersGetPlayerStatsResponse,
          json: PlayersGetPlayerStatsResponseJSON,
        },
      },
      AddRound: {
        name: "AddRound",
        handler: service.AddRound,
        input: {
          protobuf: GamesAddRoundPayload,
          json: GamesAddRoundPayloadJSON,
        },
        output: {
          protobuf: GamesAddRoundResponse,
          json: GamesAddRoundResponseJSON,
        },
      },
      PreviewRound: {
        name: "PreviewRound",
        handler: service.PreviewRound,
        input: {
          protobuf: GamesPreviewRoundPayload,
          json: GamesPreviewRoundPayloadJSON,
        },
        output: {
          protobuf: GamesPreviewRoundResponse,
          json: GamesPreviewRoundResponseJSON,
        },
      },
      AddOnlineReplay: {
        name: "AddOnlineReplay",
        handler: service.AddOnlineReplay,
        input: {
          protobuf: GamesAddOnlineReplayPayload,
          json: GamesAddOnlineReplayPayloadJSON,
        },
        output: {
          protobuf: GamesAddOnlineReplayResponse,
          json: GamesAddOnlineReplayResponseJSON,
        },
      },
      GetLastResults: {
        name: "GetLastResults",
        handler: service.GetLastResults,
        input: {
          protobuf: PlayersGetLastResultsPayload,
          json: PlayersGetLastResultsPayloadJSON,
        },
        output: {
          protobuf: PlayersGetLastResultsResponse,
          json: PlayersGetLastResultsResponseJSON,
        },
      },
      GetLastRound: {
        name: "GetLastRound",
        handler: service.GetLastRound,
        input: {
          protobuf: PlayersGetLastRoundPayload,
          json: PlayersGetLastRoundPayloadJSON,
        },
        output: {
          protobuf: PlayersGetLastRoundResponse,
          json: PlayersGetLastRoundResponseJSON,
        },
      },
      GetAllRounds: {
        name: "GetAllRounds",
        handler: service.GetAllRounds,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: PlayersGetAllRoundsResponse,
          json: PlayersGetAllRoundsResponseJSON,
        },
      },
      GetLastRoundByHash: {
        name: "GetLastRoundByHash",
        handler: service.GetLastRoundByHash,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: PlayersGetLastRoundByHashResponse,
          json: PlayersGetLastRoundByHashResponseJSON,
        },
      },
      GetEventForEdit: {
        name: "GetEventForEdit",
        handler: service.GetEventForEdit,
        input: {
          protobuf: EventsGetEventForEditPayload,
          json: EventsGetEventForEditPayloadJSON,
        },
        output: {
          protobuf: EventsGetEventForEditResponse,
          json: EventsGetEventForEditResponseJSON,
        },
      },
      RebuildScoring: {
        name: "RebuildScoring",
        handler: service.RebuildScoring,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      CreateEvent: {
        name: "CreateEvent",
        handler: service.CreateEvent,
        input: {
          protobuf: protoAtoms.EventData,
          json: protoAtoms.EventDataJSON,
        },
        output: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
      },
      UpdateEvent: {
        name: "UpdateEvent",
        handler: service.UpdateEvent,
        input: {
          protobuf: EventsUpdateEventPayload,
          json: EventsUpdateEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      FinishEvent: {
        name: "FinishEvent",
        handler: service.FinishEvent,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ToggleListed: {
        name: "ToggleListed",
        handler: service.ToggleListed,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      GetTablesState: {
        name: "GetTablesState",
        handler: service.GetTablesState,
        input: {
          protobuf: EventsGetTablesStatePayload,
          json: EventsGetTablesStatePayloadJSON,
        },
        output: {
          protobuf: EventsGetTablesStateResponse,
          json: EventsGetTablesStateResponseJSON,
        },
      },
      StartTimer: {
        name: "StartTimer",
        handler: service.StartTimer,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      RegisterPlayer: {
        name: "RegisterPlayer",
        handler: service.RegisterPlayer,
        input: {
          protobuf: EventsRegisterPlayerPayload,
          json: EventsRegisterPlayerPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      UnregisterPlayer: {
        name: "UnregisterPlayer",
        handler: service.UnregisterPlayer,
        input: {
          protobuf: EventsUnregisterPlayerPayload,
          json: EventsUnregisterPlayerPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      UpdatePlayerSeatingFlag: {
        name: "UpdatePlayerSeatingFlag",
        handler: service.UpdatePlayerSeatingFlag,
        input: {
          protobuf: EventsUpdatePlayerSeatingFlagPayload,
          json: EventsUpdatePlayerSeatingFlagPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      GetAchievements: {
        name: "GetAchievements",
        handler: service.GetAchievements,
        input: {
          protobuf: EventsGetAchievementsPayload,
          json: EventsGetAchievementsPayloadJSON,
        },
        output: {
          protobuf: EventsGetAchievementsResponse,
          json: EventsGetAchievementsResponseJSON,
        },
      },
      ToggleHideResults: {
        name: "ToggleHideResults",
        handler: service.ToggleHideResults,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ToggleHideAchievements: {
        name: "ToggleHideAchievements",
        handler: service.ToggleHideAchievements,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      UpdatePlayersLocalIds: {
        name: "UpdatePlayersLocalIds",
        handler: service.UpdatePlayersLocalIds,
        input: {
          protobuf: EventsUpdatePlayersLocalIdsPayload,
          json: EventsUpdatePlayersLocalIdsPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      UpdatePlayerReplacement: {
        name: "UpdatePlayerReplacement",
        handler: service.UpdatePlayerReplacement,
        input: {
          protobuf: EventsUpdatePlayerReplacementPayload,
          json: EventsUpdatePlayerReplacementPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      UpdatePlayersTeams: {
        name: "UpdatePlayersTeams",
        handler: service.UpdatePlayersTeams,
        input: {
          protobuf: EventsUpdatePlayersTeamsPayload,
          json: EventsUpdatePlayersTeamsPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      StartGame: {
        name: "StartGame",
        handler: service.StartGame,
        input: {
          protobuf: GamesStartGamePayload,
          json: GamesStartGamePayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
      },
      EndGame: {
        name: "EndGame",
        handler: service.EndGame,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      CancelGame: {
        name: "CancelGame",
        handler: service.CancelGame,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      FinalizeSession: {
        name: "FinalizeSession",
        handler: service.FinalizeSession,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      DropLastRound: {
        name: "DropLastRound",
        handler: service.DropLastRound,
        input: {
          protobuf: GamesDropLastRoundPayload,
          json: GamesDropLastRoundPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      DefinalizeGame: {
        name: "DefinalizeGame",
        handler: service.DefinalizeGame,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      AddPenalty: {
        name: "AddPenalty",
        handler: service.AddPenalty,
        input: {
          protobuf: GamesAddPenaltyPayload,
          json: GamesAddPenaltyPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      AddPenaltyGame: {
        name: "AddPenaltyGame",
        handler: service.AddPenaltyGame,
        input: {
          protobuf: GamesAddPenaltyGamePayload,
          json: GamesAddPenaltyGamePayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
      },
      GetPlayer: {
        name: "GetPlayer",
        handler: service.GetPlayer,
        input: {
          protobuf: PlayersGetPlayerPayload,
          json: PlayersGetPlayerPayloadJSON,
        },
        output: {
          protobuf: PlayersGetPlayerResponse,
          json: PlayersGetPlayerResponseJSON,
        },
      },
      GetCurrentSeating: {
        name: "GetCurrentSeating",
        handler: service.GetCurrentSeating,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: EventsGetCurrentSeatingResponse,
          json: EventsGetCurrentSeatingResponseJSON,
        },
      },
      MakeShuffledSeating: {
        name: "MakeShuffledSeating",
        handler: service.MakeShuffledSeating,
        input: {
          protobuf: SeatingMakeShuffledSeatingPayload,
          json: SeatingMakeShuffledSeatingPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      MakeSwissSeating: {
        name: "MakeSwissSeating",
        handler: service.MakeSwissSeating,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ResetSeating: {
        name: "ResetSeating",
        handler: service.ResetSeating,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      GenerateSwissSeating: {
        name: "GenerateSwissSeating",
        handler: service.GenerateSwissSeating,
        input: {
          protobuf: SeatingGenerateSwissSeatingPayload,
          json: SeatingGenerateSwissSeatingPayloadJSON,
        },
        output: {
          protobuf: SeatingGenerateSwissSeatingResponse,
          json: SeatingGenerateSwissSeatingResponseJSON,
        },
      },
      MakeIntervalSeating: {
        name: "MakeIntervalSeating",
        handler: service.MakeIntervalSeating,
        input: {
          protobuf: SeatingMakeIntervalSeatingPayload,
          json: SeatingMakeIntervalSeatingPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      MakePrescriptedSeating: {
        name: "MakePrescriptedSeating",
        handler: service.MakePrescriptedSeating,
        input: {
          protobuf: SeatingMakePrescriptedSeatingPayload,
          json: SeatingMakePrescriptedSeatingPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      GetNextPrescriptedSeating: {
        name: "GetNextPrescriptedSeating",
        handler: service.GetNextPrescriptedSeating,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: SeatingGetNextPrescriptedSeatingResponse,
          json: SeatingGetNextPrescriptedSeatingResponseJSON,
        },
      },
      GetPrescriptedEventConfig: {
        name: "GetPrescriptedEventConfig",
        handler: service.GetPrescriptedEventConfig,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: EventsGetPrescriptedEventConfigResponse,
          json: EventsGetPrescriptedEventConfigResponseJSON,
        },
      },
      UpdatePrescriptedEventConfig: {
        name: "UpdatePrescriptedEventConfig",
        handler: service.UpdatePrescriptedEventConfig,
        input: {
          protobuf: EventsUpdatePrescriptedEventConfigPayload,
          json: EventsUpdatePrescriptedEventConfigPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      InitStartingTimer: {
        name: "InitStartingTimer",
        handler: service.InitStartingTimer,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      GetStartingTimer: {
        name: "GetStartingTimer",
        handler: service.GetStartingTimer,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: EventsGetStartingTimerResponse,
          json: EventsGetStartingTimerResponseJSON,
        },
      },
      ClearStatCache: {
        name: "ClearStatCache",
        handler: service.ClearStatCache,
        input: {
          protobuf: ClearStatCachePayload,
          json: ClearStatCachePayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ForceFinishGame: {
        name: "ForceFinishGame",
        handler: service.ForceFinishGame,
        input: {
          protobuf: protoAtoms.GenericSessionPayload,
          json: protoAtoms.GenericSessionPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      AddTypedOnlineReplay: {
        name: "AddTypedOnlineReplay",
        handler: service.AddTypedOnlineReplay,
        input: {
          protobuf: TypedGamesAddOnlineReplayPayload,
          json: TypedGamesAddOnlineReplayPayloadJSON,
        },
        output: {
          protobuf: GamesAddOnlineReplayResponse,
          json: GamesAddOnlineReplayResponseJSON,
        },
      },
      NotifyPlayersSessionStartsSoon: {
        name: "NotifyPlayersSessionStartsSoon",
        handler: service.NotifyPlayersSessionStartsSoon,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      CallReferee: {
        name: "CallReferee",
        handler: service.CallReferee,
        input: { protobuf: CallRefereePayload, json: CallRefereePayloadJSON },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      RecalcAchievements: {
        name: "RecalcAchievements",
        handler: service.RecalcAchievements,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      RecalcPlayerStats: {
        name: "RecalcPlayerStats",
        handler: service.RecalcPlayerStats,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ListPenalties: {
        name: "ListPenalties",
        handler: service.ListPenalties,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: { protobuf: PenaltiesResponse, json: PenaltiesResponseJSON },
      },
      CancelPenalty: {
        name: "CancelPenalty",
        handler: service.CancelPenalty,
        input: {
          protobuf: CancelPenaltyPayload,
          json: CancelPenaltyPayloadJSON,
        },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      AddExtraTime: {
        name: "AddExtraTime",
        handler: service.AddExtraTime,
        input: { protobuf: AddExtraTimePayload, json: AddExtraTimePayloadJSON },
        output: {
          protobuf: protoAtoms.GenericSuccessResponse,
          json: protoAtoms.GenericSuccessResponseJSON,
        },
      },
      ListMyPenalties: {
        name: "ListMyPenalties",
        handler: service.ListMyPenalties,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: { protobuf: PenaltiesResponse, json: PenaltiesResponseJSON },
      },
      ListChombo: {
        name: "ListChombo",
        handler: service.ListChombo,
        input: {
          protobuf: protoAtoms.GenericEventPayload,
          json: protoAtoms.GenericEventPayloadJSON,
        },
        output: { protobuf: ChomboResponse, json: ChomboResponseJSON },
      },
      GetCurrentStateForPlayer: {
        name: "GetCurrentStateForPlayer",
        handler: service.GetCurrentStateForPlayer,
        input: {
          protobuf: GetCurrentStatePayload,
          json: GetCurrentStatePayloadJSON,
        },
        output: {
          protobuf: GetCurrentStateResponse,
          json: GetCurrentStateResponseJSON,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const EventsGetRulesetsPayload = {
  /**
   * Serializes EventsGetRulesetsPayload to protobuf.
   */
  encode: function (_msg?: PartialDeep<EventsGetRulesetsPayload>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes EventsGetRulesetsPayload from protobuf.
   */
  decode: function (_bytes?: ByteSource): EventsGetRulesetsPayload {
    return {};
  },

  /**
   * Initializes EventsGetRulesetsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRulesetsPayload>,
  ): EventsGetRulesetsPayload {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EventsGetRulesetsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: EventsGetRulesetsPayload,
    _reader: protoscript.BinaryReader,
  ): EventsGetRulesetsPayload {
    return _msg;
  },
};

export const EventsGetRulesetsResponse = {
  /**
   * Serializes EventsGetRulesetsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetRulesetsResponse>): Uint8Array {
    return EventsGetRulesetsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetRulesetsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetRulesetsResponse {
    return EventsGetRulesetsResponse._readMessage(
      EventsGetRulesetsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetRulesetsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRulesetsResponse>,
  ): EventsGetRulesetsResponse {
    return {
      rulesets: [],
      rulesetIds: [],
      rulesetTitles: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRulesetsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.rulesets?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.rulesets as any,
        protoAtoms.RulesetConfig._writeMessage,
      );
    }
    if (msg.rulesetIds?.length) {
      writer.writeRepeatedString(2, msg.rulesetIds);
    }
    if (msg.rulesetTitles?.length) {
      writer.writeRepeatedString(3, msg.rulesetTitles);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRulesetsResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetRulesetsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.RulesetConfig.initialize();
          reader.readMessage(m, protoAtoms.RulesetConfig._readMessage);
          msg.rulesets.push(m);
          break;
        }
        case 2: {
          msg.rulesetIds.push(reader.readString());
          break;
        }
        case 3: {
          msg.rulesetTitles.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetTimezonesPayload = {
  /**
   * Serializes EventsGetTimezonesPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetTimezonesPayload>): Uint8Array {
    return EventsGetTimezonesPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetTimezonesPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetTimezonesPayload {
    return EventsGetTimezonesPayload._readMessage(
      EventsGetTimezonesPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetTimezonesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimezonesPayload>,
  ): EventsGetTimezonesPayload {
    return {
      addr: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimezonesPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.addr) {
      writer.writeString(1, msg.addr);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimezonesPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetTimezonesPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.addr = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetTimezonesResponse = {
  /**
   * Serializes EventsGetTimezonesResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetTimezonesResponse>): Uint8Array {
    return EventsGetTimezonesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetTimezonesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetTimezonesResponse {
    return EventsGetTimezonesResponse._readMessage(
      EventsGetTimezonesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetTimezonesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimezonesResponse>,
  ): EventsGetTimezonesResponse {
    return {
      preferredByIp: "",
      timezones: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimezonesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.preferredByIp) {
      writer.writeString(1, msg.preferredByIp);
    }
    if (msg.timezones?.length) {
      writer.writeRepeatedString(2, msg.timezones);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimezonesResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetTimezonesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.preferredByIp = reader.readString();
          break;
        }
        case 2: {
          msg.timezones.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetCountriesPayload = {
  /**
   * Serializes EventsGetCountriesPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetCountriesPayload>): Uint8Array {
    return EventsGetCountriesPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetCountriesPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetCountriesPayload {
    return EventsGetCountriesPayload._readMessage(
      EventsGetCountriesPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetCountriesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCountriesPayload>,
  ): EventsGetCountriesPayload {
    return {
      addr: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCountriesPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.addr) {
      writer.writeString(1, msg.addr);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCountriesPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetCountriesPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.addr = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetCountriesResponse = {
  /**
   * Serializes EventsGetCountriesResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetCountriesResponse>): Uint8Array {
    return EventsGetCountriesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetCountriesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetCountriesResponse {
    return EventsGetCountriesResponse._readMessage(
      EventsGetCountriesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetCountriesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCountriesResponse>,
  ): EventsGetCountriesResponse {
    return {
      preferredByIp: "",
      countries: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCountriesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.preferredByIp) {
      writer.writeString(1, msg.preferredByIp);
    }
    if (msg.countries?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.countries as any,
        protoAtoms.Country._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCountriesResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetCountriesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.preferredByIp = reader.readString();
          break;
        }
        case 2: {
          const m = protoAtoms.Country.initialize();
          reader.readMessage(m, protoAtoms.Country._readMessage);
          msg.countries.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventsPayload = {
  /**
   * Serializes EventsGetEventsPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetEventsPayload>): Uint8Array {
    return EventsGetEventsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventsPayload {
    return EventsGetEventsPayload._readMessage(
      EventsGetEventsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsPayload>,
  ): EventsGetEventsPayload {
    return {
      limit: 0,
      offset: 0,
      filterUnlisted: false,
      filter: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.limit) {
      writer.writeInt32(1, msg.limit);
    }
    if (msg.offset) {
      writer.writeInt32(2, msg.offset);
    }
    if (msg.filterUnlisted) {
      writer.writeBool(3, msg.filterUnlisted);
    }
    if (msg.filter) {
      writer.writeString(4, msg.filter);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetEventsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.limit = reader.readInt32();
          break;
        }
        case 2: {
          msg.offset = reader.readInt32();
          break;
        }
        case 3: {
          msg.filterUnlisted = reader.readBool();
          break;
        }
        case 4: {
          msg.filter = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventsResponse = {
  /**
   * Serializes EventsGetEventsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetEventsResponse>): Uint8Array {
    return EventsGetEventsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventsResponse {
    return EventsGetEventsResponse._readMessage(
      EventsGetEventsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsResponse>,
  ): EventsGetEventsResponse {
    return {
      total: 0,
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.total) {
      writer.writeInt32(1, msg.total);
    }
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.events as any,
        protoAtoms.Event._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetEventsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.total = reader.readInt32();
          break;
        }
        case 2: {
          const m = protoAtoms.Event.initialize();
          reader.readMessage(m, protoAtoms.Event._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventsByIdPayload = {
  /**
   * Serializes EventsGetEventsByIdPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetEventsByIdPayload>): Uint8Array {
    return EventsGetEventsByIdPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventsByIdPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventsByIdPayload {
    return EventsGetEventsByIdPayload._readMessage(
      EventsGetEventsByIdPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventsByIdPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsByIdPayload>,
  ): EventsGetEventsByIdPayload {
    return {
      ids: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsByIdPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ids?.length) {
      writer.writePackedInt32(1, msg.ids);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsByIdPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetEventsByIdPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.ids.push(...reader.readPackedInt32());
          } else {
            msg.ids.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventsByIdResponse = {
  /**
   * Serializes EventsGetEventsByIdResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetEventsByIdResponse>): Uint8Array {
    return EventsGetEventsByIdResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventsByIdResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventsByIdResponse {
    return EventsGetEventsByIdResponse._readMessage(
      EventsGetEventsByIdResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventsByIdResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsByIdResponse>,
  ): EventsGetEventsByIdResponse {
    return {
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsByIdResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.events as any,
        protoAtoms.Event._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsByIdResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetEventsByIdResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.Event.initialize();
          reader.readMessage(m, protoAtoms.Event._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetMyEventsPayload = {
  /**
   * Serializes PlayersGetMyEventsPayload to protobuf.
   */
  encode: function (_msg?: PartialDeep<PlayersGetMyEventsPayload>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes PlayersGetMyEventsPayload from protobuf.
   */
  decode: function (_bytes?: ByteSource): PlayersGetMyEventsPayload {
    return {};
  },

  /**
   * Initializes PlayersGetMyEventsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetMyEventsPayload>,
  ): PlayersGetMyEventsPayload {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<PlayersGetMyEventsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: PlayersGetMyEventsPayload,
    _reader: protoscript.BinaryReader,
  ): PlayersGetMyEventsPayload {
    return _msg;
  },
};

export const PlayersGetMyEventsResponse = {
  /**
   * Serializes PlayersGetMyEventsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetMyEventsResponse>): Uint8Array {
    return PlayersGetMyEventsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetMyEventsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetMyEventsResponse {
    return PlayersGetMyEventsResponse._readMessage(
      PlayersGetMyEventsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetMyEventsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetMyEventsResponse>,
  ): PlayersGetMyEventsResponse {
    return {
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetMyEventsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.events?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.events as any,
        protoAtoms.MyEvent._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetMyEventsResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetMyEventsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.MyEvent.initialize();
          reader.readMessage(m, protoAtoms.MyEvent._readMessage);
          msg.events.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetRatingTablePayload = {
  /**
   * Serializes EventsGetRatingTablePayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetRatingTablePayload>): Uint8Array {
    return EventsGetRatingTablePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetRatingTablePayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetRatingTablePayload {
    return EventsGetRatingTablePayload._readMessage(
      EventsGetRatingTablePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetRatingTablePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRatingTablePayload>,
  ): EventsGetRatingTablePayload {
    return {
      eventIdList: [],
      orderBy: "",
      order: "",
      withPrefinished: undefined,
      onlyMinGames: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRatingTablePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(1, msg.eventIdList);
    }
    if (msg.orderBy) {
      writer.writeString(2, msg.orderBy);
    }
    if (msg.order) {
      writer.writeString(3, msg.order);
    }
    if (msg.withPrefinished != undefined) {
      writer.writeBool(4, msg.withPrefinished);
    }
    if (msg.onlyMinGames != undefined) {
      writer.writeBool(5, msg.onlyMinGames);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRatingTablePayload,
    reader: protoscript.BinaryReader,
  ): EventsGetRatingTablePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          msg.orderBy = reader.readString();
          break;
        }
        case 3: {
          msg.order = reader.readString();
          break;
        }
        case 4: {
          msg.withPrefinished = reader.readBool();
          break;
        }
        case 5: {
          msg.onlyMinGames = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetRatingTableResponse = {
  /**
   * Serializes EventsGetRatingTableResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetRatingTableResponse>,
  ): Uint8Array {
    return EventsGetRatingTableResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetRatingTableResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetRatingTableResponse {
    return EventsGetRatingTableResponse._readMessage(
      EventsGetRatingTableResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetRatingTableResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRatingTableResponse>,
  ): EventsGetRatingTableResponse {
    return {
      list: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRatingTableResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.list?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.list as any,
        protoAtoms.PlayerInRating._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRatingTableResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetRatingTableResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.PlayerInRating.initialize();
          reader.readMessage(m, protoAtoms.PlayerInRating._readMessage);
          msg.list.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetLastGamesPayload = {
  /**
   * Serializes EventsGetLastGamesPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetLastGamesPayload>): Uint8Array {
    return EventsGetLastGamesPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetLastGamesPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetLastGamesPayload {
    return EventsGetLastGamesPayload._readMessage(
      EventsGetLastGamesPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetLastGamesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetLastGamesPayload>,
  ): EventsGetLastGamesPayload {
    return {
      eventIdList: [],
      limit: 0,
      offset: 0,
      orderBy: undefined,
      order: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetLastGamesPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(1, msg.eventIdList);
    }
    if (msg.limit) {
      writer.writeInt32(2, msg.limit);
    }
    if (msg.offset) {
      writer.writeInt32(3, msg.offset);
    }
    if (msg.orderBy != undefined) {
      writer.writeString(4, msg.orderBy);
    }
    if (msg.order != undefined) {
      writer.writeString(5, msg.order);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetLastGamesPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetLastGamesPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          msg.limit = reader.readInt32();
          break;
        }
        case 3: {
          msg.offset = reader.readInt32();
          break;
        }
        case 4: {
          msg.orderBy = reader.readString();
          break;
        }
        case 5: {
          msg.order = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetLastGamesResponse = {
  /**
   * Serializes EventsGetLastGamesResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetLastGamesResponse>): Uint8Array {
    return EventsGetLastGamesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetLastGamesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetLastGamesResponse {
    return EventsGetLastGamesResponse._readMessage(
      EventsGetLastGamesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetLastGamesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetLastGamesResponse>,
  ): EventsGetLastGamesResponse {
    return {
      games: [],
      players: [],
      totalGames: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetLastGamesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.games?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.games as any,
        protoAtoms.GameResult._writeMessage,
      );
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        protoAtoms.Player._writeMessage,
      );
    }
    if (msg.totalGames) {
      writer.writeInt32(3, msg.totalGames);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetLastGamesResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetLastGamesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.GameResult.initialize();
          reader.readMessage(m, protoAtoms.GameResult._readMessage);
          msg.games.push(m);
          break;
        }
        case 2: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        case 3: {
          msg.totalGames = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetGameResponse = {
  /**
   * Serializes EventsGetGameResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetGameResponse>): Uint8Array {
    return EventsGetGameResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetGameResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetGameResponse {
    return EventsGetGameResponse._readMessage(
      EventsGetGameResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetGameResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetGameResponse>,
  ): EventsGetGameResponse {
    return {
      game: protoAtoms.GameResult.initialize(),
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetGameResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.game) {
      writer.writeMessage(1, msg.game, protoAtoms.GameResult._writeMessage);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        protoAtoms.Player._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetGameResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetGameResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.game, protoAtoms.GameResult._readMessage);
          break;
        }
        case 2: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetGamesSeriesResponse = {
  /**
   * Serializes EventsGetGamesSeriesResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetGamesSeriesResponse>,
  ): Uint8Array {
    return EventsGetGamesSeriesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetGamesSeriesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetGamesSeriesResponse {
    return EventsGetGamesSeriesResponse._readMessage(
      EventsGetGamesSeriesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetGamesSeriesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetGamesSeriesResponse>,
  ): EventsGetGamesSeriesResponse {
    return {
      results: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetGamesSeriesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.results?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.results as any,
        protoAtoms.SeriesResult._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetGamesSeriesResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetGamesSeriesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.SeriesResult.initialize();
          reader.readMessage(m, protoAtoms.SeriesResult._readMessage);
          msg.results.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetCurrentSessionsPayload = {
  /**
   * Serializes PlayersGetCurrentSessionsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetCurrentSessionsPayload>,
  ): Uint8Array {
    return PlayersGetCurrentSessionsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetCurrentSessionsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetCurrentSessionsPayload {
    return PlayersGetCurrentSessionsPayload._readMessage(
      PlayersGetCurrentSessionsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetCurrentSessionsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetCurrentSessionsPayload>,
  ): PlayersGetCurrentSessionsPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetCurrentSessionsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetCurrentSessionsPayload,
    reader: protoscript.BinaryReader,
  ): PlayersGetCurrentSessionsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CurrentSession = {
  /**
   * Serializes CurrentSession to protobuf.
   */
  encode: function (msg: PartialDeep<CurrentSession>): Uint8Array {
    return CurrentSession._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CurrentSession from protobuf.
   */
  decode: function (bytes: ByteSource): CurrentSession {
    return CurrentSession._readMessage(
      CurrentSession.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CurrentSession with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CurrentSession>): CurrentSession {
    return {
      sessionHash: "",
      status: "",
      tableIndex: undefined,
      players: [],
      timerState: EventsGetTimerStateResponse.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CurrentSession>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.status) {
      writer.writeString(2, msg.status);
    }
    if (msg.tableIndex != undefined) {
      writer.writeInt32(3, msg.tableIndex);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.players as any,
        protoAtoms.PlayerInSession._writeMessage,
      );
    }
    if (msg.timerState) {
      writer.writeMessage(
        5,
        msg.timerState,
        EventsGetTimerStateResponse._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CurrentSession,
    reader: protoscript.BinaryReader,
  ): CurrentSession {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          msg.status = reader.readString();
          break;
        }
        case 3: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 4: {
          const m = protoAtoms.PlayerInSession.initialize();
          reader.readMessage(m, protoAtoms.PlayerInSession._readMessage);
          msg.players.push(m);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.timerState,
            EventsGetTimerStateResponse._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetCurrentSessionsResponse = {
  /**
   * Serializes PlayersGetCurrentSessionsResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetCurrentSessionsResponse>,
  ): Uint8Array {
    return PlayersGetCurrentSessionsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetCurrentSessionsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetCurrentSessionsResponse {
    return PlayersGetCurrentSessionsResponse._readMessage(
      PlayersGetCurrentSessionsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetCurrentSessionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetCurrentSessionsResponse>,
  ): PlayersGetCurrentSessionsResponse {
    return {
      sessions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetCurrentSessionsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessions?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.sessions as any,
        CurrentSession._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetCurrentSessionsResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetCurrentSessionsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = CurrentSession.initialize();
          reader.readMessage(m, CurrentSession._readMessage);
          msg.sessions.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetAllRegisteredPlayersPayload = {
  /**
   * Serializes EventsGetAllRegisteredPlayersPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersPayload>,
  ): Uint8Array {
    return EventsGetAllRegisteredPlayersPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetAllRegisteredPlayersPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetAllRegisteredPlayersPayload {
    return EventsGetAllRegisteredPlayersPayload._readMessage(
      EventsGetAllRegisteredPlayersPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetAllRegisteredPlayersPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAllRegisteredPlayersPayload>,
  ): EventsGetAllRegisteredPlayersPayload {
    return {
      eventIds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventIds?.length) {
      writer.writePackedInt32(1, msg.eventIds);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAllRegisteredPlayersPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetAllRegisteredPlayersPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.eventIds.push(...reader.readPackedInt32());
          } else {
            msg.eventIds.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetAllRegisteredPlayersResponse = {
  /**
   * Serializes EventsGetAllRegisteredPlayersResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersResponse>,
  ): Uint8Array {
    return EventsGetAllRegisteredPlayersResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetAllRegisteredPlayersResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetAllRegisteredPlayersResponse {
    return EventsGetAllRegisteredPlayersResponse._readMessage(
      EventsGetAllRegisteredPlayersResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetAllRegisteredPlayersResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAllRegisteredPlayersResponse>,
  ): EventsGetAllRegisteredPlayersResponse {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.players as any,
        protoAtoms.RegisteredPlayer._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAllRegisteredPlayersResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetAllRegisteredPlayersResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.RegisteredPlayer.initialize();
          reader.readMessage(m, protoAtoms.RegisteredPlayer._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetTimerStateResponse = {
  /**
   * Serializes EventsGetTimerStateResponse to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetTimerStateResponse>): Uint8Array {
    return EventsGetTimerStateResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetTimerStateResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetTimerStateResponse {
    return EventsGetTimerStateResponse._readMessage(
      EventsGetTimerStateResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetTimerStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimerStateResponse>,
  ): EventsGetTimerStateResponse {
    return {
      started: false,
      finished: false,
      timeRemaining: 0,
      waitingForTimer: false,
      haveAutostart: false,
      autostartTimer: false,
      hideSeatingAfter: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimerStateResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.started) {
      writer.writeBool(1, msg.started);
    }
    if (msg.finished) {
      writer.writeBool(2, msg.finished);
    }
    if (msg.timeRemaining) {
      writer.writeInt32(3, msg.timeRemaining);
    }
    if (msg.waitingForTimer) {
      writer.writeBool(4, msg.waitingForTimer);
    }
    if (msg.haveAutostart) {
      writer.writeBool(5, msg.haveAutostart);
    }
    if (msg.autostartTimer) {
      writer.writeBool(6, msg.autostartTimer);
    }
    if (msg.hideSeatingAfter) {
      writer.writeInt32(8, msg.hideSeatingAfter);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimerStateResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetTimerStateResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.started = reader.readBool();
          break;
        }
        case 2: {
          msg.finished = reader.readBool();
          break;
        }
        case 3: {
          msg.timeRemaining = reader.readInt32();
          break;
        }
        case 4: {
          msg.waitingForTimer = reader.readBool();
          break;
        }
        case 5: {
          msg.haveAutostart = reader.readBool();
          break;
        }
        case 6: {
          msg.autostartTimer = reader.readBool();
          break;
        }
        case 8: {
          msg.hideSeatingAfter = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesGetSessionOverviewResponse = {
  /**
   * Serializes GamesGetSessionOverviewResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<GamesGetSessionOverviewResponse>,
  ): Uint8Array {
    return GamesGetSessionOverviewResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesGetSessionOverviewResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GamesGetSessionOverviewResponse {
    return GamesGetSessionOverviewResponse._readMessage(
      GamesGetSessionOverviewResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesGetSessionOverviewResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesGetSessionOverviewResponse>,
  ): GamesGetSessionOverviewResponse {
    return {
      id: 0,
      eventId: 0,
      tableIndex: undefined,
      players: [],
      state: protoAtoms.SessionState.initialize(),
      timerState: EventsGetTimerStateResponse.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesGetSessionOverviewResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.tableIndex != undefined) {
      writer.writeInt32(3, msg.tableIndex);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.players as any,
        protoAtoms.PlayerInSession._writeMessage,
      );
    }
    if (msg.state) {
      writer.writeMessage(5, msg.state, protoAtoms.SessionState._writeMessage);
    }
    if (msg.timerState) {
      writer.writeMessage(
        6,
        msg.timerState,
        EventsGetTimerStateResponse._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesGetSessionOverviewResponse,
    reader: protoscript.BinaryReader,
  ): GamesGetSessionOverviewResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 4: {
          const m = protoAtoms.PlayerInSession.initialize();
          reader.readMessage(m, protoAtoms.PlayerInSession._readMessage);
          msg.players.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.state, protoAtoms.SessionState._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.timerState,
            EventsGetTimerStateResponse._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetPlayerStatsPayload = {
  /**
   * Serializes PlayersGetPlayerStatsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetPlayerStatsPayload>,
  ): Uint8Array {
    return PlayersGetPlayerStatsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetPlayerStatsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetPlayerStatsPayload {
    return PlayersGetPlayerStatsPayload._readMessage(
      PlayersGetPlayerStatsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetPlayerStatsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerStatsPayload>,
  ): PlayersGetPlayerStatsPayload {
    return {
      playerId: 0,
      eventIdList: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerStatsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventIdList?.length) {
      writer.writePackedInt32(2, msg.eventIdList);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerStatsPayload,
    reader: protoscript.BinaryReader,
  ): PlayersGetPlayerStatsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.eventIdList.push(...reader.readPackedInt32());
          } else {
            msg.eventIdList.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetPlayerStatsResponse = {
  /**
   * Serializes PlayersGetPlayerStatsResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetPlayerStatsResponse>,
  ): Uint8Array {
    return PlayersGetPlayerStatsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetPlayerStatsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetPlayerStatsResponse {
    return PlayersGetPlayerStatsResponse._readMessage(
      PlayersGetPlayerStatsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetPlayerStatsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerStatsResponse>,
  ): PlayersGetPlayerStatsResponse {
    return {
      ratingHistory: [],
      scoreHistory: [],
      playersInfo: [],
      placesSummary: [],
      totalPlayedGames: 0,
      totalPlayedRounds: 0,
      winSummary: protoAtoms.PlayerWinSummary.initialize(),
      handsValueSummary: [],
      yakuSummary: [],
      riichiSummary: protoAtoms.RiichiSummary.initialize(),
      doraStat: protoAtoms.DoraSummary.initialize(),
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerStatsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.ratingHistory?.length) {
      writer.writePackedInt32(1, msg.ratingHistory);
    }
    if (msg.scoreHistory?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.scoreHistory as any,
        protoAtoms.SessionHistoryResultTable._writeMessage,
      );
    }
    if (msg.playersInfo?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.playersInfo as any,
        protoAtoms.Player._writeMessage,
      );
    }
    if (msg.placesSummary?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.placesSummary as any,
        protoAtoms.PlacesSummaryItem._writeMessage,
      );
    }
    if (msg.totalPlayedGames) {
      writer.writeInt32(5, msg.totalPlayedGames);
    }
    if (msg.totalPlayedRounds) {
      writer.writeInt32(6, msg.totalPlayedRounds);
    }
    if (msg.winSummary) {
      writer.writeMessage(
        7,
        msg.winSummary,
        protoAtoms.PlayerWinSummary._writeMessage,
      );
    }
    if (msg.handsValueSummary?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.handsValueSummary as any,
        protoAtoms.HandValueStat._writeMessage,
      );
    }
    if (msg.yakuSummary?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.yakuSummary as any,
        protoAtoms.YakuStat._writeMessage,
      );
    }
    if (msg.riichiSummary) {
      writer.writeMessage(
        10,
        msg.riichiSummary,
        protoAtoms.RiichiSummary._writeMessage,
      );
    }
    if (msg.doraStat) {
      writer.writeMessage(
        11,
        msg.doraStat,
        protoAtoms.DoraSummary._writeMessage,
      );
    }
    if (msg.lastUpdate) {
      writer.writeString(12, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerStatsResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetPlayerStatsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.ratingHistory.push(...reader.readPackedInt32());
          } else {
            msg.ratingHistory.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          const m = protoAtoms.SessionHistoryResultTable.initialize();
          reader.readMessage(
            m,
            protoAtoms.SessionHistoryResultTable._readMessage,
          );
          msg.scoreHistory.push(m);
          break;
        }
        case 3: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.playersInfo.push(m);
          break;
        }
        case 4: {
          const m = protoAtoms.PlacesSummaryItem.initialize();
          reader.readMessage(m, protoAtoms.PlacesSummaryItem._readMessage);
          msg.placesSummary.push(m);
          break;
        }
        case 5: {
          msg.totalPlayedGames = reader.readInt32();
          break;
        }
        case 6: {
          msg.totalPlayedRounds = reader.readInt32();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.winSummary,
            protoAtoms.PlayerWinSummary._readMessage,
          );
          break;
        }
        case 8: {
          const m = protoAtoms.HandValueStat.initialize();
          reader.readMessage(m, protoAtoms.HandValueStat._readMessage);
          msg.handsValueSummary.push(m);
          break;
        }
        case 9: {
          const m = protoAtoms.YakuStat.initialize();
          reader.readMessage(m, protoAtoms.YakuStat._readMessage);
          msg.yakuSummary.push(m);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.riichiSummary,
            protoAtoms.RiichiSummary._readMessage,
          );
          break;
        }
        case 11: {
          reader.readMessage(msg.doraStat, protoAtoms.DoraSummary._readMessage);
          break;
        }
        case 12: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddRoundPayload = {
  /**
   * Serializes GamesAddRoundPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesAddRoundPayload>): Uint8Array {
    return GamesAddRoundPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddRoundPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddRoundPayload {
    return GamesAddRoundPayload._readMessage(
      GamesAddRoundPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddRoundPayload>,
  ): GamesAddRoundPayload {
    return {
      sessionHash: "",
      roundData: protoAtoms.Round.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddRoundPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.roundData) {
      writer.writeMessage(2, msg.roundData, protoAtoms.Round._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddRoundPayload,
    reader: protoscript.BinaryReader,
  ): GamesAddRoundPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.roundData, protoAtoms.Round._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddRoundResponse = {
  /**
   * Serializes GamesAddRoundResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GamesAddRoundResponse>): Uint8Array {
    return GamesAddRoundResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddRoundResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddRoundResponse {
    return GamesAddRoundResponse._readMessage(
      GamesAddRoundResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddRoundResponse>,
  ): GamesAddRoundResponse {
    return {
      scores: [],
      round: 0,
      honba: 0,
      riichiBets: 0,
      prematurelyFinished: false,
      roundJustChanged: false,
      isFinished: false,
      lastHandStarted: false,
      lastOutcome: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddRoundResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.scores?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.scores as any,
        protoAtoms.IntermediateResultOfSession._writeMessage,
      );
    }
    if (msg.round) {
      writer.writeInt32(3, msg.round);
    }
    if (msg.honba) {
      writer.writeInt32(4, msg.honba);
    }
    if (msg.riichiBets) {
      writer.writeInt32(5, msg.riichiBets);
    }
    if (msg.prematurelyFinished) {
      writer.writeBool(6, msg.prematurelyFinished);
    }
    if (msg.roundJustChanged) {
      writer.writeBool(7, msg.roundJustChanged);
    }
    if (msg.isFinished) {
      writer.writeBool(8, msg.isFinished);
    }
    if (msg.lastHandStarted) {
      writer.writeBool(9, msg.lastHandStarted);
    }
    if (msg.lastOutcome != undefined) {
      writer.writeEnum(10, protoAtoms.RoundOutcome._toInt(msg.lastOutcome));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddRoundResponse,
    reader: protoscript.BinaryReader,
  ): GamesAddRoundResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.IntermediateResultOfSession.initialize();
          reader.readMessage(
            m,
            protoAtoms.IntermediateResultOfSession._readMessage,
          );
          msg.scores.push(m);
          break;
        }
        case 3: {
          msg.round = reader.readInt32();
          break;
        }
        case 4: {
          msg.honba = reader.readInt32();
          break;
        }
        case 5: {
          msg.riichiBets = reader.readInt32();
          break;
        }
        case 6: {
          msg.prematurelyFinished = reader.readBool();
          break;
        }
        case 7: {
          msg.roundJustChanged = reader.readBool();
          break;
        }
        case 8: {
          msg.isFinished = reader.readBool();
          break;
        }
        case 9: {
          msg.lastHandStarted = reader.readBool();
          break;
        }
        case 10: {
          msg.lastOutcome = protoAtoms.RoundOutcome._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesPreviewRoundPayload = {
  /**
   * Serializes GamesPreviewRoundPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesPreviewRoundPayload>): Uint8Array {
    return GamesPreviewRoundPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesPreviewRoundPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesPreviewRoundPayload {
    return GamesPreviewRoundPayload._readMessage(
      GamesPreviewRoundPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesPreviewRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesPreviewRoundPayload>,
  ): GamesPreviewRoundPayload {
    return {
      sessionHash: "",
      roundData: protoAtoms.Round.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesPreviewRoundPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.roundData) {
      writer.writeMessage(2, msg.roundData, protoAtoms.Round._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesPreviewRoundPayload,
    reader: protoscript.BinaryReader,
  ): GamesPreviewRoundPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.roundData, protoAtoms.Round._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesPreviewRoundResponse = {
  /**
   * Serializes GamesPreviewRoundResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GamesPreviewRoundResponse>): Uint8Array {
    return GamesPreviewRoundResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesPreviewRoundResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GamesPreviewRoundResponse {
    return GamesPreviewRoundResponse._readMessage(
      GamesPreviewRoundResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesPreviewRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesPreviewRoundResponse>,
  ): GamesPreviewRoundResponse {
    return {
      state: protoAtoms.RoundState.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesPreviewRoundResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.state) {
      writer.writeMessage(1, msg.state, protoAtoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesPreviewRoundResponse,
    reader: protoscript.BinaryReader,
  ): GamesPreviewRoundResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.state, protoAtoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddOnlineReplayPayload = {
  /**
   * Serializes GamesAddOnlineReplayPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesAddOnlineReplayPayload>): Uint8Array {
    return GamesAddOnlineReplayPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddOnlineReplayPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddOnlineReplayPayload {
    return GamesAddOnlineReplayPayload._readMessage(
      GamesAddOnlineReplayPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddOnlineReplayPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddOnlineReplayPayload>,
  ): GamesAddOnlineReplayPayload {
    return {
      eventId: 0,
      link: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddOnlineReplayPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.link) {
      writer.writeString(2, msg.link);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddOnlineReplayPayload,
    reader: protoscript.BinaryReader,
  ): GamesAddOnlineReplayPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.link = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddOnlineReplayResponse = {
  /**
   * Serializes GamesAddOnlineReplayResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<GamesAddOnlineReplayResponse>,
  ): Uint8Array {
    return GamesAddOnlineReplayResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddOnlineReplayResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddOnlineReplayResponse {
    return GamesAddOnlineReplayResponse._readMessage(
      GamesAddOnlineReplayResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddOnlineReplayResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddOnlineReplayResponse>,
  ): GamesAddOnlineReplayResponse {
    return {
      game: protoAtoms.GameResult.initialize(),
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddOnlineReplayResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.game) {
      writer.writeMessage(1, msg.game, protoAtoms.GameResult._writeMessage);
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        protoAtoms.Player._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddOnlineReplayResponse,
    reader: protoscript.BinaryReader,
  ): GamesAddOnlineReplayResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.game, protoAtoms.GameResult._readMessage);
          break;
        }
        case 2: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetLastResultsPayload = {
  /**
   * Serializes PlayersGetLastResultsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetLastResultsPayload>,
  ): Uint8Array {
    return PlayersGetLastResultsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetLastResultsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetLastResultsPayload {
    return PlayersGetLastResultsPayload._readMessage(
      PlayersGetLastResultsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetLastResultsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastResultsPayload>,
  ): PlayersGetLastResultsPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastResultsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastResultsPayload,
    reader: protoscript.BinaryReader,
  ): PlayersGetLastResultsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetLastResultsResponse = {
  /**
   * Serializes PlayersGetLastResultsResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetLastResultsResponse>,
  ): Uint8Array {
    return PlayersGetLastResultsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetLastResultsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetLastResultsResponse {
    return PlayersGetLastResultsResponse._readMessage(
      PlayersGetLastResultsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetLastResultsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastResultsResponse>,
  ): PlayersGetLastResultsResponse {
    return {
      results: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastResultsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.results?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.results as any,
        protoAtoms.SessionHistoryResult._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastResultsResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetLastResultsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.SessionHistoryResult.initialize();
          reader.readMessage(m, protoAtoms.SessionHistoryResult._readMessage);
          msg.results.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetLastRoundPayload = {
  /**
   * Serializes PlayersGetLastRoundPayload to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetLastRoundPayload>): Uint8Array {
    return PlayersGetLastRoundPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetLastRoundPayload from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetLastRoundPayload {
    return PlayersGetLastRoundPayload._readMessage(
      PlayersGetLastRoundPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetLastRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundPayload>,
  ): PlayersGetLastRoundPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundPayload,
    reader: protoscript.BinaryReader,
  ): PlayersGetLastRoundPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetLastRoundResponse = {
  /**
   * Serializes PlayersGetLastRoundResponse to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetLastRoundResponse>): Uint8Array {
    return PlayersGetLastRoundResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetLastRoundResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetLastRoundResponse {
    return PlayersGetLastRoundResponse._readMessage(
      PlayersGetLastRoundResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetLastRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundResponse>,
  ): PlayersGetLastRoundResponse {
    return {
      round: protoAtoms.RoundState.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.round) {
      writer.writeMessage(1, msg.round, protoAtoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetLastRoundResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.round, protoAtoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetAllRoundsResponse = {
  /**
   * Serializes PlayersGetAllRoundsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetAllRoundsResponse>): Uint8Array {
    return PlayersGetAllRoundsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetAllRoundsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetAllRoundsResponse {
    return PlayersGetAllRoundsResponse._readMessage(
      PlayersGetAllRoundsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetAllRoundsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetAllRoundsResponse>,
  ): PlayersGetAllRoundsResponse {
    return {
      rounds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetAllRoundsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.rounds?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.rounds as any,
        protoAtoms.RoundState._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetAllRoundsResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetAllRoundsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.RoundState.initialize();
          reader.readMessage(m, protoAtoms.RoundState._readMessage);
          msg.rounds.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetLastRoundByHashResponse = {
  /**
   * Serializes PlayersGetLastRoundByHashResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<PlayersGetLastRoundByHashResponse>,
  ): Uint8Array {
    return PlayersGetLastRoundByHashResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetLastRoundByHashResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetLastRoundByHashResponse {
    return PlayersGetLastRoundByHashResponse._readMessage(
      PlayersGetLastRoundByHashResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetLastRoundByHashResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundByHashResponse>,
  ): PlayersGetLastRoundByHashResponse {
    return {
      round: protoAtoms.RoundState.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundByHashResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.round) {
      writer.writeMessage(1, msg.round, protoAtoms.RoundState._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundByHashResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetLastRoundByHashResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.round, protoAtoms.RoundState._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventForEditPayload = {
  /**
   * Serializes EventsGetEventForEditPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetEventForEditPayload>,
  ): Uint8Array {
    return EventsGetEventForEditPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventForEditPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventForEditPayload {
    return EventsGetEventForEditPayload._readMessage(
      EventsGetEventForEditPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventForEditPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventForEditPayload>,
  ): EventsGetEventForEditPayload {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventForEditPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventForEditPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetEventForEditPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetEventForEditResponse = {
  /**
   * Serializes EventsGetEventForEditResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetEventForEditResponse>,
  ): Uint8Array {
    return EventsGetEventForEditResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetEventForEditResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetEventForEditResponse {
    return EventsGetEventForEditResponse._readMessage(
      EventsGetEventForEditResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetEventForEditResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventForEditResponse>,
  ): EventsGetEventForEditResponse {
    return {
      id: 0,
      event: protoAtoms.EventData.initialize(),
      finished: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventForEditResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.event) {
      writer.writeMessage(2, msg.event, protoAtoms.EventData._writeMessage);
    }
    if (msg.finished) {
      writer.writeBool(3, msg.finished);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventForEditResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetEventForEditResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          reader.readMessage(msg.event, protoAtoms.EventData._readMessage);
          break;
        }
        case 3: {
          msg.finished = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdateEventPayload = {
  /**
   * Serializes EventsUpdateEventPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsUpdateEventPayload>): Uint8Array {
    return EventsUpdateEventPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdateEventPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUpdateEventPayload {
    return EventsUpdateEventPayload._readMessage(
      EventsUpdateEventPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdateEventPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdateEventPayload>,
  ): EventsUpdateEventPayload {
    return {
      id: 0,
      event: protoAtoms.EventData.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdateEventPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.event) {
      writer.writeMessage(2, msg.event, protoAtoms.EventData._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdateEventPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdateEventPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          reader.readMessage(msg.event, protoAtoms.EventData._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetTablesStatePayload = {
  /**
   * Serializes EventsGetTablesStatePayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsGetTablesStatePayload>): Uint8Array {
    return EventsGetTablesStatePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetTablesStatePayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetTablesStatePayload {
    return EventsGetTablesStatePayload._readMessage(
      EventsGetTablesStatePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetTablesStatePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTablesStatePayload>,
  ): EventsGetTablesStatePayload {
    return {
      eventId: 0,
      omitLastRound: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTablesStatePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.omitLastRound) {
      writer.writeBool(2, msg.omitLastRound);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTablesStatePayload,
    reader: protoscript.BinaryReader,
  ): EventsGetTablesStatePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.omitLastRound = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetTablesStateResponse = {
  /**
   * Serializes EventsGetTablesStateResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetTablesStateResponse>,
  ): Uint8Array {
    return EventsGetTablesStateResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetTablesStateResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetTablesStateResponse {
    return EventsGetTablesStateResponse._readMessage(
      EventsGetTablesStateResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetTablesStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTablesStateResponse>,
  ): EventsGetTablesStateResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTablesStateResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        protoAtoms.TableState._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTablesStateResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetTablesStateResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.TableState.initialize();
          reader.readMessage(m, protoAtoms.TableState._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsRegisterPlayerPayload = {
  /**
   * Serializes EventsRegisterPlayerPayload to protobuf.
   */
  encode: function (msg: PartialDeep<EventsRegisterPlayerPayload>): Uint8Array {
    return EventsRegisterPlayerPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsRegisterPlayerPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsRegisterPlayerPayload {
    return EventsRegisterPlayerPayload._readMessage(
      EventsRegisterPlayerPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsRegisterPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsRegisterPlayerPayload>,
  ): EventsRegisterPlayerPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsRegisterPlayerPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsRegisterPlayerPayload,
    reader: protoscript.BinaryReader,
  ): EventsRegisterPlayerPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUnregisterPlayerPayload = {
  /**
   * Serializes EventsUnregisterPlayerPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUnregisterPlayerPayload>,
  ): Uint8Array {
    return EventsUnregisterPlayerPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUnregisterPlayerPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUnregisterPlayerPayload {
    return EventsUnregisterPlayerPayload._readMessage(
      EventsUnregisterPlayerPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUnregisterPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUnregisterPlayerPayload>,
  ): EventsUnregisterPlayerPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUnregisterPlayerPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUnregisterPlayerPayload,
    reader: protoscript.BinaryReader,
  ): EventsUnregisterPlayerPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdatePlayerSeatingFlagPayload = {
  /**
   * Serializes EventsUpdatePlayerSeatingFlagPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayerSeatingFlagPayload>,
  ): Uint8Array {
    return EventsUpdatePlayerSeatingFlagPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdatePlayerSeatingFlagPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUpdatePlayerSeatingFlagPayload {
    return EventsUpdatePlayerSeatingFlagPayload._readMessage(
      EventsUpdatePlayerSeatingFlagPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdatePlayerSeatingFlagPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayerSeatingFlagPayload>,
  ): EventsUpdatePlayerSeatingFlagPayload {
    return {
      playerId: 0,
      eventId: 0,
      ignoreSeating: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayerSeatingFlagPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.ignoreSeating) {
      writer.writeBool(3, msg.ignoreSeating);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayerSeatingFlagPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdatePlayerSeatingFlagPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.ignoreSeating = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetAchievementsPayload = {
  /**
   * Serializes EventsGetAchievementsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetAchievementsPayload>,
  ): Uint8Array {
    return EventsGetAchievementsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetAchievementsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetAchievementsPayload {
    return EventsGetAchievementsPayload._readMessage(
      EventsGetAchievementsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetAchievementsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAchievementsPayload>,
  ): EventsGetAchievementsPayload {
    return {
      achievementsList: [],
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAchievementsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.achievementsList?.length) {
      writer.writeRepeatedString(2, msg.achievementsList);
    }
    if (msg.eventId) {
      writer.writeInt32(3, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAchievementsPayload,
    reader: protoscript.BinaryReader,
  ): EventsGetAchievementsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2: {
          msg.achievementsList.push(reader.readString());
          break;
        }
        case 3: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetAchievementsResponse = {
  /**
   * Serializes EventsGetAchievementsResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetAchievementsResponse>,
  ): Uint8Array {
    return EventsGetAchievementsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetAchievementsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetAchievementsResponse {
    return EventsGetAchievementsResponse._readMessage(
      EventsGetAchievementsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetAchievementsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAchievementsResponse>,
  ): EventsGetAchievementsResponse {
    return {
      achievements: [],
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAchievementsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.achievements?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.achievements as any,
        protoAtoms.Achievement._writeMessage,
      );
    }
    if (msg.lastUpdate) {
      writer.writeString(2, msg.lastUpdate);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAchievementsResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetAchievementsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.Achievement.initialize();
          reader.readMessage(m, protoAtoms.Achievement._readMessage);
          msg.achievements.push(m);
          break;
        }
        case 2: {
          msg.lastUpdate = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdatePlayersLocalIdsPayload = {
  /**
   * Serializes EventsUpdatePlayersLocalIdsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayersLocalIdsPayload>,
  ): Uint8Array {
    return EventsUpdatePlayersLocalIdsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdatePlayersLocalIdsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUpdatePlayersLocalIdsPayload {
    return EventsUpdatePlayersLocalIdsPayload._readMessage(
      EventsUpdatePlayersLocalIdsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdatePlayersLocalIdsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayersLocalIdsPayload>,
  ): EventsUpdatePlayersLocalIdsPayload {
    return {
      eventId: 0,
      idsToLocalIds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayersLocalIdsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.idsToLocalIds?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.idsToLocalIds as any,
        protoAtoms.LocalIdMapping._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayersLocalIdsPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdatePlayersLocalIdsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          const m = protoAtoms.LocalIdMapping.initialize();
          reader.readMessage(m, protoAtoms.LocalIdMapping._readMessage);
          msg.idsToLocalIds.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdatePlayerReplacementPayload = {
  /**
   * Serializes EventsUpdatePlayerReplacementPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayerReplacementPayload>,
  ): Uint8Array {
    return EventsUpdatePlayerReplacementPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdatePlayerReplacementPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUpdatePlayerReplacementPayload {
    return EventsUpdatePlayerReplacementPayload._readMessage(
      EventsUpdatePlayerReplacementPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdatePlayerReplacementPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayerReplacementPayload>,
  ): EventsUpdatePlayerReplacementPayload {
    return {
      playerId: 0,
      eventId: 0,
      replacementId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayerReplacementPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    if (msg.replacementId) {
      writer.writeInt32(3, msg.replacementId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayerReplacementPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdatePlayerReplacementPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 3: {
          msg.replacementId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdatePlayersTeamsPayload = {
  /**
   * Serializes EventsUpdatePlayersTeamsPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayersTeamsPayload>,
  ): Uint8Array {
    return EventsUpdatePlayersTeamsPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdatePlayersTeamsPayload from protobuf.
   */
  decode: function (bytes: ByteSource): EventsUpdatePlayersTeamsPayload {
    return EventsUpdatePlayersTeamsPayload._readMessage(
      EventsUpdatePlayersTeamsPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdatePlayersTeamsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayersTeamsPayload>,
  ): EventsUpdatePlayersTeamsPayload {
    return {
      eventId: 0,
      idsToTeamNames: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayersTeamsPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.idsToTeamNames?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.idsToTeamNames as any,
        protoAtoms.TeamMapping._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayersTeamsPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdatePlayersTeamsPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          const m = protoAtoms.TeamMapping.initialize();
          reader.readMessage(m, protoAtoms.TeamMapping._readMessage);
          msg.idsToTeamNames.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesStartGamePayload = {
  /**
   * Serializes GamesStartGamePayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesStartGamePayload>): Uint8Array {
    return GamesStartGamePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesStartGamePayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesStartGamePayload {
    return GamesStartGamePayload._readMessage(
      GamesStartGamePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesStartGamePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesStartGamePayload>,
  ): GamesStartGamePayload {
    return {
      eventId: 0,
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesStartGamePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.players?.length) {
      writer.writePackedInt32(2, msg.players);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesStartGamePayload,
    reader: protoscript.BinaryReader,
  ): GamesStartGamePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.players.push(...reader.readPackedInt32());
          } else {
            msg.players.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesDropLastRoundPayload = {
  /**
   * Serializes GamesDropLastRoundPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesDropLastRoundPayload>): Uint8Array {
    return GamesDropLastRoundPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesDropLastRoundPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesDropLastRoundPayload {
    return GamesDropLastRoundPayload._readMessage(
      GamesDropLastRoundPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesDropLastRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesDropLastRoundPayload>,
  ): GamesDropLastRoundPayload {
    return {
      sessionHash: "",
      intermediateResults: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesDropLastRoundPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHash) {
      writer.writeString(1, msg.sessionHash);
    }
    if (msg.intermediateResults?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.intermediateResults as any,
        protoAtoms.IntermediateResultOfSession._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesDropLastRoundPayload,
    reader: protoscript.BinaryReader,
  ): GamesDropLastRoundPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHash = reader.readString();
          break;
        }
        case 2: {
          const m = protoAtoms.IntermediateResultOfSession.initialize();
          reader.readMessage(
            m,
            protoAtoms.IntermediateResultOfSession._readMessage,
          );
          msg.intermediateResults.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddPenaltyPayload = {
  /**
   * Serializes GamesAddPenaltyPayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesAddPenaltyPayload>): Uint8Array {
    return GamesAddPenaltyPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddPenaltyPayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddPenaltyPayload {
    return GamesAddPenaltyPayload._readMessage(
      GamesAddPenaltyPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddPenaltyPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddPenaltyPayload>,
  ): GamesAddPenaltyPayload {
    return {
      eventId: 0,
      playerId: 0,
      amount: 0,
      reason: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddPenaltyPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.playerId) {
      writer.writeInt32(2, msg.playerId);
    }
    if (msg.amount) {
      writer.writeInt32(3, msg.amount);
    }
    if (msg.reason) {
      writer.writeString(4, msg.reason);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddPenaltyPayload,
    reader: protoscript.BinaryReader,
  ): GamesAddPenaltyPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.playerId = reader.readInt32();
          break;
        }
        case 3: {
          msg.amount = reader.readInt32();
          break;
        }
        case 4: {
          msg.reason = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GamesAddPenaltyGamePayload = {
  /**
   * Serializes GamesAddPenaltyGamePayload to protobuf.
   */
  encode: function (msg: PartialDeep<GamesAddPenaltyGamePayload>): Uint8Array {
    return GamesAddPenaltyGamePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GamesAddPenaltyGamePayload from protobuf.
   */
  decode: function (bytes: ByteSource): GamesAddPenaltyGamePayload {
    return GamesAddPenaltyGamePayload._readMessage(
      GamesAddPenaltyGamePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GamesAddPenaltyGamePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddPenaltyGamePayload>,
  ): GamesAddPenaltyGamePayload {
    return {
      eventId: 0,
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddPenaltyGamePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.players?.length) {
      writer.writePackedInt32(2, msg.players);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddPenaltyGamePayload,
    reader: protoscript.BinaryReader,
  ): GamesAddPenaltyGamePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.players.push(...reader.readPackedInt32());
          } else {
            msg.players.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetPlayerPayload = {
  /**
   * Serializes PlayersGetPlayerPayload to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerPayload>): Uint8Array {
    return PlayersGetPlayerPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetPlayerPayload from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetPlayerPayload {
    return PlayersGetPlayerPayload._readMessage(
      PlayersGetPlayerPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerPayload>,
  ): PlayersGetPlayerPayload {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerPayload,
    reader: protoscript.BinaryReader,
  ): PlayersGetPlayerPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PlayersGetPlayerResponse = {
  /**
   * Serializes PlayersGetPlayerResponse to protobuf.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerResponse>): Uint8Array {
    return PlayersGetPlayerResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PlayersGetPlayerResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PlayersGetPlayerResponse {
    return PlayersGetPlayerResponse._readMessage(
      PlayersGetPlayerResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PlayersGetPlayerResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerResponse>,
  ): PlayersGetPlayerResponse {
    return {
      players: protoAtoms.Player.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.players) {
      writer.writeMessage(1, msg.players, protoAtoms.Player._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerResponse,
    reader: protoscript.BinaryReader,
  ): PlayersGetPlayerResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.players, protoAtoms.Player._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetCurrentSeatingResponse = {
  /**
   * Serializes EventsGetCurrentSeatingResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetCurrentSeatingResponse>,
  ): Uint8Array {
    return EventsGetCurrentSeatingResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetCurrentSeatingResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetCurrentSeatingResponse {
    return EventsGetCurrentSeatingResponse._readMessage(
      EventsGetCurrentSeatingResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetCurrentSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCurrentSeatingResponse>,
  ): EventsGetCurrentSeatingResponse {
    return {
      seating: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCurrentSeatingResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.seating?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.seating as any,
        protoAtoms.PlayerSeating._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCurrentSeatingResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetCurrentSeatingResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.PlayerSeating.initialize();
          reader.readMessage(m, protoAtoms.PlayerSeating._readMessage);
          msg.seating.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingMakeShuffledSeatingPayload = {
  /**
   * Serializes SeatingMakeShuffledSeatingPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingMakeShuffledSeatingPayload>,
  ): Uint8Array {
    return SeatingMakeShuffledSeatingPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingMakeShuffledSeatingPayload from protobuf.
   */
  decode: function (bytes: ByteSource): SeatingMakeShuffledSeatingPayload {
    return SeatingMakeShuffledSeatingPayload._readMessage(
      SeatingMakeShuffledSeatingPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingMakeShuffledSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakeShuffledSeatingPayload>,
  ): SeatingMakeShuffledSeatingPayload {
    return {
      eventId: 0,
      groupsCount: 0,
      seed: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakeShuffledSeatingPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.groupsCount) {
      writer.writeInt32(2, msg.groupsCount);
    }
    if (msg.seed) {
      writer.writeInt32(3, msg.seed);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakeShuffledSeatingPayload,
    reader: protoscript.BinaryReader,
  ): SeatingMakeShuffledSeatingPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.groupsCount = reader.readInt32();
          break;
        }
        case 3: {
          msg.seed = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingGenerateSwissSeatingPayload = {
  /**
   * Serializes SeatingGenerateSwissSeatingPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingPayload>,
  ): Uint8Array {
    return SeatingGenerateSwissSeatingPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingGenerateSwissSeatingPayload from protobuf.
   */
  decode: function (bytes: ByteSource): SeatingGenerateSwissSeatingPayload {
    return SeatingGenerateSwissSeatingPayload._readMessage(
      SeatingGenerateSwissSeatingPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingGenerateSwissSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGenerateSwissSeatingPayload>,
  ): SeatingGenerateSwissSeatingPayload {
    return {
      eventId: 0,
      substituteReplacementPlayers: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.substituteReplacementPlayers) {
      writer.writeBool(2, msg.substituteReplacementPlayers);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGenerateSwissSeatingPayload,
    reader: protoscript.BinaryReader,
  ): SeatingGenerateSwissSeatingPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.substituteReplacementPlayers = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingGenerateSwissSeatingResponse = {
  /**
   * Serializes SeatingGenerateSwissSeatingResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingResponse>,
  ): Uint8Array {
    return SeatingGenerateSwissSeatingResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingGenerateSwissSeatingResponse from protobuf.
   */
  decode: function (bytes: ByteSource): SeatingGenerateSwissSeatingResponse {
    return SeatingGenerateSwissSeatingResponse._readMessage(
      SeatingGenerateSwissSeatingResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingGenerateSwissSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGenerateSwissSeatingResponse>,
  ): SeatingGenerateSwissSeatingResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        protoAtoms.TableItemSwiss._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGenerateSwissSeatingResponse,
    reader: protoscript.BinaryReader,
  ): SeatingGenerateSwissSeatingResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.TableItemSwiss.initialize();
          reader.readMessage(m, protoAtoms.TableItemSwiss._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingMakeIntervalSeatingPayload = {
  /**
   * Serializes SeatingMakeIntervalSeatingPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingMakeIntervalSeatingPayload>,
  ): Uint8Array {
    return SeatingMakeIntervalSeatingPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingMakeIntervalSeatingPayload from protobuf.
   */
  decode: function (bytes: ByteSource): SeatingMakeIntervalSeatingPayload {
    return SeatingMakeIntervalSeatingPayload._readMessage(
      SeatingMakeIntervalSeatingPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingMakeIntervalSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakeIntervalSeatingPayload>,
  ): SeatingMakeIntervalSeatingPayload {
    return {
      eventId: 0,
      step: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakeIntervalSeatingPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.step) {
      writer.writeInt32(2, msg.step);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakeIntervalSeatingPayload,
    reader: protoscript.BinaryReader,
  ): SeatingMakeIntervalSeatingPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.step = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingMakePrescriptedSeatingPayload = {
  /**
   * Serializes SeatingMakePrescriptedSeatingPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingMakePrescriptedSeatingPayload>,
  ): Uint8Array {
    return SeatingMakePrescriptedSeatingPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingMakePrescriptedSeatingPayload from protobuf.
   */
  decode: function (bytes: ByteSource): SeatingMakePrescriptedSeatingPayload {
    return SeatingMakePrescriptedSeatingPayload._readMessage(
      SeatingMakePrescriptedSeatingPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingMakePrescriptedSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakePrescriptedSeatingPayload>,
  ): SeatingMakePrescriptedSeatingPayload {
    return {
      eventId: 0,
      randomizeAtTables: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakePrescriptedSeatingPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.randomizeAtTables) {
      writer.writeBool(2, msg.randomizeAtTables);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakePrescriptedSeatingPayload,
    reader: protoscript.BinaryReader,
  ): SeatingMakePrescriptedSeatingPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.randomizeAtTables = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SeatingGetNextPrescriptedSeatingResponse = {
  /**
   * Serializes SeatingGetNextPrescriptedSeatingResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<SeatingGetNextPrescriptedSeatingResponse>,
  ): Uint8Array {
    return SeatingGetNextPrescriptedSeatingResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SeatingGetNextPrescriptedSeatingResponse from protobuf.
   */
  decode: function (
    bytes: ByteSource,
  ): SeatingGetNextPrescriptedSeatingResponse {
    return SeatingGetNextPrescriptedSeatingResponse._readMessage(
      SeatingGetNextPrescriptedSeatingResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SeatingGetNextPrescriptedSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGetNextPrescriptedSeatingResponse>,
  ): SeatingGetNextPrescriptedSeatingResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGetNextPrescriptedSeatingResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tables?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.tables as any,
        protoAtoms.PrescriptedTable._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGetNextPrescriptedSeatingResponse,
    reader: protoscript.BinaryReader,
  ): SeatingGetNextPrescriptedSeatingResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.PrescriptedTable.initialize();
          reader.readMessage(m, protoAtoms.PrescriptedTable._readMessage);
          msg.tables.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetPrescriptedEventConfigResponse = {
  /**
   * Serializes EventsGetPrescriptedEventConfigResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetPrescriptedEventConfigResponse>,
  ): Uint8Array {
    return EventsGetPrescriptedEventConfigResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetPrescriptedEventConfigResponse from protobuf.
   */
  decode: function (
    bytes: ByteSource,
  ): EventsGetPrescriptedEventConfigResponse {
    return EventsGetPrescriptedEventConfigResponse._readMessage(
      EventsGetPrescriptedEventConfigResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetPrescriptedEventConfigResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetPrescriptedEventConfigResponse>,
  ): EventsGetPrescriptedEventConfigResponse {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: undefined,
      errors: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetPrescriptedEventConfigResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.nextSessionIndex) {
      writer.writeInt32(2, msg.nextSessionIndex);
    }
    if (msg.prescript != undefined) {
      writer.writeString(3, msg.prescript);
    }
    if (msg.errors?.length) {
      writer.writeRepeatedString(4, msg.errors);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetPrescriptedEventConfigResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetPrescriptedEventConfigResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.nextSessionIndex = reader.readInt32();
          break;
        }
        case 3: {
          msg.prescript = reader.readString();
          break;
        }
        case 4: {
          msg.errors.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsUpdatePrescriptedEventConfigPayload = {
  /**
   * Serializes EventsUpdatePrescriptedEventConfigPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePrescriptedEventConfigPayload>,
  ): Uint8Array {
    return EventsUpdatePrescriptedEventConfigPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsUpdatePrescriptedEventConfigPayload from protobuf.
   */
  decode: function (
    bytes: ByteSource,
  ): EventsUpdatePrescriptedEventConfigPayload {
    return EventsUpdatePrescriptedEventConfigPayload._readMessage(
      EventsUpdatePrescriptedEventConfigPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsUpdatePrescriptedEventConfigPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePrescriptedEventConfigPayload>,
  ): EventsUpdatePrescriptedEventConfigPayload {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePrescriptedEventConfigPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.nextSessionIndex) {
      writer.writeInt32(2, msg.nextSessionIndex);
    }
    if (msg.prescript) {
      writer.writeString(3, msg.prescript);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePrescriptedEventConfigPayload,
    reader: protoscript.BinaryReader,
  ): EventsUpdatePrescriptedEventConfigPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.nextSessionIndex = reader.readInt32();
          break;
        }
        case 3: {
          msg.prescript = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EventsGetStartingTimerResponse = {
  /**
   * Serializes EventsGetStartingTimerResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<EventsGetStartingTimerResponse>,
  ): Uint8Array {
    return EventsGetStartingTimerResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes EventsGetStartingTimerResponse from protobuf.
   */
  decode: function (bytes: ByteSource): EventsGetStartingTimerResponse {
    return EventsGetStartingTimerResponse._readMessage(
      EventsGetStartingTimerResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes EventsGetStartingTimerResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetStartingTimerResponse>,
  ): EventsGetStartingTimerResponse {
    return {
      timer: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetStartingTimerResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.timer) {
      writer.writeInt32(1, msg.timer);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetStartingTimerResponse,
    reader: protoscript.BinaryReader,
  ): EventsGetStartingTimerResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.timer = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ClearStatCachePayload = {
  /**
   * Serializes ClearStatCachePayload to protobuf.
   */
  encode: function (msg: PartialDeep<ClearStatCachePayload>): Uint8Array {
    return ClearStatCachePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ClearStatCachePayload from protobuf.
   */
  decode: function (bytes: ByteSource): ClearStatCachePayload {
    return ClearStatCachePayload._readMessage(
      ClearStatCachePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ClearStatCachePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ClearStatCachePayload>,
  ): ClearStatCachePayload {
    return {
      playerId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ClearStatCachePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.playerId) {
      writer.writeInt32(1, msg.playerId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ClearStatCachePayload,
    reader: protoscript.BinaryReader,
  ): ClearStatCachePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.playerId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TypedGamesAddOnlineReplayPayload = {
  /**
   * Serializes TypedGamesAddOnlineReplayPayload to protobuf.
   */
  encode: function (
    msg: PartialDeep<TypedGamesAddOnlineReplayPayload>,
  ): Uint8Array {
    return TypedGamesAddOnlineReplayPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TypedGamesAddOnlineReplayPayload from protobuf.
   */
  decode: function (bytes: ByteSource): TypedGamesAddOnlineReplayPayload {
    return TypedGamesAddOnlineReplayPayload._readMessage(
      TypedGamesAddOnlineReplayPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TypedGamesAddOnlineReplayPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<TypedGamesAddOnlineReplayPayload>,
  ): TypedGamesAddOnlineReplayPayload {
    return {
      eventId: 0,
      platformId: 0,
      contentType: 0,
      logTimestamp: 0,
      replayHash: "",
      content: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TypedGamesAddOnlineReplayPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.platformId) {
      writer.writeInt32(2, msg.platformId);
    }
    if (msg.contentType) {
      writer.writeInt32(3, msg.contentType);
    }
    if (msg.logTimestamp) {
      writer.writeInt32(4, msg.logTimestamp);
    }
    if (msg.replayHash) {
      writer.writeString(5, msg.replayHash);
    }
    if (msg.content) {
      writer.writeString(6, msg.content);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TypedGamesAddOnlineReplayPayload,
    reader: protoscript.BinaryReader,
  ): TypedGamesAddOnlineReplayPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.platformId = reader.readInt32();
          break;
        }
        case 3: {
          msg.contentType = reader.readInt32();
          break;
        }
        case 4: {
          msg.logTimestamp = reader.readInt32();
          break;
        }
        case 5: {
          msg.replayHash = reader.readString();
          break;
        }
        case 6: {
          msg.content = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CallRefereePayload = {
  /**
   * Serializes CallRefereePayload to protobuf.
   */
  encode: function (msg: PartialDeep<CallRefereePayload>): Uint8Array {
    return CallRefereePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CallRefereePayload from protobuf.
   */
  decode: function (bytes: ByteSource): CallRefereePayload {
    return CallRefereePayload._readMessage(
      CallRefereePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CallRefereePayload with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CallRefereePayload>): CallRefereePayload {
    return {
      tableIndex: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CallRefereePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.tableIndex) {
      writer.writeInt32(1, msg.tableIndex);
    }
    if (msg.eventId) {
      writer.writeInt32(2, msg.eventId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CallRefereePayload,
    reader: protoscript.BinaryReader,
  ): CallRefereePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.tableIndex = reader.readInt32();
          break;
        }
        case 2: {
          msg.eventId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const PenaltiesResponse = {
  /**
   * Serializes PenaltiesResponse to protobuf.
   */
  encode: function (msg: PartialDeep<PenaltiesResponse>): Uint8Array {
    return PenaltiesResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes PenaltiesResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PenaltiesResponse {
    return PenaltiesResponse._readMessage(
      PenaltiesResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes PenaltiesResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PenaltiesResponse>): PenaltiesResponse {
    return {
      penalties: [],
      referees: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PenaltiesResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.penalties?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.penalties as any,
        protoAtoms.Penalty._writeMessage,
      );
    }
    if (msg.referees?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.referees as any,
        protoAtoms.Player._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PenaltiesResponse,
    reader: protoscript.BinaryReader,
  ): PenaltiesResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.Penalty.initialize();
          reader.readMessage(m, protoAtoms.Penalty._readMessage);
          msg.penalties.push(m);
          break;
        }
        case 2: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.referees.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelPenaltyPayload = {
  /**
   * Serializes CancelPenaltyPayload to protobuf.
   */
  encode: function (msg: PartialDeep<CancelPenaltyPayload>): Uint8Array {
    return CancelPenaltyPayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelPenaltyPayload from protobuf.
   */
  decode: function (bytes: ByteSource): CancelPenaltyPayload {
    return CancelPenaltyPayload._readMessage(
      CancelPenaltyPayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CancelPenaltyPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CancelPenaltyPayload>,
  ): CancelPenaltyPayload {
    return {
      penaltyId: 0,
      reason: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelPenaltyPayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.penaltyId) {
      writer.writeInt32(1, msg.penaltyId);
    }
    if (msg.reason != undefined) {
      writer.writeString(2, msg.reason);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelPenaltyPayload,
    reader: protoscript.BinaryReader,
  ): CancelPenaltyPayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.penaltyId = reader.readInt32();
          break;
        }
        case 2: {
          msg.reason = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const AddExtraTimePayload = {
  /**
   * Serializes AddExtraTimePayload to protobuf.
   */
  encode: function (msg: PartialDeep<AddExtraTimePayload>): Uint8Array {
    return AddExtraTimePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes AddExtraTimePayload from protobuf.
   */
  decode: function (bytes: ByteSource): AddExtraTimePayload {
    return AddExtraTimePayload._readMessage(
      AddExtraTimePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes AddExtraTimePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<AddExtraTimePayload>,
  ): AddExtraTimePayload {
    return {
      sessionHashList: [],
      extraTime: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AddExtraTimePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessionHashList?.length) {
      writer.writeRepeatedString(1, msg.sessionHashList);
    }
    if (msg.extraTime) {
      writer.writeInt32(2, msg.extraTime);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AddExtraTimePayload,
    reader: protoscript.BinaryReader,
  ): AddExtraTimePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sessionHashList.push(reader.readString());
          break;
        }
        case 2: {
          msg.extraTime = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetCurrentStatePayload = {
  /**
   * Serializes GetCurrentStatePayload to protobuf.
   */
  encode: function (msg: PartialDeep<GetCurrentStatePayload>): Uint8Array {
    return GetCurrentStatePayload._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetCurrentStatePayload from protobuf.
   */
  decode: function (bytes: ByteSource): GetCurrentStatePayload {
    return GetCurrentStatePayload._readMessage(
      GetCurrentStatePayload.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetCurrentStatePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCurrentStatePayload>,
  ): GetCurrentStatePayload {
    return {
      eventId: 0,
      playerId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCurrentStatePayload>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.eventId) {
      writer.writeInt32(1, msg.eventId);
    }
    if (msg.playerId) {
      writer.writeInt32(2, msg.playerId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCurrentStatePayload,
    reader: protoscript.BinaryReader,
  ): GetCurrentStatePayload {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventId = reader.readInt32();
          break;
        }
        case 2: {
          msg.playerId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetCurrentStateResponse = {
  /**
   * Serializes GetCurrentStateResponse to protobuf.
   */
  encode: function (msg: PartialDeep<GetCurrentStateResponse>): Uint8Array {
    return GetCurrentStateResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetCurrentStateResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetCurrentStateResponse {
    return GetCurrentStateResponse._readMessage(
      GetCurrentStateResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetCurrentStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCurrentStateResponse>,
  ): GetCurrentStateResponse {
    return {
      sessions: [],
      config: protoAtoms.GameConfig.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCurrentStateResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sessions?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.sessions as any,
        CurrentSession._writeMessage,
      );
    }
    if (msg.config) {
      writer.writeMessage(2, msg.config, protoAtoms.GameConfig._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCurrentStateResponse,
    reader: protoscript.BinaryReader,
  ): GetCurrentStateResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = CurrentSession.initialize();
          reader.readMessage(m, CurrentSession._readMessage);
          msg.sessions.push(m);
          break;
        }
        case 2: {
          reader.readMessage(msg.config, protoAtoms.GameConfig._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChomboResponse = {
  /**
   * Serializes ChomboResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ChomboResponse>): Uint8Array {
    return ChomboResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ChomboResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ChomboResponse {
    return ChomboResponse._readMessage(
      ChomboResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ChomboResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ChomboResponse>): ChomboResponse {
    return {
      chombos: [],
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ChomboResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.chombos?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.chombos as any,
        protoAtoms.Chombo._writeMessage,
      );
    }
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.players as any,
        protoAtoms.Player._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChomboResponse,
    reader: protoscript.BinaryReader,
  ): ChomboResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoAtoms.Chombo.initialize();
          reader.readMessage(m, protoAtoms.Chombo._readMessage);
          msg.chombos.push(m);
          break;
        }
        case 2: {
          const m = protoAtoms.Player.initialize();
          reader.readMessage(m, protoAtoms.Player._readMessage);
          msg.players.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const EventsGetRulesetsPayloadJSON = {
  /**
   * Serializes EventsGetRulesetsPayload to JSON.
   */
  encode: function (_msg?: PartialDeep<EventsGetRulesetsPayload>): string {
    return "{}";
  },

  /**
   * Deserializes EventsGetRulesetsPayload from JSON.
   */
  decode: function (_json?: string): EventsGetRulesetsPayload {
    return {};
  },

  /**
   * Initializes EventsGetRulesetsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRulesetsPayload>,
  ): EventsGetRulesetsPayload {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EventsGetRulesetsPayload>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRulesetsPayload,
    _json: any,
  ): EventsGetRulesetsPayload {
    return msg;
  },
};

export const EventsGetRulesetsResponseJSON = {
  /**
   * Serializes EventsGetRulesetsResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetRulesetsResponse>): string {
    return JSON.stringify(EventsGetRulesetsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetRulesetsResponse from JSON.
   */
  decode: function (json: string): EventsGetRulesetsResponse {
    return EventsGetRulesetsResponseJSON._readMessage(
      EventsGetRulesetsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetRulesetsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRulesetsResponse>,
  ): EventsGetRulesetsResponse {
    return {
      rulesets: [],
      rulesetIds: [],
      rulesetTitles: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRulesetsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rulesets?.length) {
      json["rulesets"] = msg.rulesets.map(
        protoAtoms.RulesetConfigJSON._writeMessage,
      );
    }
    if (msg.rulesetIds?.length) {
      json["rulesetIds"] = msg.rulesetIds;
    }
    if (msg.rulesetTitles?.length) {
      json["rulesetTitles"] = msg.rulesetTitles;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRulesetsResponse,
    json: any,
  ): EventsGetRulesetsResponse {
    const _rulesets_ = json["rulesets"];
    if (_rulesets_) {
      for (const item of _rulesets_) {
        const m = protoAtoms.RulesetConfigJSON.initialize();
        protoAtoms.RulesetConfigJSON._readMessage(m, item);
        msg.rulesets.push(m);
      }
    }
    const _rulesetIds_ = json["rulesetIds"] ?? json["ruleset_ids"];
    if (_rulesetIds_) {
      msg.rulesetIds = _rulesetIds_;
    }
    const _rulesetTitles_ = json["rulesetTitles"] ?? json["ruleset_titles"];
    if (_rulesetTitles_) {
      msg.rulesetTitles = _rulesetTitles_;
    }
    return msg;
  },
};

export const EventsGetTimezonesPayloadJSON = {
  /**
   * Serializes EventsGetTimezonesPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetTimezonesPayload>): string {
    return JSON.stringify(EventsGetTimezonesPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetTimezonesPayload from JSON.
   */
  decode: function (json: string): EventsGetTimezonesPayload {
    return EventsGetTimezonesPayloadJSON._readMessage(
      EventsGetTimezonesPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetTimezonesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimezonesPayload>,
  ): EventsGetTimezonesPayload {
    return {
      addr: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimezonesPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.addr) {
      json["addr"] = msg.addr;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimezonesPayload,
    json: any,
  ): EventsGetTimezonesPayload {
    const _addr_ = json["addr"];
    if (_addr_) {
      msg.addr = _addr_;
    }
    return msg;
  },
};

export const EventsGetTimezonesResponseJSON = {
  /**
   * Serializes EventsGetTimezonesResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetTimezonesResponse>): string {
    return JSON.stringify(EventsGetTimezonesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetTimezonesResponse from JSON.
   */
  decode: function (json: string): EventsGetTimezonesResponse {
    return EventsGetTimezonesResponseJSON._readMessage(
      EventsGetTimezonesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetTimezonesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimezonesResponse>,
  ): EventsGetTimezonesResponse {
    return {
      preferredByIp: "",
      timezones: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimezonesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.preferredByIp) {
      json["preferredByIp"] = msg.preferredByIp;
    }
    if (msg.timezones?.length) {
      json["timezones"] = msg.timezones;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimezonesResponse,
    json: any,
  ): EventsGetTimezonesResponse {
    const _preferredByIp_ = json["preferredByIp"] ?? json["preferred_by_ip"];
    if (_preferredByIp_) {
      msg.preferredByIp = _preferredByIp_;
    }
    const _timezones_ = json["timezones"];
    if (_timezones_) {
      msg.timezones = _timezones_;
    }
    return msg;
  },
};

export const EventsGetCountriesPayloadJSON = {
  /**
   * Serializes EventsGetCountriesPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetCountriesPayload>): string {
    return JSON.stringify(EventsGetCountriesPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetCountriesPayload from JSON.
   */
  decode: function (json: string): EventsGetCountriesPayload {
    return EventsGetCountriesPayloadJSON._readMessage(
      EventsGetCountriesPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetCountriesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCountriesPayload>,
  ): EventsGetCountriesPayload {
    return {
      addr: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCountriesPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.addr) {
      json["addr"] = msg.addr;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCountriesPayload,
    json: any,
  ): EventsGetCountriesPayload {
    const _addr_ = json["addr"];
    if (_addr_) {
      msg.addr = _addr_;
    }
    return msg;
  },
};

export const EventsGetCountriesResponseJSON = {
  /**
   * Serializes EventsGetCountriesResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetCountriesResponse>): string {
    return JSON.stringify(EventsGetCountriesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetCountriesResponse from JSON.
   */
  decode: function (json: string): EventsGetCountriesResponse {
    return EventsGetCountriesResponseJSON._readMessage(
      EventsGetCountriesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetCountriesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCountriesResponse>,
  ): EventsGetCountriesResponse {
    return {
      preferredByIp: "",
      countries: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCountriesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.preferredByIp) {
      json["preferredByIp"] = msg.preferredByIp;
    }
    if (msg.countries?.length) {
      json["countries"] = msg.countries.map(
        protoAtoms.CountryJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCountriesResponse,
    json: any,
  ): EventsGetCountriesResponse {
    const _preferredByIp_ = json["preferredByIp"] ?? json["preferred_by_ip"];
    if (_preferredByIp_) {
      msg.preferredByIp = _preferredByIp_;
    }
    const _countries_ = json["countries"];
    if (_countries_) {
      for (const item of _countries_) {
        const m = protoAtoms.CountryJSON.initialize();
        protoAtoms.CountryJSON._readMessage(m, item);
        msg.countries.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetEventsPayloadJSON = {
  /**
   * Serializes EventsGetEventsPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventsPayload>): string {
    return JSON.stringify(EventsGetEventsPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventsPayload from JSON.
   */
  decode: function (json: string): EventsGetEventsPayload {
    return EventsGetEventsPayloadJSON._readMessage(
      EventsGetEventsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsPayload>,
  ): EventsGetEventsPayload {
    return {
      limit: 0,
      offset: 0,
      filterUnlisted: false,
      filter: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    if (msg.offset) {
      json["offset"] = msg.offset;
    }
    if (msg.filterUnlisted) {
      json["filterUnlisted"] = msg.filterUnlisted;
    }
    if (msg.filter) {
      json["filter"] = msg.filter;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsPayload,
    json: any,
  ): EventsGetEventsPayload {
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = protoscript.parseNumber(_offset_);
    }
    const _filterUnlisted_ = json["filterUnlisted"] ?? json["filter_unlisted"];
    if (_filterUnlisted_) {
      msg.filterUnlisted = _filterUnlisted_;
    }
    const _filter_ = json["filter"];
    if (_filter_) {
      msg.filter = _filter_;
    }
    return msg;
  },
};

export const EventsGetEventsResponseJSON = {
  /**
   * Serializes EventsGetEventsResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventsResponse>): string {
    return JSON.stringify(EventsGetEventsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventsResponse from JSON.
   */
  decode: function (json: string): EventsGetEventsResponse {
    return EventsGetEventsResponseJSON._readMessage(
      EventsGetEventsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsResponse>,
  ): EventsGetEventsResponse {
    return {
      total: 0,
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.total) {
      json["total"] = msg.total;
    }
    if (msg.events?.length) {
      json["events"] = msg.events.map(protoAtoms.EventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsResponse,
    json: any,
  ): EventsGetEventsResponse {
    const _total_ = json["total"];
    if (_total_) {
      msg.total = protoscript.parseNumber(_total_);
    }
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = protoAtoms.EventJSON.initialize();
        protoAtoms.EventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetEventsByIdPayloadJSON = {
  /**
   * Serializes EventsGetEventsByIdPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventsByIdPayload>): string {
    return JSON.stringify(EventsGetEventsByIdPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventsByIdPayload from JSON.
   */
  decode: function (json: string): EventsGetEventsByIdPayload {
    return EventsGetEventsByIdPayloadJSON._readMessage(
      EventsGetEventsByIdPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventsByIdPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsByIdPayload>,
  ): EventsGetEventsByIdPayload {
    return {
      ids: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsByIdPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ids?.length) {
      json["ids"] = msg.ids;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsByIdPayload,
    json: any,
  ): EventsGetEventsByIdPayload {
    const _ids_ = json["ids"];
    if (_ids_) {
      msg.ids = _ids_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const EventsGetEventsByIdResponseJSON = {
  /**
   * Serializes EventsGetEventsByIdResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventsByIdResponse>): string {
    return JSON.stringify(EventsGetEventsByIdResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventsByIdResponse from JSON.
   */
  decode: function (json: string): EventsGetEventsByIdResponse {
    return EventsGetEventsByIdResponseJSON._readMessage(
      EventsGetEventsByIdResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventsByIdResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventsByIdResponse>,
  ): EventsGetEventsByIdResponse {
    return {
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventsByIdResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.events?.length) {
      json["events"] = msg.events.map(protoAtoms.EventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventsByIdResponse,
    json: any,
  ): EventsGetEventsByIdResponse {
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = protoAtoms.EventJSON.initialize();
        protoAtoms.EventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const PlayersGetMyEventsPayloadJSON = {
  /**
   * Serializes PlayersGetMyEventsPayload to JSON.
   */
  encode: function (_msg?: PartialDeep<PlayersGetMyEventsPayload>): string {
    return "{}";
  },

  /**
   * Deserializes PlayersGetMyEventsPayload from JSON.
   */
  decode: function (_json?: string): PlayersGetMyEventsPayload {
    return {};
  },

  /**
   * Initializes PlayersGetMyEventsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetMyEventsPayload>,
  ): PlayersGetMyEventsPayload {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<PlayersGetMyEventsPayload>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetMyEventsPayload,
    _json: any,
  ): PlayersGetMyEventsPayload {
    return msg;
  },
};

export const PlayersGetMyEventsResponseJSON = {
  /**
   * Serializes PlayersGetMyEventsResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetMyEventsResponse>): string {
    return JSON.stringify(PlayersGetMyEventsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetMyEventsResponse from JSON.
   */
  decode: function (json: string): PlayersGetMyEventsResponse {
    return PlayersGetMyEventsResponseJSON._readMessage(
      PlayersGetMyEventsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetMyEventsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetMyEventsResponse>,
  ): PlayersGetMyEventsResponse {
    return {
      events: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetMyEventsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.events?.length) {
      json["events"] = msg.events.map(protoAtoms.MyEventJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetMyEventsResponse,
    json: any,
  ): PlayersGetMyEventsResponse {
    const _events_ = json["events"];
    if (_events_) {
      for (const item of _events_) {
        const m = protoAtoms.MyEventJSON.initialize();
        protoAtoms.MyEventJSON._readMessage(m, item);
        msg.events.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetRatingTablePayloadJSON = {
  /**
   * Serializes EventsGetRatingTablePayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetRatingTablePayload>): string {
    return JSON.stringify(EventsGetRatingTablePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetRatingTablePayload from JSON.
   */
  decode: function (json: string): EventsGetRatingTablePayload {
    return EventsGetRatingTablePayloadJSON._readMessage(
      EventsGetRatingTablePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetRatingTablePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRatingTablePayload>,
  ): EventsGetRatingTablePayload {
    return {
      eventIdList: [],
      orderBy: "",
      order: "",
      withPrefinished: undefined,
      onlyMinGames: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRatingTablePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    if (msg.orderBy) {
      json["orderBy"] = msg.orderBy;
    }
    if (msg.order) {
      json["order"] = msg.order;
    }
    if (msg.withPrefinished != undefined) {
      json["withPrefinished"] = msg.withPrefinished;
    }
    if (msg.onlyMinGames != undefined) {
      json["onlyMinGames"] = msg.onlyMinGames;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRatingTablePayload,
    json: any,
  ): EventsGetRatingTablePayload {
    const _eventIdList_ = json["eventIdList"] ?? json["event_id_list"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_.map(protoscript.parseNumber);
    }
    const _orderBy_ = json["orderBy"] ?? json["order_by"];
    if (_orderBy_) {
      msg.orderBy = _orderBy_;
    }
    const _order_ = json["order"];
    if (_order_) {
      msg.order = _order_;
    }
    const _withPrefinished_ =
      json["withPrefinished"] ?? json["with_prefinished"];
    if (_withPrefinished_) {
      msg.withPrefinished = _withPrefinished_;
    }
    const _onlyMinGames_ = json["onlyMinGames"] ?? json["only_min_games"];
    if (_onlyMinGames_) {
      msg.onlyMinGames = _onlyMinGames_;
    }
    return msg;
  },
};

export const EventsGetRatingTableResponseJSON = {
  /**
   * Serializes EventsGetRatingTableResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetRatingTableResponse>): string {
    return JSON.stringify(EventsGetRatingTableResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetRatingTableResponse from JSON.
   */
  decode: function (json: string): EventsGetRatingTableResponse {
    return EventsGetRatingTableResponseJSON._readMessage(
      EventsGetRatingTableResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetRatingTableResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetRatingTableResponse>,
  ): EventsGetRatingTableResponse {
    return {
      list: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetRatingTableResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.list?.length) {
      json["list"] = msg.list.map(protoAtoms.PlayerInRatingJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetRatingTableResponse,
    json: any,
  ): EventsGetRatingTableResponse {
    const _list_ = json["list"];
    if (_list_) {
      for (const item of _list_) {
        const m = protoAtoms.PlayerInRatingJSON.initialize();
        protoAtoms.PlayerInRatingJSON._readMessage(m, item);
        msg.list.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetLastGamesPayloadJSON = {
  /**
   * Serializes EventsGetLastGamesPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetLastGamesPayload>): string {
    return JSON.stringify(EventsGetLastGamesPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetLastGamesPayload from JSON.
   */
  decode: function (json: string): EventsGetLastGamesPayload {
    return EventsGetLastGamesPayloadJSON._readMessage(
      EventsGetLastGamesPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetLastGamesPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetLastGamesPayload>,
  ): EventsGetLastGamesPayload {
    return {
      eventIdList: [],
      limit: 0,
      offset: 0,
      orderBy: undefined,
      order: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetLastGamesPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    if (msg.limit) {
      json["limit"] = msg.limit;
    }
    if (msg.offset) {
      json["offset"] = msg.offset;
    }
    if (msg.orderBy != undefined) {
      json["orderBy"] = msg.orderBy;
    }
    if (msg.order != undefined) {
      json["order"] = msg.order;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetLastGamesPayload,
    json: any,
  ): EventsGetLastGamesPayload {
    const _eventIdList_ = json["eventIdList"] ?? json["event_id_list"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_.map(protoscript.parseNumber);
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = protoscript.parseNumber(_limit_);
    }
    const _offset_ = json["offset"];
    if (_offset_) {
      msg.offset = protoscript.parseNumber(_offset_);
    }
    const _orderBy_ = json["orderBy"] ?? json["order_by"];
    if (_orderBy_) {
      msg.orderBy = _orderBy_;
    }
    const _order_ = json["order"];
    if (_order_) {
      msg.order = _order_;
    }
    return msg;
  },
};

export const EventsGetLastGamesResponseJSON = {
  /**
   * Serializes EventsGetLastGamesResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetLastGamesResponse>): string {
    return JSON.stringify(EventsGetLastGamesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetLastGamesResponse from JSON.
   */
  decode: function (json: string): EventsGetLastGamesResponse {
    return EventsGetLastGamesResponseJSON._readMessage(
      EventsGetLastGamesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetLastGamesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetLastGamesResponse>,
  ): EventsGetLastGamesResponse {
    return {
      games: [],
      players: [],
      totalGames: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetLastGamesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.games?.length) {
      json["games"] = msg.games.map(protoAtoms.GameResultJSON._writeMessage);
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(protoAtoms.PlayerJSON._writeMessage);
    }
    if (msg.totalGames) {
      json["totalGames"] = msg.totalGames;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetLastGamesResponse,
    json: any,
  ): EventsGetLastGamesResponse {
    const _games_ = json["games"];
    if (_games_) {
      for (const item of _games_) {
        const m = protoAtoms.GameResultJSON.initialize();
        protoAtoms.GameResultJSON._readMessage(m, item);
        msg.games.push(m);
      }
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _totalGames_ = json["totalGames"] ?? json["total_games"];
    if (_totalGames_) {
      msg.totalGames = protoscript.parseNumber(_totalGames_);
    }
    return msg;
  },
};

export const EventsGetGameResponseJSON = {
  /**
   * Serializes EventsGetGameResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetGameResponse>): string {
    return JSON.stringify(EventsGetGameResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetGameResponse from JSON.
   */
  decode: function (json: string): EventsGetGameResponse {
    return EventsGetGameResponseJSON._readMessage(
      EventsGetGameResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetGameResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetGameResponse>,
  ): EventsGetGameResponse {
    return {
      game: protoAtoms.GameResultJSON.initialize(),
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetGameResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.game) {
      const _game_ = protoAtoms.GameResultJSON._writeMessage(msg.game);
      if (Object.keys(_game_).length > 0) {
        json["game"] = _game_;
      }
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(protoAtoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetGameResponse,
    json: any,
  ): EventsGetGameResponse {
    const _game_ = json["game"];
    if (_game_) {
      protoAtoms.GameResultJSON._readMessage(msg.game, _game_);
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetGamesSeriesResponseJSON = {
  /**
   * Serializes EventsGetGamesSeriesResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetGamesSeriesResponse>): string {
    return JSON.stringify(EventsGetGamesSeriesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetGamesSeriesResponse from JSON.
   */
  decode: function (json: string): EventsGetGamesSeriesResponse {
    return EventsGetGamesSeriesResponseJSON._readMessage(
      EventsGetGamesSeriesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetGamesSeriesResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetGamesSeriesResponse>,
  ): EventsGetGamesSeriesResponse {
    return {
      results: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetGamesSeriesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.results?.length) {
      json["results"] = msg.results.map(
        protoAtoms.SeriesResultJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetGamesSeriesResponse,
    json: any,
  ): EventsGetGamesSeriesResponse {
    const _results_ = json["results"];
    if (_results_) {
      for (const item of _results_) {
        const m = protoAtoms.SeriesResultJSON.initialize();
        protoAtoms.SeriesResultJSON._readMessage(m, item);
        msg.results.push(m);
      }
    }
    return msg;
  },
};

export const PlayersGetCurrentSessionsPayloadJSON = {
  /**
   * Serializes PlayersGetCurrentSessionsPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<PlayersGetCurrentSessionsPayload>,
  ): string {
    return JSON.stringify(
      PlayersGetCurrentSessionsPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes PlayersGetCurrentSessionsPayload from JSON.
   */
  decode: function (json: string): PlayersGetCurrentSessionsPayload {
    return PlayersGetCurrentSessionsPayloadJSON._readMessage(
      PlayersGetCurrentSessionsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetCurrentSessionsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetCurrentSessionsPayload>,
  ): PlayersGetCurrentSessionsPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetCurrentSessionsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetCurrentSessionsPayload,
    json: any,
  ): PlayersGetCurrentSessionsPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const CurrentSessionJSON = {
  /**
   * Serializes CurrentSession to JSON.
   */
  encode: function (msg: PartialDeep<CurrentSession>): string {
    return JSON.stringify(CurrentSessionJSON._writeMessage(msg));
  },

  /**
   * Deserializes CurrentSession from JSON.
   */
  decode: function (json: string): CurrentSession {
    return CurrentSessionJSON._readMessage(
      CurrentSessionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CurrentSession with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CurrentSession>): CurrentSession {
    return {
      sessionHash: "",
      status: "",
      tableIndex: undefined,
      players: [],
      timerState: EventsGetTimerStateResponseJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CurrentSession>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.status) {
      json["status"] = msg.status;
    }
    if (msg.tableIndex != undefined) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(
        protoAtoms.PlayerInSessionJSON._writeMessage,
      );
    }
    if (msg.timerState) {
      const _timerState_ = EventsGetTimerStateResponseJSON._writeMessage(
        msg.timerState,
      );
      if (Object.keys(_timerState_).length > 0) {
        json["timerState"] = _timerState_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CurrentSession, json: any): CurrentSession {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = _status_;
    }
    const _tableIndex_ = json["tableIndex"] ?? json["table_index"];
    if (_tableIndex_) {
      msg.tableIndex = protoscript.parseNumber(_tableIndex_);
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerInSessionJSON.initialize();
        protoAtoms.PlayerInSessionJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _timerState_ = json["timerState"] ?? json["timer_state"];
    if (_timerState_) {
      EventsGetTimerStateResponseJSON._readMessage(
        msg.timerState,
        _timerState_,
      );
    }
    return msg;
  },
};

export const PlayersGetCurrentSessionsResponseJSON = {
  /**
   * Serializes PlayersGetCurrentSessionsResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<PlayersGetCurrentSessionsResponse>,
  ): string {
    return JSON.stringify(
      PlayersGetCurrentSessionsResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes PlayersGetCurrentSessionsResponse from JSON.
   */
  decode: function (json: string): PlayersGetCurrentSessionsResponse {
    return PlayersGetCurrentSessionsResponseJSON._readMessage(
      PlayersGetCurrentSessionsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetCurrentSessionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetCurrentSessionsResponse>,
  ): PlayersGetCurrentSessionsResponse {
    return {
      sessions: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetCurrentSessionsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessions?.length) {
      json["sessions"] = msg.sessions.map(CurrentSessionJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetCurrentSessionsResponse,
    json: any,
  ): PlayersGetCurrentSessionsResponse {
    const _sessions_ = json["sessions"];
    if (_sessions_) {
      for (const item of _sessions_) {
        const m = CurrentSessionJSON.initialize();
        CurrentSessionJSON._readMessage(m, item);
        msg.sessions.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetAllRegisteredPlayersPayloadJSON = {
  /**
   * Serializes EventsGetAllRegisteredPlayersPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersPayload>,
  ): string {
    return JSON.stringify(
      EventsGetAllRegisteredPlayersPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsGetAllRegisteredPlayersPayload from JSON.
   */
  decode: function (json: string): EventsGetAllRegisteredPlayersPayload {
    return EventsGetAllRegisteredPlayersPayloadJSON._readMessage(
      EventsGetAllRegisteredPlayersPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetAllRegisteredPlayersPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAllRegisteredPlayersPayload>,
  ): EventsGetAllRegisteredPlayersPayload {
    return {
      eventIds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventIds?.length) {
      json["eventIds"] = msg.eventIds;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAllRegisteredPlayersPayload,
    json: any,
  ): EventsGetAllRegisteredPlayersPayload {
    const _eventIds_ = json["eventIds"] ?? json["event_ids"];
    if (_eventIds_) {
      msg.eventIds = _eventIds_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const EventsGetAllRegisteredPlayersResponseJSON = {
  /**
   * Serializes EventsGetAllRegisteredPlayersResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersResponse>,
  ): string {
    return JSON.stringify(
      EventsGetAllRegisteredPlayersResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsGetAllRegisteredPlayersResponse from JSON.
   */
  decode: function (json: string): EventsGetAllRegisteredPlayersResponse {
    return EventsGetAllRegisteredPlayersResponseJSON._readMessage(
      EventsGetAllRegisteredPlayersResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetAllRegisteredPlayersResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAllRegisteredPlayersResponse>,
  ): EventsGetAllRegisteredPlayersResponse {
    return {
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAllRegisteredPlayersResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players?.length) {
      json["players"] = msg.players.map(
        protoAtoms.RegisteredPlayerJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAllRegisteredPlayersResponse,
    json: any,
  ): EventsGetAllRegisteredPlayersResponse {
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.RegisteredPlayerJSON.initialize();
        protoAtoms.RegisteredPlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetTimerStateResponseJSON = {
  /**
   * Serializes EventsGetTimerStateResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetTimerStateResponse>): string {
    return JSON.stringify(EventsGetTimerStateResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetTimerStateResponse from JSON.
   */
  decode: function (json: string): EventsGetTimerStateResponse {
    return EventsGetTimerStateResponseJSON._readMessage(
      EventsGetTimerStateResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetTimerStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTimerStateResponse>,
  ): EventsGetTimerStateResponse {
    return {
      started: false,
      finished: false,
      timeRemaining: 0,
      waitingForTimer: false,
      haveAutostart: false,
      autostartTimer: false,
      hideSeatingAfter: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTimerStateResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.started) {
      json["started"] = msg.started;
    }
    if (msg.finished) {
      json["finished"] = msg.finished;
    }
    if (msg.timeRemaining) {
      json["timeRemaining"] = msg.timeRemaining;
    }
    if (msg.waitingForTimer) {
      json["waitingForTimer"] = msg.waitingForTimer;
    }
    if (msg.haveAutostart) {
      json["haveAutostart"] = msg.haveAutostart;
    }
    if (msg.autostartTimer) {
      json["autostartTimer"] = msg.autostartTimer;
    }
    if (msg.hideSeatingAfter) {
      json["hideSeatingAfter"] = msg.hideSeatingAfter;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTimerStateResponse,
    json: any,
  ): EventsGetTimerStateResponse {
    const _started_ = json["started"];
    if (_started_) {
      msg.started = _started_;
    }
    const _finished_ = json["finished"];
    if (_finished_) {
      msg.finished = _finished_;
    }
    const _timeRemaining_ = json["timeRemaining"] ?? json["time_remaining"];
    if (_timeRemaining_) {
      msg.timeRemaining = protoscript.parseNumber(_timeRemaining_);
    }
    const _waitingForTimer_ =
      json["waitingForTimer"] ?? json["waiting_for_timer"];
    if (_waitingForTimer_) {
      msg.waitingForTimer = _waitingForTimer_;
    }
    const _haveAutostart_ = json["haveAutostart"] ?? json["have_autostart"];
    if (_haveAutostart_) {
      msg.haveAutostart = _haveAutostart_;
    }
    const _autostartTimer_ = json["autostartTimer"] ?? json["autostart_timer"];
    if (_autostartTimer_) {
      msg.autostartTimer = _autostartTimer_;
    }
    const _hideSeatingAfter_ =
      json["hideSeatingAfter"] ?? json["hide_seating_after"];
    if (_hideSeatingAfter_) {
      msg.hideSeatingAfter = protoscript.parseNumber(_hideSeatingAfter_);
    }
    return msg;
  },
};

export const GamesGetSessionOverviewResponseJSON = {
  /**
   * Serializes GamesGetSessionOverviewResponse to JSON.
   */
  encode: function (msg: PartialDeep<GamesGetSessionOverviewResponse>): string {
    return JSON.stringify(
      GamesGetSessionOverviewResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes GamesGetSessionOverviewResponse from JSON.
   */
  decode: function (json: string): GamesGetSessionOverviewResponse {
    return GamesGetSessionOverviewResponseJSON._readMessage(
      GamesGetSessionOverviewResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesGetSessionOverviewResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesGetSessionOverviewResponse>,
  ): GamesGetSessionOverviewResponse {
    return {
      id: 0,
      eventId: 0,
      tableIndex: undefined,
      players: [],
      state: protoAtoms.SessionStateJSON.initialize(),
      timerState: EventsGetTimerStateResponseJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesGetSessionOverviewResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.tableIndex != undefined) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(
        protoAtoms.PlayerInSessionJSON._writeMessage,
      );
    }
    if (msg.state) {
      const _state_ = protoAtoms.SessionStateJSON._writeMessage(msg.state);
      if (Object.keys(_state_).length > 0) {
        json["state"] = _state_;
      }
    }
    if (msg.timerState) {
      const _timerState_ = EventsGetTimerStateResponseJSON._writeMessage(
        msg.timerState,
      );
      if (Object.keys(_timerState_).length > 0) {
        json["timerState"] = _timerState_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesGetSessionOverviewResponse,
    json: any,
  ): GamesGetSessionOverviewResponse {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _tableIndex_ = json["tableIndex"] ?? json["table_index"];
    if (_tableIndex_) {
      msg.tableIndex = protoscript.parseNumber(_tableIndex_);
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerInSessionJSON.initialize();
        protoAtoms.PlayerInSessionJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _state_ = json["state"];
    if (_state_) {
      protoAtoms.SessionStateJSON._readMessage(msg.state, _state_);
    }
    const _timerState_ = json["timerState"] ?? json["timer_state"];
    if (_timerState_) {
      EventsGetTimerStateResponseJSON._readMessage(
        msg.timerState,
        _timerState_,
      );
    }
    return msg;
  },
};

export const PlayersGetPlayerStatsPayloadJSON = {
  /**
   * Serializes PlayersGetPlayerStatsPayload to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerStatsPayload>): string {
    return JSON.stringify(PlayersGetPlayerStatsPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetPlayerStatsPayload from JSON.
   */
  decode: function (json: string): PlayersGetPlayerStatsPayload {
    return PlayersGetPlayerStatsPayloadJSON._readMessage(
      PlayersGetPlayerStatsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetPlayerStatsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerStatsPayload>,
  ): PlayersGetPlayerStatsPayload {
    return {
      playerId: 0,
      eventIdList: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerStatsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventIdList?.length) {
      json["eventIdList"] = msg.eventIdList;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerStatsPayload,
    json: any,
  ): PlayersGetPlayerStatsPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventIdList_ = json["eventIdList"] ?? json["event_id_list"];
    if (_eventIdList_) {
      msg.eventIdList = _eventIdList_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const PlayersGetPlayerStatsResponseJSON = {
  /**
   * Serializes PlayersGetPlayerStatsResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerStatsResponse>): string {
    return JSON.stringify(PlayersGetPlayerStatsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetPlayerStatsResponse from JSON.
   */
  decode: function (json: string): PlayersGetPlayerStatsResponse {
    return PlayersGetPlayerStatsResponseJSON._readMessage(
      PlayersGetPlayerStatsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetPlayerStatsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerStatsResponse>,
  ): PlayersGetPlayerStatsResponse {
    return {
      ratingHistory: [],
      scoreHistory: [],
      playersInfo: [],
      placesSummary: [],
      totalPlayedGames: 0,
      totalPlayedRounds: 0,
      winSummary: protoAtoms.PlayerWinSummaryJSON.initialize(),
      handsValueSummary: [],
      yakuSummary: [],
      riichiSummary: protoAtoms.RiichiSummaryJSON.initialize(),
      doraStat: protoAtoms.DoraSummaryJSON.initialize(),
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerStatsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ratingHistory?.length) {
      json["ratingHistory"] = msg.ratingHistory;
    }
    if (msg.scoreHistory?.length) {
      json["scoreHistory"] = msg.scoreHistory.map(
        protoAtoms.SessionHistoryResultTableJSON._writeMessage,
      );
    }
    if (msg.playersInfo?.length) {
      json["playersInfo"] = msg.playersInfo.map(
        protoAtoms.PlayerJSON._writeMessage,
      );
    }
    if (msg.placesSummary?.length) {
      json["placesSummary"] = msg.placesSummary.map(
        protoAtoms.PlacesSummaryItemJSON._writeMessage,
      );
    }
    if (msg.totalPlayedGames) {
      json["totalPlayedGames"] = msg.totalPlayedGames;
    }
    if (msg.totalPlayedRounds) {
      json["totalPlayedRounds"] = msg.totalPlayedRounds;
    }
    if (msg.winSummary) {
      const _winSummary_ = protoAtoms.PlayerWinSummaryJSON._writeMessage(
        msg.winSummary,
      );
      if (Object.keys(_winSummary_).length > 0) {
        json["winSummary"] = _winSummary_;
      }
    }
    if (msg.handsValueSummary?.length) {
      json["handsValueSummary"] = msg.handsValueSummary.map(
        protoAtoms.HandValueStatJSON._writeMessage,
      );
    }
    if (msg.yakuSummary?.length) {
      json["yakuSummary"] = msg.yakuSummary.map(
        protoAtoms.YakuStatJSON._writeMessage,
      );
    }
    if (msg.riichiSummary) {
      const _riichiSummary_ = protoAtoms.RiichiSummaryJSON._writeMessage(
        msg.riichiSummary,
      );
      if (Object.keys(_riichiSummary_).length > 0) {
        json["riichiSummary"] = _riichiSummary_;
      }
    }
    if (msg.doraStat) {
      const _doraStat_ = protoAtoms.DoraSummaryJSON._writeMessage(msg.doraStat);
      if (Object.keys(_doraStat_).length > 0) {
        json["doraStat"] = _doraStat_;
      }
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerStatsResponse,
    json: any,
  ): PlayersGetPlayerStatsResponse {
    const _ratingHistory_ = json["ratingHistory"] ?? json["rating_history"];
    if (_ratingHistory_) {
      msg.ratingHistory = _ratingHistory_.map(protoscript.parseNumber);
    }
    const _scoreHistory_ = json["scoreHistory"] ?? json["score_history"];
    if (_scoreHistory_) {
      for (const item of _scoreHistory_) {
        const m = protoAtoms.SessionHistoryResultTableJSON.initialize();
        protoAtoms.SessionHistoryResultTableJSON._readMessage(m, item);
        msg.scoreHistory.push(m);
      }
    }
    const _playersInfo_ = json["playersInfo"] ?? json["players_info"];
    if (_playersInfo_) {
      for (const item of _playersInfo_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.playersInfo.push(m);
      }
    }
    const _placesSummary_ = json["placesSummary"] ?? json["places_summary"];
    if (_placesSummary_) {
      for (const item of _placesSummary_) {
        const m = protoAtoms.PlacesSummaryItemJSON.initialize();
        protoAtoms.PlacesSummaryItemJSON._readMessage(m, item);
        msg.placesSummary.push(m);
      }
    }
    const _totalPlayedGames_ =
      json["totalPlayedGames"] ?? json["total_played_games"];
    if (_totalPlayedGames_) {
      msg.totalPlayedGames = protoscript.parseNumber(_totalPlayedGames_);
    }
    const _totalPlayedRounds_ =
      json["totalPlayedRounds"] ?? json["total_played_rounds"];
    if (_totalPlayedRounds_) {
      msg.totalPlayedRounds = protoscript.parseNumber(_totalPlayedRounds_);
    }
    const _winSummary_ = json["winSummary"] ?? json["win_summary"];
    if (_winSummary_) {
      protoAtoms.PlayerWinSummaryJSON._readMessage(
        msg.winSummary,
        _winSummary_,
      );
    }
    const _handsValueSummary_ =
      json["handsValueSummary"] ?? json["hands_value_summary"];
    if (_handsValueSummary_) {
      for (const item of _handsValueSummary_) {
        const m = protoAtoms.HandValueStatJSON.initialize();
        protoAtoms.HandValueStatJSON._readMessage(m, item);
        msg.handsValueSummary.push(m);
      }
    }
    const _yakuSummary_ = json["yakuSummary"] ?? json["yaku_summary"];
    if (_yakuSummary_) {
      for (const item of _yakuSummary_) {
        const m = protoAtoms.YakuStatJSON.initialize();
        protoAtoms.YakuStatJSON._readMessage(m, item);
        msg.yakuSummary.push(m);
      }
    }
    const _riichiSummary_ = json["riichiSummary"] ?? json["riichi_summary"];
    if (_riichiSummary_) {
      protoAtoms.RiichiSummaryJSON._readMessage(
        msg.riichiSummary,
        _riichiSummary_,
      );
    }
    const _doraStat_ = json["doraStat"] ?? json["dora_stat"];
    if (_doraStat_) {
      protoAtoms.DoraSummaryJSON._readMessage(msg.doraStat, _doraStat_);
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const GamesAddRoundPayloadJSON = {
  /**
   * Serializes GamesAddRoundPayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddRoundPayload>): string {
    return JSON.stringify(GamesAddRoundPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddRoundPayload from JSON.
   */
  decode: function (json: string): GamesAddRoundPayload {
    return GamesAddRoundPayloadJSON._readMessage(
      GamesAddRoundPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddRoundPayload>,
  ): GamesAddRoundPayload {
    return {
      sessionHash: "",
      roundData: protoAtoms.RoundJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddRoundPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.roundData) {
      const _roundData_ = protoAtoms.RoundJSON._writeMessage(msg.roundData);
      if (Object.keys(_roundData_).length > 0) {
        json["roundData"] = _roundData_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddRoundPayload,
    json: any,
  ): GamesAddRoundPayload {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _roundData_ = json["roundData"] ?? json["round_data"];
    if (_roundData_) {
      protoAtoms.RoundJSON._readMessage(msg.roundData, _roundData_);
    }
    return msg;
  },
};

export const GamesAddRoundResponseJSON = {
  /**
   * Serializes GamesAddRoundResponse to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddRoundResponse>): string {
    return JSON.stringify(GamesAddRoundResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddRoundResponse from JSON.
   */
  decode: function (json: string): GamesAddRoundResponse {
    return GamesAddRoundResponseJSON._readMessage(
      GamesAddRoundResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddRoundResponse>,
  ): GamesAddRoundResponse {
    return {
      scores: [],
      round: 0,
      honba: 0,
      riichiBets: 0,
      prematurelyFinished: false,
      roundJustChanged: false,
      isFinished: false,
      lastHandStarted: false,
      lastOutcome: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddRoundResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scores?.length) {
      json["scores"] = msg.scores.map(
        protoAtoms.IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    if (msg.round) {
      json["round"] = msg.round;
    }
    if (msg.honba) {
      json["honba"] = msg.honba;
    }
    if (msg.riichiBets) {
      json["riichiBets"] = msg.riichiBets;
    }
    if (msg.prematurelyFinished) {
      json["prematurelyFinished"] = msg.prematurelyFinished;
    }
    if (msg.roundJustChanged) {
      json["roundJustChanged"] = msg.roundJustChanged;
    }
    if (msg.isFinished) {
      json["isFinished"] = msg.isFinished;
    }
    if (msg.lastHandStarted) {
      json["lastHandStarted"] = msg.lastHandStarted;
    }
    if (msg.lastOutcome != undefined) {
      json["lastOutcome"] = msg.lastOutcome;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddRoundResponse,
    json: any,
  ): GamesAddRoundResponse {
    const _scores_ = json["scores"];
    if (_scores_) {
      for (const item of _scores_) {
        const m = protoAtoms.IntermediateResultOfSessionJSON.initialize();
        protoAtoms.IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.scores.push(m);
      }
    }
    const _round_ = json["round"];
    if (_round_) {
      msg.round = protoscript.parseNumber(_round_);
    }
    const _honba_ = json["honba"];
    if (_honba_) {
      msg.honba = protoscript.parseNumber(_honba_);
    }
    const _riichiBets_ = json["riichiBets"] ?? json["riichi_bets"];
    if (_riichiBets_) {
      msg.riichiBets = protoscript.parseNumber(_riichiBets_);
    }
    const _prematurelyFinished_ =
      json["prematurelyFinished"] ?? json["prematurely_finished"];
    if (_prematurelyFinished_) {
      msg.prematurelyFinished = _prematurelyFinished_;
    }
    const _roundJustChanged_ =
      json["roundJustChanged"] ?? json["round_just_changed"];
    if (_roundJustChanged_) {
      msg.roundJustChanged = _roundJustChanged_;
    }
    const _isFinished_ = json["isFinished"] ?? json["is_finished"];
    if (_isFinished_) {
      msg.isFinished = _isFinished_;
    }
    const _lastHandStarted_ =
      json["lastHandStarted"] ?? json["last_hand_started"];
    if (_lastHandStarted_) {
      msg.lastHandStarted = _lastHandStarted_;
    }
    const _lastOutcome_ = json["lastOutcome"] ?? json["last_outcome"];
    if (_lastOutcome_) {
      msg.lastOutcome = protoAtoms.RoundOutcome._fromInt(_lastOutcome_);
    }
    return msg;
  },
};

export const GamesPreviewRoundPayloadJSON = {
  /**
   * Serializes GamesPreviewRoundPayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesPreviewRoundPayload>): string {
    return JSON.stringify(GamesPreviewRoundPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesPreviewRoundPayload from JSON.
   */
  decode: function (json: string): GamesPreviewRoundPayload {
    return GamesPreviewRoundPayloadJSON._readMessage(
      GamesPreviewRoundPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesPreviewRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesPreviewRoundPayload>,
  ): GamesPreviewRoundPayload {
    return {
      sessionHash: "",
      roundData: protoAtoms.RoundJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesPreviewRoundPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.roundData) {
      const _roundData_ = protoAtoms.RoundJSON._writeMessage(msg.roundData);
      if (Object.keys(_roundData_).length > 0) {
        json["roundData"] = _roundData_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesPreviewRoundPayload,
    json: any,
  ): GamesPreviewRoundPayload {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _roundData_ = json["roundData"] ?? json["round_data"];
    if (_roundData_) {
      protoAtoms.RoundJSON._readMessage(msg.roundData, _roundData_);
    }
    return msg;
  },
};

export const GamesPreviewRoundResponseJSON = {
  /**
   * Serializes GamesPreviewRoundResponse to JSON.
   */
  encode: function (msg: PartialDeep<GamesPreviewRoundResponse>): string {
    return JSON.stringify(GamesPreviewRoundResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesPreviewRoundResponse from JSON.
   */
  decode: function (json: string): GamesPreviewRoundResponse {
    return GamesPreviewRoundResponseJSON._readMessage(
      GamesPreviewRoundResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesPreviewRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesPreviewRoundResponse>,
  ): GamesPreviewRoundResponse {
    return {
      state: protoAtoms.RoundStateJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesPreviewRoundResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.state) {
      const _state_ = protoAtoms.RoundStateJSON._writeMessage(msg.state);
      if (Object.keys(_state_).length > 0) {
        json["state"] = _state_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesPreviewRoundResponse,
    json: any,
  ): GamesPreviewRoundResponse {
    const _state_ = json["state"];
    if (_state_) {
      protoAtoms.RoundStateJSON._readMessage(msg.state, _state_);
    }
    return msg;
  },
};

export const GamesAddOnlineReplayPayloadJSON = {
  /**
   * Serializes GamesAddOnlineReplayPayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddOnlineReplayPayload>): string {
    return JSON.stringify(GamesAddOnlineReplayPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddOnlineReplayPayload from JSON.
   */
  decode: function (json: string): GamesAddOnlineReplayPayload {
    return GamesAddOnlineReplayPayloadJSON._readMessage(
      GamesAddOnlineReplayPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddOnlineReplayPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddOnlineReplayPayload>,
  ): GamesAddOnlineReplayPayload {
    return {
      eventId: 0,
      link: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddOnlineReplayPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.link) {
      json["link"] = msg.link;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddOnlineReplayPayload,
    json: any,
  ): GamesAddOnlineReplayPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _link_ = json["link"];
    if (_link_) {
      msg.link = _link_;
    }
    return msg;
  },
};

export const GamesAddOnlineReplayResponseJSON = {
  /**
   * Serializes GamesAddOnlineReplayResponse to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddOnlineReplayResponse>): string {
    return JSON.stringify(GamesAddOnlineReplayResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddOnlineReplayResponse from JSON.
   */
  decode: function (json: string): GamesAddOnlineReplayResponse {
    return GamesAddOnlineReplayResponseJSON._readMessage(
      GamesAddOnlineReplayResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddOnlineReplayResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddOnlineReplayResponse>,
  ): GamesAddOnlineReplayResponse {
    return {
      game: protoAtoms.GameResultJSON.initialize(),
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddOnlineReplayResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.game) {
      const _game_ = protoAtoms.GameResultJSON._writeMessage(msg.game);
      if (Object.keys(_game_).length > 0) {
        json["game"] = _game_;
      }
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(protoAtoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddOnlineReplayResponse,
    json: any,
  ): GamesAddOnlineReplayResponse {
    const _game_ = json["game"];
    if (_game_) {
      protoAtoms.GameResultJSON._readMessage(msg.game, _game_);
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};

export const PlayersGetLastResultsPayloadJSON = {
  /**
   * Serializes PlayersGetLastResultsPayload to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetLastResultsPayload>): string {
    return JSON.stringify(PlayersGetLastResultsPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetLastResultsPayload from JSON.
   */
  decode: function (json: string): PlayersGetLastResultsPayload {
    return PlayersGetLastResultsPayloadJSON._readMessage(
      PlayersGetLastResultsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetLastResultsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastResultsPayload>,
  ): PlayersGetLastResultsPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastResultsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastResultsPayload,
    json: any,
  ): PlayersGetLastResultsPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const PlayersGetLastResultsResponseJSON = {
  /**
   * Serializes PlayersGetLastResultsResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetLastResultsResponse>): string {
    return JSON.stringify(PlayersGetLastResultsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetLastResultsResponse from JSON.
   */
  decode: function (json: string): PlayersGetLastResultsResponse {
    return PlayersGetLastResultsResponseJSON._readMessage(
      PlayersGetLastResultsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetLastResultsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastResultsResponse>,
  ): PlayersGetLastResultsResponse {
    return {
      results: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastResultsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.results?.length) {
      json["results"] = msg.results.map(
        protoAtoms.SessionHistoryResultJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastResultsResponse,
    json: any,
  ): PlayersGetLastResultsResponse {
    const _results_ = json["results"];
    if (_results_) {
      for (const item of _results_) {
        const m = protoAtoms.SessionHistoryResultJSON.initialize();
        protoAtoms.SessionHistoryResultJSON._readMessage(m, item);
        msg.results.push(m);
      }
    }
    return msg;
  },
};

export const PlayersGetLastRoundPayloadJSON = {
  /**
   * Serializes PlayersGetLastRoundPayload to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetLastRoundPayload>): string {
    return JSON.stringify(PlayersGetLastRoundPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetLastRoundPayload from JSON.
   */
  decode: function (json: string): PlayersGetLastRoundPayload {
    return PlayersGetLastRoundPayloadJSON._readMessage(
      PlayersGetLastRoundPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetLastRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundPayload>,
  ): PlayersGetLastRoundPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundPayload,
    json: any,
  ): PlayersGetLastRoundPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const PlayersGetLastRoundResponseJSON = {
  /**
   * Serializes PlayersGetLastRoundResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetLastRoundResponse>): string {
    return JSON.stringify(PlayersGetLastRoundResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetLastRoundResponse from JSON.
   */
  decode: function (json: string): PlayersGetLastRoundResponse {
    return PlayersGetLastRoundResponseJSON._readMessage(
      PlayersGetLastRoundResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetLastRoundResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundResponse>,
  ): PlayersGetLastRoundResponse {
    return {
      round: protoAtoms.RoundStateJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.round) {
      const _round_ = protoAtoms.RoundStateJSON._writeMessage(msg.round);
      if (Object.keys(_round_).length > 0) {
        json["round"] = _round_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundResponse,
    json: any,
  ): PlayersGetLastRoundResponse {
    const _round_ = json["round"];
    if (_round_) {
      protoAtoms.RoundStateJSON._readMessage(msg.round, _round_);
    }
    return msg;
  },
};

export const PlayersGetAllRoundsResponseJSON = {
  /**
   * Serializes PlayersGetAllRoundsResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetAllRoundsResponse>): string {
    return JSON.stringify(PlayersGetAllRoundsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetAllRoundsResponse from JSON.
   */
  decode: function (json: string): PlayersGetAllRoundsResponse {
    return PlayersGetAllRoundsResponseJSON._readMessage(
      PlayersGetAllRoundsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetAllRoundsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetAllRoundsResponse>,
  ): PlayersGetAllRoundsResponse {
    return {
      rounds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetAllRoundsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.rounds?.length) {
      json["rounds"] = msg.rounds.map(protoAtoms.RoundStateJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetAllRoundsResponse,
    json: any,
  ): PlayersGetAllRoundsResponse {
    const _rounds_ = json["rounds"];
    if (_rounds_) {
      for (const item of _rounds_) {
        const m = protoAtoms.RoundStateJSON.initialize();
        protoAtoms.RoundStateJSON._readMessage(m, item);
        msg.rounds.push(m);
      }
    }
    return msg;
  },
};

export const PlayersGetLastRoundByHashResponseJSON = {
  /**
   * Serializes PlayersGetLastRoundByHashResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<PlayersGetLastRoundByHashResponse>,
  ): string {
    return JSON.stringify(
      PlayersGetLastRoundByHashResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes PlayersGetLastRoundByHashResponse from JSON.
   */
  decode: function (json: string): PlayersGetLastRoundByHashResponse {
    return PlayersGetLastRoundByHashResponseJSON._readMessage(
      PlayersGetLastRoundByHashResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetLastRoundByHashResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetLastRoundByHashResponse>,
  ): PlayersGetLastRoundByHashResponse {
    return {
      round: protoAtoms.RoundStateJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetLastRoundByHashResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.round) {
      const _round_ = protoAtoms.RoundStateJSON._writeMessage(msg.round);
      if (Object.keys(_round_).length > 0) {
        json["round"] = _round_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetLastRoundByHashResponse,
    json: any,
  ): PlayersGetLastRoundByHashResponse {
    const _round_ = json["round"];
    if (_round_) {
      protoAtoms.RoundStateJSON._readMessage(msg.round, _round_);
    }
    return msg;
  },
};

export const EventsGetEventForEditPayloadJSON = {
  /**
   * Serializes EventsGetEventForEditPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventForEditPayload>): string {
    return JSON.stringify(EventsGetEventForEditPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventForEditPayload from JSON.
   */
  decode: function (json: string): EventsGetEventForEditPayload {
    return EventsGetEventForEditPayloadJSON._readMessage(
      EventsGetEventForEditPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventForEditPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventForEditPayload>,
  ): EventsGetEventForEditPayload {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventForEditPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventForEditPayload,
    json: any,
  ): EventsGetEventForEditPayload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    return msg;
  },
};

export const EventsGetEventForEditResponseJSON = {
  /**
   * Serializes EventsGetEventForEditResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetEventForEditResponse>): string {
    return JSON.stringify(EventsGetEventForEditResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetEventForEditResponse from JSON.
   */
  decode: function (json: string): EventsGetEventForEditResponse {
    return EventsGetEventForEditResponseJSON._readMessage(
      EventsGetEventForEditResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetEventForEditResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetEventForEditResponse>,
  ): EventsGetEventForEditResponse {
    return {
      id: 0,
      event: protoAtoms.EventDataJSON.initialize(),
      finished: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetEventForEditResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.event) {
      const _event_ = protoAtoms.EventDataJSON._writeMessage(msg.event);
      if (Object.keys(_event_).length > 0) {
        json["event"] = _event_;
      }
    }
    if (msg.finished) {
      json["finished"] = msg.finished;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetEventForEditResponse,
    json: any,
  ): EventsGetEventForEditResponse {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _event_ = json["event"];
    if (_event_) {
      protoAtoms.EventDataJSON._readMessage(msg.event, _event_);
    }
    const _finished_ = json["finished"];
    if (_finished_) {
      msg.finished = _finished_;
    }
    return msg;
  },
};

export const EventsUpdateEventPayloadJSON = {
  /**
   * Serializes EventsUpdateEventPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsUpdateEventPayload>): string {
    return JSON.stringify(EventsUpdateEventPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsUpdateEventPayload from JSON.
   */
  decode: function (json: string): EventsUpdateEventPayload {
    return EventsUpdateEventPayloadJSON._readMessage(
      EventsUpdateEventPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdateEventPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdateEventPayload>,
  ): EventsUpdateEventPayload {
    return {
      id: 0,
      event: protoAtoms.EventDataJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdateEventPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.event) {
      const _event_ = protoAtoms.EventDataJSON._writeMessage(msg.event);
      if (Object.keys(_event_).length > 0) {
        json["event"] = _event_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdateEventPayload,
    json: any,
  ): EventsUpdateEventPayload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _event_ = json["event"];
    if (_event_) {
      protoAtoms.EventDataJSON._readMessage(msg.event, _event_);
    }
    return msg;
  },
};

export const EventsGetTablesStatePayloadJSON = {
  /**
   * Serializes EventsGetTablesStatePayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetTablesStatePayload>): string {
    return JSON.stringify(EventsGetTablesStatePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetTablesStatePayload from JSON.
   */
  decode: function (json: string): EventsGetTablesStatePayload {
    return EventsGetTablesStatePayloadJSON._readMessage(
      EventsGetTablesStatePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetTablesStatePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTablesStatePayload>,
  ): EventsGetTablesStatePayload {
    return {
      eventId: 0,
      omitLastRound: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTablesStatePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.omitLastRound) {
      json["omitLastRound"] = msg.omitLastRound;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTablesStatePayload,
    json: any,
  ): EventsGetTablesStatePayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _omitLastRound_ = json["omitLastRound"] ?? json["omit_last_round"];
    if (_omitLastRound_) {
      msg.omitLastRound = _omitLastRound_;
    }
    return msg;
  },
};

export const EventsGetTablesStateResponseJSON = {
  /**
   * Serializes EventsGetTablesStateResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetTablesStateResponse>): string {
    return JSON.stringify(EventsGetTablesStateResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetTablesStateResponse from JSON.
   */
  decode: function (json: string): EventsGetTablesStateResponse {
    return EventsGetTablesStateResponseJSON._readMessage(
      EventsGetTablesStateResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetTablesStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetTablesStateResponse>,
  ): EventsGetTablesStateResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetTablesStateResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(protoAtoms.TableStateJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetTablesStateResponse,
    json: any,
  ): EventsGetTablesStateResponse {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = protoAtoms.TableStateJSON.initialize();
        protoAtoms.TableStateJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const EventsRegisterPlayerPayloadJSON = {
  /**
   * Serializes EventsRegisterPlayerPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsRegisterPlayerPayload>): string {
    return JSON.stringify(EventsRegisterPlayerPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsRegisterPlayerPayload from JSON.
   */
  decode: function (json: string): EventsRegisterPlayerPayload {
    return EventsRegisterPlayerPayloadJSON._readMessage(
      EventsRegisterPlayerPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsRegisterPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsRegisterPlayerPayload>,
  ): EventsRegisterPlayerPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsRegisterPlayerPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsRegisterPlayerPayload,
    json: any,
  ): EventsRegisterPlayerPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const EventsUnregisterPlayerPayloadJSON = {
  /**
   * Serializes EventsUnregisterPlayerPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsUnregisterPlayerPayload>): string {
    return JSON.stringify(EventsUnregisterPlayerPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsUnregisterPlayerPayload from JSON.
   */
  decode: function (json: string): EventsUnregisterPlayerPayload {
    return EventsUnregisterPlayerPayloadJSON._readMessage(
      EventsUnregisterPlayerPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUnregisterPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUnregisterPlayerPayload>,
  ): EventsUnregisterPlayerPayload {
    return {
      playerId: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUnregisterPlayerPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUnregisterPlayerPayload,
    json: any,
  ): EventsUnregisterPlayerPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const EventsUpdatePlayerSeatingFlagPayloadJSON = {
  /**
   * Serializes EventsUpdatePlayerSeatingFlagPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayerSeatingFlagPayload>,
  ): string {
    return JSON.stringify(
      EventsUpdatePlayerSeatingFlagPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsUpdatePlayerSeatingFlagPayload from JSON.
   */
  decode: function (json: string): EventsUpdatePlayerSeatingFlagPayload {
    return EventsUpdatePlayerSeatingFlagPayloadJSON._readMessage(
      EventsUpdatePlayerSeatingFlagPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdatePlayerSeatingFlagPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayerSeatingFlagPayload>,
  ): EventsUpdatePlayerSeatingFlagPayload {
    return {
      playerId: 0,
      eventId: 0,
      ignoreSeating: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayerSeatingFlagPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.ignoreSeating) {
      json["ignoreSeating"] = msg.ignoreSeating;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayerSeatingFlagPayload,
    json: any,
  ): EventsUpdatePlayerSeatingFlagPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _ignoreSeating_ = json["ignoreSeating"] ?? json["ignore_seating"];
    if (_ignoreSeating_) {
      msg.ignoreSeating = _ignoreSeating_;
    }
    return msg;
  },
};

export const EventsGetAchievementsPayloadJSON = {
  /**
   * Serializes EventsGetAchievementsPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetAchievementsPayload>): string {
    return JSON.stringify(EventsGetAchievementsPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetAchievementsPayload from JSON.
   */
  decode: function (json: string): EventsGetAchievementsPayload {
    return EventsGetAchievementsPayloadJSON._readMessage(
      EventsGetAchievementsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetAchievementsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAchievementsPayload>,
  ): EventsGetAchievementsPayload {
    return {
      achievementsList: [],
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAchievementsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.achievementsList?.length) {
      json["achievementsList"] = msg.achievementsList;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAchievementsPayload,
    json: any,
  ): EventsGetAchievementsPayload {
    const _achievementsList_ =
      json["achievementsList"] ?? json["achievements_list"];
    if (_achievementsList_) {
      msg.achievementsList = _achievementsList_;
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const EventsGetAchievementsResponseJSON = {
  /**
   * Serializes EventsGetAchievementsResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetAchievementsResponse>): string {
    return JSON.stringify(EventsGetAchievementsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes EventsGetAchievementsResponse from JSON.
   */
  decode: function (json: string): EventsGetAchievementsResponse {
    return EventsGetAchievementsResponseJSON._readMessage(
      EventsGetAchievementsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetAchievementsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetAchievementsResponse>,
  ): EventsGetAchievementsResponse {
    return {
      achievements: [],
      lastUpdate: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetAchievementsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.achievements?.length) {
      json["achievements"] = msg.achievements.map(
        protoAtoms.AchievementJSON._writeMessage,
      );
    }
    if (msg.lastUpdate) {
      json["lastUpdate"] = msg.lastUpdate;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetAchievementsResponse,
    json: any,
  ): EventsGetAchievementsResponse {
    const _achievements_ = json["achievements"];
    if (_achievements_) {
      for (const item of _achievements_) {
        const m = protoAtoms.AchievementJSON.initialize();
        protoAtoms.AchievementJSON._readMessage(m, item);
        msg.achievements.push(m);
      }
    }
    const _lastUpdate_ = json["lastUpdate"] ?? json["last_update"];
    if (_lastUpdate_) {
      msg.lastUpdate = _lastUpdate_;
    }
    return msg;
  },
};

export const EventsUpdatePlayersLocalIdsPayloadJSON = {
  /**
   * Serializes EventsUpdatePlayersLocalIdsPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayersLocalIdsPayload>,
  ): string {
    return JSON.stringify(
      EventsUpdatePlayersLocalIdsPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsUpdatePlayersLocalIdsPayload from JSON.
   */
  decode: function (json: string): EventsUpdatePlayersLocalIdsPayload {
    return EventsUpdatePlayersLocalIdsPayloadJSON._readMessage(
      EventsUpdatePlayersLocalIdsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdatePlayersLocalIdsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayersLocalIdsPayload>,
  ): EventsUpdatePlayersLocalIdsPayload {
    return {
      eventId: 0,
      idsToLocalIds: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayersLocalIdsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.idsToLocalIds?.length) {
      json["idsToLocalIds"] = msg.idsToLocalIds.map(
        protoAtoms.LocalIdMappingJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayersLocalIdsPayload,
    json: any,
  ): EventsUpdatePlayersLocalIdsPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _idsToLocalIds_ = json["idsToLocalIds"] ?? json["ids_to_local_ids"];
    if (_idsToLocalIds_) {
      for (const item of _idsToLocalIds_) {
        const m = protoAtoms.LocalIdMappingJSON.initialize();
        protoAtoms.LocalIdMappingJSON._readMessage(m, item);
        msg.idsToLocalIds.push(m);
      }
    }
    return msg;
  },
};

export const EventsUpdatePlayerReplacementPayloadJSON = {
  /**
   * Serializes EventsUpdatePlayerReplacementPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePlayerReplacementPayload>,
  ): string {
    return JSON.stringify(
      EventsUpdatePlayerReplacementPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsUpdatePlayerReplacementPayload from JSON.
   */
  decode: function (json: string): EventsUpdatePlayerReplacementPayload {
    return EventsUpdatePlayerReplacementPayloadJSON._readMessage(
      EventsUpdatePlayerReplacementPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdatePlayerReplacementPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayerReplacementPayload>,
  ): EventsUpdatePlayerReplacementPayload {
    return {
      playerId: 0,
      eventId: 0,
      replacementId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayerReplacementPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.replacementId) {
      json["replacementId"] = msg.replacementId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayerReplacementPayload,
    json: any,
  ): EventsUpdatePlayerReplacementPayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _replacementId_ = json["replacementId"] ?? json["replacement_id"];
    if (_replacementId_) {
      msg.replacementId = protoscript.parseNumber(_replacementId_);
    }
    return msg;
  },
};

export const EventsUpdatePlayersTeamsPayloadJSON = {
  /**
   * Serializes EventsUpdatePlayersTeamsPayload to JSON.
   */
  encode: function (msg: PartialDeep<EventsUpdatePlayersTeamsPayload>): string {
    return JSON.stringify(
      EventsUpdatePlayersTeamsPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsUpdatePlayersTeamsPayload from JSON.
   */
  decode: function (json: string): EventsUpdatePlayersTeamsPayload {
    return EventsUpdatePlayersTeamsPayloadJSON._readMessage(
      EventsUpdatePlayersTeamsPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdatePlayersTeamsPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePlayersTeamsPayload>,
  ): EventsUpdatePlayersTeamsPayload {
    return {
      eventId: 0,
      idsToTeamNames: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePlayersTeamsPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.idsToTeamNames?.length) {
      json["idsToTeamNames"] = msg.idsToTeamNames.map(
        protoAtoms.TeamMappingJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePlayersTeamsPayload,
    json: any,
  ): EventsUpdatePlayersTeamsPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _idsToTeamNames_ =
      json["idsToTeamNames"] ?? json["ids_to_team_names"];
    if (_idsToTeamNames_) {
      for (const item of _idsToTeamNames_) {
        const m = protoAtoms.TeamMappingJSON.initialize();
        protoAtoms.TeamMappingJSON._readMessage(m, item);
        msg.idsToTeamNames.push(m);
      }
    }
    return msg;
  },
};

export const GamesStartGamePayloadJSON = {
  /**
   * Serializes GamesStartGamePayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesStartGamePayload>): string {
    return JSON.stringify(GamesStartGamePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesStartGamePayload from JSON.
   */
  decode: function (json: string): GamesStartGamePayload {
    return GamesStartGamePayloadJSON._readMessage(
      GamesStartGamePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesStartGamePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesStartGamePayload>,
  ): GamesStartGamePayload {
    return {
      eventId: 0,
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesStartGamePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.players?.length) {
      json["players"] = msg.players;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesStartGamePayload,
    json: any,
  ): GamesStartGamePayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _players_ = json["players"];
    if (_players_) {
      msg.players = _players_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const GamesDropLastRoundPayloadJSON = {
  /**
   * Serializes GamesDropLastRoundPayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesDropLastRoundPayload>): string {
    return JSON.stringify(GamesDropLastRoundPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesDropLastRoundPayload from JSON.
   */
  decode: function (json: string): GamesDropLastRoundPayload {
    return GamesDropLastRoundPayloadJSON._readMessage(
      GamesDropLastRoundPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesDropLastRoundPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesDropLastRoundPayload>,
  ): GamesDropLastRoundPayload {
    return {
      sessionHash: "",
      intermediateResults: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesDropLastRoundPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHash) {
      json["sessionHash"] = msg.sessionHash;
    }
    if (msg.intermediateResults?.length) {
      json["intermediateResults"] = msg.intermediateResults.map(
        protoAtoms.IntermediateResultOfSessionJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesDropLastRoundPayload,
    json: any,
  ): GamesDropLastRoundPayload {
    const _sessionHash_ = json["sessionHash"] ?? json["session_hash"];
    if (_sessionHash_) {
      msg.sessionHash = _sessionHash_;
    }
    const _intermediateResults_ =
      json["intermediateResults"] ?? json["intermediate_results"];
    if (_intermediateResults_) {
      for (const item of _intermediateResults_) {
        const m = protoAtoms.IntermediateResultOfSessionJSON.initialize();
        protoAtoms.IntermediateResultOfSessionJSON._readMessage(m, item);
        msg.intermediateResults.push(m);
      }
    }
    return msg;
  },
};

export const GamesAddPenaltyPayloadJSON = {
  /**
   * Serializes GamesAddPenaltyPayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddPenaltyPayload>): string {
    return JSON.stringify(GamesAddPenaltyPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddPenaltyPayload from JSON.
   */
  decode: function (json: string): GamesAddPenaltyPayload {
    return GamesAddPenaltyPayloadJSON._readMessage(
      GamesAddPenaltyPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddPenaltyPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddPenaltyPayload>,
  ): GamesAddPenaltyPayload {
    return {
      eventId: 0,
      playerId: 0,
      amount: 0,
      reason: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddPenaltyPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    if (msg.amount) {
      json["amount"] = msg.amount;
    }
    if (msg.reason) {
      json["reason"] = msg.reason;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddPenaltyPayload,
    json: any,
  ): GamesAddPenaltyPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    const _amount_ = json["amount"];
    if (_amount_) {
      msg.amount = protoscript.parseNumber(_amount_);
    }
    const _reason_ = json["reason"];
    if (_reason_) {
      msg.reason = _reason_;
    }
    return msg;
  },
};

export const GamesAddPenaltyGamePayloadJSON = {
  /**
   * Serializes GamesAddPenaltyGamePayload to JSON.
   */
  encode: function (msg: PartialDeep<GamesAddPenaltyGamePayload>): string {
    return JSON.stringify(GamesAddPenaltyGamePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GamesAddPenaltyGamePayload from JSON.
   */
  decode: function (json: string): GamesAddPenaltyGamePayload {
    return GamesAddPenaltyGamePayloadJSON._readMessage(
      GamesAddPenaltyGamePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GamesAddPenaltyGamePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GamesAddPenaltyGamePayload>,
  ): GamesAddPenaltyGamePayload {
    return {
      eventId: 0,
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GamesAddPenaltyGamePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.players?.length) {
      json["players"] = msg.players;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GamesAddPenaltyGamePayload,
    json: any,
  ): GamesAddPenaltyGamePayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _players_ = json["players"];
    if (_players_) {
      msg.players = _players_.map(protoscript.parseNumber);
    }
    return msg;
  },
};

export const PlayersGetPlayerPayloadJSON = {
  /**
   * Serializes PlayersGetPlayerPayload to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerPayload>): string {
    return JSON.stringify(PlayersGetPlayerPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetPlayerPayload from JSON.
   */
  decode: function (json: string): PlayersGetPlayerPayload {
    return PlayersGetPlayerPayloadJSON._readMessage(
      PlayersGetPlayerPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetPlayerPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerPayload>,
  ): PlayersGetPlayerPayload {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerPayload,
    json: any,
  ): PlayersGetPlayerPayload {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    return msg;
  },
};

export const PlayersGetPlayerResponseJSON = {
  /**
   * Serializes PlayersGetPlayerResponse to JSON.
   */
  encode: function (msg: PartialDeep<PlayersGetPlayerResponse>): string {
    return JSON.stringify(PlayersGetPlayerResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PlayersGetPlayerResponse from JSON.
   */
  decode: function (json: string): PlayersGetPlayerResponse {
    return PlayersGetPlayerResponseJSON._readMessage(
      PlayersGetPlayerResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PlayersGetPlayerResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<PlayersGetPlayerResponse>,
  ): PlayersGetPlayerResponse {
    return {
      players: protoAtoms.PlayerJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PlayersGetPlayerResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players) {
      const _players_ = protoAtoms.PlayerJSON._writeMessage(msg.players);
      if (Object.keys(_players_).length > 0) {
        json["players"] = _players_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PlayersGetPlayerResponse,
    json: any,
  ): PlayersGetPlayerResponse {
    const _players_ = json["players"];
    if (_players_) {
      protoAtoms.PlayerJSON._readMessage(msg.players, _players_);
    }
    return msg;
  },
};

export const EventsGetCurrentSeatingResponseJSON = {
  /**
   * Serializes EventsGetCurrentSeatingResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetCurrentSeatingResponse>): string {
    return JSON.stringify(
      EventsGetCurrentSeatingResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsGetCurrentSeatingResponse from JSON.
   */
  decode: function (json: string): EventsGetCurrentSeatingResponse {
    return EventsGetCurrentSeatingResponseJSON._readMessage(
      EventsGetCurrentSeatingResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetCurrentSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetCurrentSeatingResponse>,
  ): EventsGetCurrentSeatingResponse {
    return {
      seating: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetCurrentSeatingResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seating?.length) {
      json["seating"] = msg.seating.map(
        protoAtoms.PlayerSeatingJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetCurrentSeatingResponse,
    json: any,
  ): EventsGetCurrentSeatingResponse {
    const _seating_ = json["seating"];
    if (_seating_) {
      for (const item of _seating_) {
        const m = protoAtoms.PlayerSeatingJSON.initialize();
        protoAtoms.PlayerSeatingJSON._readMessage(m, item);
        msg.seating.push(m);
      }
    }
    return msg;
  },
};

export const SeatingMakeShuffledSeatingPayloadJSON = {
  /**
   * Serializes SeatingMakeShuffledSeatingPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingMakeShuffledSeatingPayload>,
  ): string {
    return JSON.stringify(
      SeatingMakeShuffledSeatingPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingMakeShuffledSeatingPayload from JSON.
   */
  decode: function (json: string): SeatingMakeShuffledSeatingPayload {
    return SeatingMakeShuffledSeatingPayloadJSON._readMessage(
      SeatingMakeShuffledSeatingPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingMakeShuffledSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakeShuffledSeatingPayload>,
  ): SeatingMakeShuffledSeatingPayload {
    return {
      eventId: 0,
      groupsCount: 0,
      seed: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakeShuffledSeatingPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.groupsCount) {
      json["groupsCount"] = msg.groupsCount;
    }
    if (msg.seed) {
      json["seed"] = msg.seed;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakeShuffledSeatingPayload,
    json: any,
  ): SeatingMakeShuffledSeatingPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _groupsCount_ = json["groupsCount"] ?? json["groups_count"];
    if (_groupsCount_) {
      msg.groupsCount = protoscript.parseNumber(_groupsCount_);
    }
    const _seed_ = json["seed"];
    if (_seed_) {
      msg.seed = protoscript.parseNumber(_seed_);
    }
    return msg;
  },
};

export const SeatingGenerateSwissSeatingPayloadJSON = {
  /**
   * Serializes SeatingGenerateSwissSeatingPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingPayload>,
  ): string {
    return JSON.stringify(
      SeatingGenerateSwissSeatingPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingGenerateSwissSeatingPayload from JSON.
   */
  decode: function (json: string): SeatingGenerateSwissSeatingPayload {
    return SeatingGenerateSwissSeatingPayloadJSON._readMessage(
      SeatingGenerateSwissSeatingPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingGenerateSwissSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGenerateSwissSeatingPayload>,
  ): SeatingGenerateSwissSeatingPayload {
    return {
      eventId: 0,
      substituteReplacementPlayers: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.substituteReplacementPlayers) {
      json["substituteReplacementPlayers"] = msg.substituteReplacementPlayers;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGenerateSwissSeatingPayload,
    json: any,
  ): SeatingGenerateSwissSeatingPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _substituteReplacementPlayers_ =
      json["substituteReplacementPlayers"] ??
      json["substitute_replacement_players"];
    if (_substituteReplacementPlayers_) {
      msg.substituteReplacementPlayers = _substituteReplacementPlayers_;
    }
    return msg;
  },
};

export const SeatingGenerateSwissSeatingResponseJSON = {
  /**
   * Serializes SeatingGenerateSwissSeatingResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingResponse>,
  ): string {
    return JSON.stringify(
      SeatingGenerateSwissSeatingResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingGenerateSwissSeatingResponse from JSON.
   */
  decode: function (json: string): SeatingGenerateSwissSeatingResponse {
    return SeatingGenerateSwissSeatingResponseJSON._readMessage(
      SeatingGenerateSwissSeatingResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingGenerateSwissSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGenerateSwissSeatingResponse>,
  ): SeatingGenerateSwissSeatingResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGenerateSwissSeatingResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(
        protoAtoms.TableItemSwissJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGenerateSwissSeatingResponse,
    json: any,
  ): SeatingGenerateSwissSeatingResponse {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = protoAtoms.TableItemSwissJSON.initialize();
        protoAtoms.TableItemSwissJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const SeatingMakeIntervalSeatingPayloadJSON = {
  /**
   * Serializes SeatingMakeIntervalSeatingPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingMakeIntervalSeatingPayload>,
  ): string {
    return JSON.stringify(
      SeatingMakeIntervalSeatingPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingMakeIntervalSeatingPayload from JSON.
   */
  decode: function (json: string): SeatingMakeIntervalSeatingPayload {
    return SeatingMakeIntervalSeatingPayloadJSON._readMessage(
      SeatingMakeIntervalSeatingPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingMakeIntervalSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakeIntervalSeatingPayload>,
  ): SeatingMakeIntervalSeatingPayload {
    return {
      eventId: 0,
      step: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakeIntervalSeatingPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.step) {
      json["step"] = msg.step;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakeIntervalSeatingPayload,
    json: any,
  ): SeatingMakeIntervalSeatingPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _step_ = json["step"];
    if (_step_) {
      msg.step = protoscript.parseNumber(_step_);
    }
    return msg;
  },
};

export const SeatingMakePrescriptedSeatingPayloadJSON = {
  /**
   * Serializes SeatingMakePrescriptedSeatingPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingMakePrescriptedSeatingPayload>,
  ): string {
    return JSON.stringify(
      SeatingMakePrescriptedSeatingPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingMakePrescriptedSeatingPayload from JSON.
   */
  decode: function (json: string): SeatingMakePrescriptedSeatingPayload {
    return SeatingMakePrescriptedSeatingPayloadJSON._readMessage(
      SeatingMakePrescriptedSeatingPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingMakePrescriptedSeatingPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingMakePrescriptedSeatingPayload>,
  ): SeatingMakePrescriptedSeatingPayload {
    return {
      eventId: 0,
      randomizeAtTables: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingMakePrescriptedSeatingPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.randomizeAtTables) {
      json["randomizeAtTables"] = msg.randomizeAtTables;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingMakePrescriptedSeatingPayload,
    json: any,
  ): SeatingMakePrescriptedSeatingPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _randomizeAtTables_ =
      json["randomizeAtTables"] ?? json["randomize_at_tables"];
    if (_randomizeAtTables_) {
      msg.randomizeAtTables = _randomizeAtTables_;
    }
    return msg;
  },
};

export const SeatingGetNextPrescriptedSeatingResponseJSON = {
  /**
   * Serializes SeatingGetNextPrescriptedSeatingResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<SeatingGetNextPrescriptedSeatingResponse>,
  ): string {
    return JSON.stringify(
      SeatingGetNextPrescriptedSeatingResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes SeatingGetNextPrescriptedSeatingResponse from JSON.
   */
  decode: function (json: string): SeatingGetNextPrescriptedSeatingResponse {
    return SeatingGetNextPrescriptedSeatingResponseJSON._readMessage(
      SeatingGetNextPrescriptedSeatingResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SeatingGetNextPrescriptedSeatingResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<SeatingGetNextPrescriptedSeatingResponse>,
  ): SeatingGetNextPrescriptedSeatingResponse {
    return {
      tables: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SeatingGetNextPrescriptedSeatingResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tables?.length) {
      json["tables"] = msg.tables.map(
        protoAtoms.PrescriptedTableJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SeatingGetNextPrescriptedSeatingResponse,
    json: any,
  ): SeatingGetNextPrescriptedSeatingResponse {
    const _tables_ = json["tables"];
    if (_tables_) {
      for (const item of _tables_) {
        const m = protoAtoms.PrescriptedTableJSON.initialize();
        protoAtoms.PrescriptedTableJSON._readMessage(m, item);
        msg.tables.push(m);
      }
    }
    return msg;
  },
};

export const EventsGetPrescriptedEventConfigResponseJSON = {
  /**
   * Serializes EventsGetPrescriptedEventConfigResponse to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsGetPrescriptedEventConfigResponse>,
  ): string {
    return JSON.stringify(
      EventsGetPrescriptedEventConfigResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsGetPrescriptedEventConfigResponse from JSON.
   */
  decode: function (json: string): EventsGetPrescriptedEventConfigResponse {
    return EventsGetPrescriptedEventConfigResponseJSON._readMessage(
      EventsGetPrescriptedEventConfigResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetPrescriptedEventConfigResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetPrescriptedEventConfigResponse>,
  ): EventsGetPrescriptedEventConfigResponse {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: undefined,
      errors: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetPrescriptedEventConfigResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.nextSessionIndex) {
      json["nextSessionIndex"] = msg.nextSessionIndex;
    }
    if (msg.prescript != undefined) {
      json["prescript"] = msg.prescript;
    }
    if (msg.errors?.length) {
      json["errors"] = msg.errors;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetPrescriptedEventConfigResponse,
    json: any,
  ): EventsGetPrescriptedEventConfigResponse {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _nextSessionIndex_ =
      json["nextSessionIndex"] ?? json["next_session_index"];
    if (_nextSessionIndex_) {
      msg.nextSessionIndex = protoscript.parseNumber(_nextSessionIndex_);
    }
    const _prescript_ = json["prescript"];
    if (_prescript_) {
      msg.prescript = _prescript_;
    }
    const _errors_ = json["errors"];
    if (_errors_) {
      msg.errors = _errors_;
    }
    return msg;
  },
};

export const EventsUpdatePrescriptedEventConfigPayloadJSON = {
  /**
   * Serializes EventsUpdatePrescriptedEventConfigPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<EventsUpdatePrescriptedEventConfigPayload>,
  ): string {
    return JSON.stringify(
      EventsUpdatePrescriptedEventConfigPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsUpdatePrescriptedEventConfigPayload from JSON.
   */
  decode: function (json: string): EventsUpdatePrescriptedEventConfigPayload {
    return EventsUpdatePrescriptedEventConfigPayloadJSON._readMessage(
      EventsUpdatePrescriptedEventConfigPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsUpdatePrescriptedEventConfigPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsUpdatePrescriptedEventConfigPayload>,
  ): EventsUpdatePrescriptedEventConfigPayload {
    return {
      eventId: 0,
      nextSessionIndex: 0,
      prescript: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsUpdatePrescriptedEventConfigPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.nextSessionIndex) {
      json["nextSessionIndex"] = msg.nextSessionIndex;
    }
    if (msg.prescript) {
      json["prescript"] = msg.prescript;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsUpdatePrescriptedEventConfigPayload,
    json: any,
  ): EventsUpdatePrescriptedEventConfigPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _nextSessionIndex_ =
      json["nextSessionIndex"] ?? json["next_session_index"];
    if (_nextSessionIndex_) {
      msg.nextSessionIndex = protoscript.parseNumber(_nextSessionIndex_);
    }
    const _prescript_ = json["prescript"];
    if (_prescript_) {
      msg.prescript = _prescript_;
    }
    return msg;
  },
};

export const EventsGetStartingTimerResponseJSON = {
  /**
   * Serializes EventsGetStartingTimerResponse to JSON.
   */
  encode: function (msg: PartialDeep<EventsGetStartingTimerResponse>): string {
    return JSON.stringify(
      EventsGetStartingTimerResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes EventsGetStartingTimerResponse from JSON.
   */
  decode: function (json: string): EventsGetStartingTimerResponse {
    return EventsGetStartingTimerResponseJSON._readMessage(
      EventsGetStartingTimerResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes EventsGetStartingTimerResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<EventsGetStartingTimerResponse>,
  ): EventsGetStartingTimerResponse {
    return {
      timer: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<EventsGetStartingTimerResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.timer) {
      json["timer"] = msg.timer;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: EventsGetStartingTimerResponse,
    json: any,
  ): EventsGetStartingTimerResponse {
    const _timer_ = json["timer"];
    if (_timer_) {
      msg.timer = protoscript.parseNumber(_timer_);
    }
    return msg;
  },
};

export const ClearStatCachePayloadJSON = {
  /**
   * Serializes ClearStatCachePayload to JSON.
   */
  encode: function (msg: PartialDeep<ClearStatCachePayload>): string {
    return JSON.stringify(ClearStatCachePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes ClearStatCachePayload from JSON.
   */
  decode: function (json: string): ClearStatCachePayload {
    return ClearStatCachePayloadJSON._readMessage(
      ClearStatCachePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ClearStatCachePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ClearStatCachePayload>,
  ): ClearStatCachePayload {
    return {
      playerId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ClearStatCachePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ClearStatCachePayload,
    json: any,
  ): ClearStatCachePayload {
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    return msg;
  },
};

export const TypedGamesAddOnlineReplayPayloadJSON = {
  /**
   * Serializes TypedGamesAddOnlineReplayPayload to JSON.
   */
  encode: function (
    msg: PartialDeep<TypedGamesAddOnlineReplayPayload>,
  ): string {
    return JSON.stringify(
      TypedGamesAddOnlineReplayPayloadJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes TypedGamesAddOnlineReplayPayload from JSON.
   */
  decode: function (json: string): TypedGamesAddOnlineReplayPayload {
    return TypedGamesAddOnlineReplayPayloadJSON._readMessage(
      TypedGamesAddOnlineReplayPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TypedGamesAddOnlineReplayPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<TypedGamesAddOnlineReplayPayload>,
  ): TypedGamesAddOnlineReplayPayload {
    return {
      eventId: 0,
      platformId: 0,
      contentType: 0,
      logTimestamp: 0,
      replayHash: "",
      content: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TypedGamesAddOnlineReplayPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.platformId) {
      json["platformId"] = msg.platformId;
    }
    if (msg.contentType) {
      json["contentType"] = msg.contentType;
    }
    if (msg.logTimestamp) {
      json["logTimestamp"] = msg.logTimestamp;
    }
    if (msg.replayHash) {
      json["replayHash"] = msg.replayHash;
    }
    if (msg.content) {
      json["content"] = msg.content;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TypedGamesAddOnlineReplayPayload,
    json: any,
  ): TypedGamesAddOnlineReplayPayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _platformId_ = json["platformId"] ?? json["platform_id"];
    if (_platformId_) {
      msg.platformId = protoscript.parseNumber(_platformId_);
    }
    const _contentType_ = json["contentType"] ?? json["content_type"];
    if (_contentType_) {
      msg.contentType = protoscript.parseNumber(_contentType_);
    }
    const _logTimestamp_ = json["logTimestamp"] ?? json["log_timestamp"];
    if (_logTimestamp_) {
      msg.logTimestamp = protoscript.parseNumber(_logTimestamp_);
    }
    const _replayHash_ = json["replayHash"] ?? json["replay_hash"];
    if (_replayHash_) {
      msg.replayHash = _replayHash_;
    }
    const _content_ = json["content"];
    if (_content_) {
      msg.content = _content_;
    }
    return msg;
  },
};

export const CallRefereePayloadJSON = {
  /**
   * Serializes CallRefereePayload to JSON.
   */
  encode: function (msg: PartialDeep<CallRefereePayload>): string {
    return JSON.stringify(CallRefereePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes CallRefereePayload from JSON.
   */
  decode: function (json: string): CallRefereePayload {
    return CallRefereePayloadJSON._readMessage(
      CallRefereePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CallRefereePayload with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CallRefereePayload>): CallRefereePayload {
    return {
      tableIndex: 0,
      eventId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CallRefereePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tableIndex) {
      json["tableIndex"] = msg.tableIndex;
    }
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CallRefereePayload,
    json: any,
  ): CallRefereePayload {
    const _tableIndex_ = json["tableIndex"] ?? json["table_index"];
    if (_tableIndex_) {
      msg.tableIndex = protoscript.parseNumber(_tableIndex_);
    }
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    return msg;
  },
};

export const PenaltiesResponseJSON = {
  /**
   * Serializes PenaltiesResponse to JSON.
   */
  encode: function (msg: PartialDeep<PenaltiesResponse>): string {
    return JSON.stringify(PenaltiesResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes PenaltiesResponse from JSON.
   */
  decode: function (json: string): PenaltiesResponse {
    return PenaltiesResponseJSON._readMessage(
      PenaltiesResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes PenaltiesResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<PenaltiesResponse>): PenaltiesResponse {
    return {
      penalties: [],
      referees: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<PenaltiesResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.penalties?.length) {
      json["penalties"] = msg.penalties.map(
        protoAtoms.PenaltyJSON._writeMessage,
      );
    }
    if (msg.referees?.length) {
      json["referees"] = msg.referees.map(protoAtoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PenaltiesResponse,
    json: any,
  ): PenaltiesResponse {
    const _penalties_ = json["penalties"];
    if (_penalties_) {
      for (const item of _penalties_) {
        const m = protoAtoms.PenaltyJSON.initialize();
        protoAtoms.PenaltyJSON._readMessage(m, item);
        msg.penalties.push(m);
      }
    }
    const _referees_ = json["referees"];
    if (_referees_) {
      for (const item of _referees_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.referees.push(m);
      }
    }
    return msg;
  },
};

export const CancelPenaltyPayloadJSON = {
  /**
   * Serializes CancelPenaltyPayload to JSON.
   */
  encode: function (msg: PartialDeep<CancelPenaltyPayload>): string {
    return JSON.stringify(CancelPenaltyPayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes CancelPenaltyPayload from JSON.
   */
  decode: function (json: string): CancelPenaltyPayload {
    return CancelPenaltyPayloadJSON._readMessage(
      CancelPenaltyPayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CancelPenaltyPayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CancelPenaltyPayload>,
  ): CancelPenaltyPayload {
    return {
      penaltyId: 0,
      reason: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelPenaltyPayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.penaltyId) {
      json["penaltyId"] = msg.penaltyId;
    }
    if (msg.reason != undefined) {
      json["reason"] = msg.reason;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelPenaltyPayload,
    json: any,
  ): CancelPenaltyPayload {
    const _penaltyId_ = json["penaltyId"] ?? json["penalty_id"];
    if (_penaltyId_) {
      msg.penaltyId = protoscript.parseNumber(_penaltyId_);
    }
    const _reason_ = json["reason"];
    if (_reason_) {
      msg.reason = _reason_;
    }
    return msg;
  },
};

export const AddExtraTimePayloadJSON = {
  /**
   * Serializes AddExtraTimePayload to JSON.
   */
  encode: function (msg: PartialDeep<AddExtraTimePayload>): string {
    return JSON.stringify(AddExtraTimePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes AddExtraTimePayload from JSON.
   */
  decode: function (json: string): AddExtraTimePayload {
    return AddExtraTimePayloadJSON._readMessage(
      AddExtraTimePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes AddExtraTimePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<AddExtraTimePayload>,
  ): AddExtraTimePayload {
    return {
      sessionHashList: [],
      extraTime: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AddExtraTimePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessionHashList?.length) {
      json["sessionHashList"] = msg.sessionHashList;
    }
    if (msg.extraTime) {
      json["extraTime"] = msg.extraTime;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AddExtraTimePayload,
    json: any,
  ): AddExtraTimePayload {
    const _sessionHashList_ =
      json["sessionHashList"] ?? json["session_hash_list"];
    if (_sessionHashList_) {
      msg.sessionHashList = _sessionHashList_;
    }
    const _extraTime_ = json["extraTime"] ?? json["extra_time"];
    if (_extraTime_) {
      msg.extraTime = protoscript.parseNumber(_extraTime_);
    }
    return msg;
  },
};

export const GetCurrentStatePayloadJSON = {
  /**
   * Serializes GetCurrentStatePayload to JSON.
   */
  encode: function (msg: PartialDeep<GetCurrentStatePayload>): string {
    return JSON.stringify(GetCurrentStatePayloadJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetCurrentStatePayload from JSON.
   */
  decode: function (json: string): GetCurrentStatePayload {
    return GetCurrentStatePayloadJSON._readMessage(
      GetCurrentStatePayloadJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetCurrentStatePayload with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCurrentStatePayload>,
  ): GetCurrentStatePayload {
    return {
      eventId: 0,
      playerId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCurrentStatePayload>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.eventId) {
      json["eventId"] = msg.eventId;
    }
    if (msg.playerId) {
      json["playerId"] = msg.playerId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCurrentStatePayload,
    json: any,
  ): GetCurrentStatePayload {
    const _eventId_ = json["eventId"] ?? json["event_id"];
    if (_eventId_) {
      msg.eventId = protoscript.parseNumber(_eventId_);
    }
    const _playerId_ = json["playerId"] ?? json["player_id"];
    if (_playerId_) {
      msg.playerId = protoscript.parseNumber(_playerId_);
    }
    return msg;
  },
};

export const GetCurrentStateResponseJSON = {
  /**
   * Serializes GetCurrentStateResponse to JSON.
   */
  encode: function (msg: PartialDeep<GetCurrentStateResponse>): string {
    return JSON.stringify(GetCurrentStateResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetCurrentStateResponse from JSON.
   */
  decode: function (json: string): GetCurrentStateResponse {
    return GetCurrentStateResponseJSON._readMessage(
      GetCurrentStateResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetCurrentStateResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCurrentStateResponse>,
  ): GetCurrentStateResponse {
    return {
      sessions: [],
      config: protoAtoms.GameConfigJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCurrentStateResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sessions?.length) {
      json["sessions"] = msg.sessions.map(CurrentSessionJSON._writeMessage);
    }
    if (msg.config) {
      const _config_ = protoAtoms.GameConfigJSON._writeMessage(msg.config);
      if (Object.keys(_config_).length > 0) {
        json["config"] = _config_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCurrentStateResponse,
    json: any,
  ): GetCurrentStateResponse {
    const _sessions_ = json["sessions"];
    if (_sessions_) {
      for (const item of _sessions_) {
        const m = CurrentSessionJSON.initialize();
        CurrentSessionJSON._readMessage(m, item);
        msg.sessions.push(m);
      }
    }
    const _config_ = json["config"];
    if (_config_) {
      protoAtoms.GameConfigJSON._readMessage(msg.config, _config_);
    }
    return msg;
  },
};

export const ChomboResponseJSON = {
  /**
   * Serializes ChomboResponse to JSON.
   */
  encode: function (msg: PartialDeep<ChomboResponse>): string {
    return JSON.stringify(ChomboResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChomboResponse from JSON.
   */
  decode: function (json: string): ChomboResponse {
    return ChomboResponseJSON._readMessage(
      ChomboResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ChomboResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ChomboResponse>): ChomboResponse {
    return {
      chombos: [],
      players: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ChomboResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.chombos?.length) {
      json["chombos"] = msg.chombos.map(protoAtoms.ChomboJSON._writeMessage);
    }
    if (msg.players?.length) {
      json["players"] = msg.players.map(protoAtoms.PlayerJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChomboResponse, json: any): ChomboResponse {
    const _chombos_ = json["chombos"];
    if (_chombos_) {
      for (const item of _chombos_) {
        const m = protoAtoms.ChomboJSON.initialize();
        protoAtoms.ChomboJSON._readMessage(m, item);
        msg.chombos.push(m);
      }
    }
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = protoAtoms.PlayerJSON.initialize();
        protoAtoms.PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    return msg;
  },
};
