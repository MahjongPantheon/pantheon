// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: njord.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type N_RoundStatus = "NOT_STARTED" | "SEEDING" | "PLAYING" | "ENDED";

export type N_TileValue =
  | "NIL"
  | "PIN_1"
  | "PIN_2"
  | "PIN_3"
  | "PIN_4"
  | "PIN_5"
  | "PIN_6"
  | "PIN_7"
  | "PIN_8"
  | "PIN_9"
  | "SOU_1"
  | "SOU_2"
  | "SOU_3"
  | "SOU_4"
  | "SOU_5"
  | "SOU_6"
  | "SOU_7"
  | "SOU_8"
  | "SOU_9"
  | "MAN_1"
  | "MAN_2"
  | "MAN_3"
  | "MAN_4"
  | "MAN_5"
  | "MAN_6"
  | "MAN_7"
  | "MAN_8"
  | "MAN_9"
  | "HAKU"
  | "HATSU"
  | "CHUN"
  | "TON"
  | "NAN"
  | "SHA"
  | "PEI";

export type N_SetKind = "PON" | "CHI" | "ANKAN" | "SHOMINKAN" | "DAIMINKAN";

export type N_ClaimedFrom = "KAMICHA" | "TOIMEN" | "SHIMOCHA";

export type N_MoveState =
  | "WAITING"
  | "WAITING_FOR_DISCARD"
  | "WAITING_FOR_CLAIM";

export interface N_Player {
  id: number;
  title: string;
  rating: number;
}

export interface N_Tile {
  value: N_TileValue;
  isAka: boolean;
  isTsumogiri: boolean;
  isClaimed: boolean;
}

export interface N_Discard {
  tiles: N_Tile[];
  riichi: number;
}

export interface N_OpenSet {
  kind: N_SetKind;
  tiles: N_Tile[];
  from: N_ClaimedFrom;
}

export interface N_ClosedPart {
  closedPart: N_Tile[];
}

export interface N_Hand {
  closedPart?: N_ClosedPart | null | undefined;
  openedPart: N_OpenSet[];
  closedPartLength: number;
}

export interface N_Move {
  moveState: N_MoveState;
  lastDiscard: N_Tile;
  lastDiscardFrom: number;
}

export interface N_CurrentRound {
  discards: N_Discard[];
  tilesInWallCount: number;
  doraIndicators: N_TileValue[];
  currentRiichi: boolean[];
  moveState: N_Move;
  diceValue: number;
  /**
   * Filtered fields, existing only on server
   * Some of the data _can_ get to clients, but this should be filtered carefully
   */
  hands: N_Hand[];
}

export interface N_GameState {
  players: N_Player[];
  currentScores: number[];
  currentRound: number;
  currentRenchan: number;
  roundStatus: N_RoundStatus;
  riichiOnTable: number;
}

export interface N_TableState {
  game: N_GameState;
  currentRound: N_CurrentRound;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const N_RoundStatus = {
  NOT_STARTED: "NOT_STARTED",
  SEEDING: "SEEDING",
  PLAYING: "PLAYING",
  ENDED: "ENDED",
  /**
   * @private
   */
  _fromInt: function (i: number): N_RoundStatus {
    switch (i) {
      case 0: {
        return "NOT_STARTED";
      }
      case 1: {
        return "SEEDING";
      }
      case 2: {
        return "PLAYING";
      }
      case 3: {
        return "ENDED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_RoundStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_RoundStatus): number {
    switch (i) {
      case "NOT_STARTED": {
        return 0;
      }
      case "SEEDING": {
        return 1;
      }
      case "PLAYING": {
        return 2;
      }
      case "ENDED": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_TileValue = {
  NIL: "NIL",
  PIN_1: "PIN_1",
  PIN_2: "PIN_2",
  PIN_3: "PIN_3",
  PIN_4: "PIN_4",
  PIN_5: "PIN_5",
  PIN_6: "PIN_6",
  PIN_7: "PIN_7",
  PIN_8: "PIN_8",
  PIN_9: "PIN_9",
  SOU_1: "SOU_1",
  SOU_2: "SOU_2",
  SOU_3: "SOU_3",
  SOU_4: "SOU_4",
  SOU_5: "SOU_5",
  SOU_6: "SOU_6",
  SOU_7: "SOU_7",
  SOU_8: "SOU_8",
  SOU_9: "SOU_9",
  MAN_1: "MAN_1",
  MAN_2: "MAN_2",
  MAN_3: "MAN_3",
  MAN_4: "MAN_4",
  MAN_5: "MAN_5",
  MAN_6: "MAN_6",
  MAN_7: "MAN_7",
  MAN_8: "MAN_8",
  MAN_9: "MAN_9",
  HAKU: "HAKU",
  HATSU: "HATSU",
  CHUN: "CHUN",
  TON: "TON",
  NAN: "NAN",
  SHA: "SHA",
  PEI: "PEI",
  /**
   * @private
   */
  _fromInt: function (i: number): N_TileValue {
    switch (i) {
      case 0: {
        return "NIL";
      }
      case 17: {
        return "PIN_1";
      }
      case 18: {
        return "PIN_2";
      }
      case 19: {
        return "PIN_3";
      }
      case 20: {
        return "PIN_4";
      }
      case 21: {
        return "PIN_5";
      }
      case 22: {
        return "PIN_6";
      }
      case 23: {
        return "PIN_7";
      }
      case 24: {
        return "PIN_8";
      }
      case 25: {
        return "PIN_9";
      }
      case 33: {
        return "SOU_1";
      }
      case 34: {
        return "SOU_2";
      }
      case 35: {
        return "SOU_3";
      }
      case 36: {
        return "SOU_4";
      }
      case 37: {
        return "SOU_5";
      }
      case 38: {
        return "SOU_6";
      }
      case 39: {
        return "SOU_7";
      }
      case 40: {
        return "SOU_8";
      }
      case 41: {
        return "SOU_9";
      }
      case 49: {
        return "MAN_1";
      }
      case 50: {
        return "MAN_2";
      }
      case 51: {
        return "MAN_3";
      }
      case 52: {
        return "MAN_4";
      }
      case 53: {
        return "MAN_5";
      }
      case 54: {
        return "MAN_6";
      }
      case 55: {
        return "MAN_7";
      }
      case 56: {
        return "MAN_8";
      }
      case 57: {
        return "MAN_9";
      }
      case 65: {
        return "HAKU";
      }
      case 66: {
        return "HATSU";
      }
      case 67: {
        return "CHUN";
      }
      case 68: {
        return "TON";
      }
      case 69: {
        return "NAN";
      }
      case 70: {
        return "SHA";
      }
      case 71: {
        return "PEI";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_TileValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_TileValue): number {
    switch (i) {
      case "NIL": {
        return 0;
      }
      case "PIN_1": {
        return 17;
      }
      case "PIN_2": {
        return 18;
      }
      case "PIN_3": {
        return 19;
      }
      case "PIN_4": {
        return 20;
      }
      case "PIN_5": {
        return 21;
      }
      case "PIN_6": {
        return 22;
      }
      case "PIN_7": {
        return 23;
      }
      case "PIN_8": {
        return 24;
      }
      case "PIN_9": {
        return 25;
      }
      case "SOU_1": {
        return 33;
      }
      case "SOU_2": {
        return 34;
      }
      case "SOU_3": {
        return 35;
      }
      case "SOU_4": {
        return 36;
      }
      case "SOU_5": {
        return 37;
      }
      case "SOU_6": {
        return 38;
      }
      case "SOU_7": {
        return 39;
      }
      case "SOU_8": {
        return 40;
      }
      case "SOU_9": {
        return 41;
      }
      case "MAN_1": {
        return 49;
      }
      case "MAN_2": {
        return 50;
      }
      case "MAN_3": {
        return 51;
      }
      case "MAN_4": {
        return 52;
      }
      case "MAN_5": {
        return 53;
      }
      case "MAN_6": {
        return 54;
      }
      case "MAN_7": {
        return 55;
      }
      case "MAN_8": {
        return 56;
      }
      case "MAN_9": {
        return 57;
      }
      case "HAKU": {
        return 65;
      }
      case "HATSU": {
        return 66;
      }
      case "CHUN": {
        return 67;
      }
      case "TON": {
        return 68;
      }
      case "NAN": {
        return 69;
      }
      case "SHA": {
        return 70;
      }
      case "PEI": {
        return 71;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_SetKind = {
  PON: "PON",
  CHI: "CHI",
  ANKAN: "ANKAN",
  SHOMINKAN: "SHOMINKAN",
  DAIMINKAN: "DAIMINKAN",
  /**
   * @private
   */
  _fromInt: function (i: number): N_SetKind {
    switch (i) {
      case 0: {
        return "PON";
      }
      case 1: {
        return "CHI";
      }
      case 2: {
        return "ANKAN";
      }
      case 3: {
        return "SHOMINKAN";
      }
      case 4: {
        return "DAIMINKAN";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_SetKind;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_SetKind): number {
    switch (i) {
      case "PON": {
        return 0;
      }
      case "CHI": {
        return 1;
      }
      case "ANKAN": {
        return 2;
      }
      case "SHOMINKAN": {
        return 3;
      }
      case "DAIMINKAN": {
        return 4;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_ClaimedFrom = {
  KAMICHA: "KAMICHA",
  TOIMEN: "TOIMEN",
  SHIMOCHA: "SHIMOCHA",
  /**
   * @private
   */
  _fromInt: function (i: number): N_ClaimedFrom {
    switch (i) {
      case 0: {
        return "KAMICHA";
      }
      case 1: {
        return "TOIMEN";
      }
      case 2: {
        return "SHIMOCHA";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_ClaimedFrom;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_ClaimedFrom): number {
    switch (i) {
      case "KAMICHA": {
        return 0;
      }
      case "TOIMEN": {
        return 1;
      }
      case "SHIMOCHA": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_MoveState = {
  WAITING: "WAITING",
  WAITING_FOR_DISCARD: "WAITING_FOR_DISCARD",
  WAITING_FOR_CLAIM: "WAITING_FOR_CLAIM",
  /**
   * @private
   */
  _fromInt: function (i: number): N_MoveState {
    switch (i) {
      case 0: {
        return "WAITING";
      }
      case 1: {
        return "WAITING_FOR_DISCARD";
      }
      case 2: {
        return "WAITING_FOR_CLAIM";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_MoveState;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_MoveState): number {
    switch (i) {
      case "WAITING": {
        return 0;
      }
      case "WAITING_FOR_DISCARD": {
        return 1;
      }
      case "WAITING_FOR_CLAIM": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_Player = {
  /**
   * Serializes N_Player to protobuf.
   */
  encode: function (msg: Partial<N_Player>): Uint8Array {
    return N_Player._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_Player from protobuf.
   */
  decode: function (bytes: ByteSource): N_Player {
    return N_Player._readMessage(
      N_Player.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_Player with all fields set to their default value.
   */
  initialize: function (): N_Player {
    return {
      id: 0,
      title: "",
      rating: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_Player>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.rating) {
      writer.writeInt32(3, msg.rating);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Player, reader: BinaryReader): N_Player {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.rating = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_Tile = {
  /**
   * Serializes N_Tile to protobuf.
   */
  encode: function (msg: Partial<N_Tile>): Uint8Array {
    return N_Tile._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_Tile from protobuf.
   */
  decode: function (bytes: ByteSource): N_Tile {
    return N_Tile._readMessage(N_Tile.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes N_Tile with all fields set to their default value.
   */
  initialize: function (): N_Tile {
    return {
      value: N_TileValue._fromInt(0),
      isAka: false,
      isTsumogiri: false,
      isClaimed: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_Tile>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value && N_TileValue._toInt(msg.value)) {
      writer.writeEnum(1, N_TileValue._toInt(msg.value));
    }
    if (msg.isAka) {
      writer.writeBool(2, msg.isAka);
    }
    if (msg.isTsumogiri) {
      writer.writeBool(3, msg.isTsumogiri);
    }
    if (msg.isClaimed) {
      writer.writeBool(4, msg.isClaimed);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Tile, reader: BinaryReader): N_Tile {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = N_TileValue._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.isAka = reader.readBool();
          break;
        }
        case 3: {
          msg.isTsumogiri = reader.readBool();
          break;
        }
        case 4: {
          msg.isClaimed = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_Discard = {
  /**
   * Serializes N_Discard to protobuf.
   */
  encode: function (msg: Partial<N_Discard>): Uint8Array {
    return N_Discard._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_Discard from protobuf.
   */
  decode: function (bytes: ByteSource): N_Discard {
    return N_Discard._readMessage(
      N_Discard.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_Discard with all fields set to their default value.
   */
  initialize: function (): N_Discard {
    return {
      tiles: [],
      riichi: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_Discard>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.tiles?.length) {
      writer.writeRepeatedMessage(1, msg.tiles as any, N_Tile._writeMessage);
    }
    if (msg.riichi) {
      writer.writeInt32(2, msg.riichi);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Discard, reader: BinaryReader): N_Discard {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = N_Tile.initialize();
          reader.readMessage(m, N_Tile._readMessage);
          msg.tiles.push(m);
          break;
        }
        case 2: {
          msg.riichi = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_OpenSet = {
  /**
   * Serializes N_OpenSet to protobuf.
   */
  encode: function (msg: Partial<N_OpenSet>): Uint8Array {
    return N_OpenSet._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_OpenSet from protobuf.
   */
  decode: function (bytes: ByteSource): N_OpenSet {
    return N_OpenSet._readMessage(
      N_OpenSet.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_OpenSet with all fields set to their default value.
   */
  initialize: function (): N_OpenSet {
    return {
      kind: N_SetKind._fromInt(0),
      tiles: [],
      from: N_ClaimedFrom._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_OpenSet>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.kind && N_SetKind._toInt(msg.kind)) {
      writer.writeEnum(1, N_SetKind._toInt(msg.kind));
    }
    if (msg.tiles?.length) {
      writer.writeRepeatedMessage(2, msg.tiles as any, N_Tile._writeMessage);
    }
    if (msg.from && N_ClaimedFrom._toInt(msg.from)) {
      writer.writeEnum(3, N_ClaimedFrom._toInt(msg.from));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_OpenSet, reader: BinaryReader): N_OpenSet {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = N_SetKind._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          const m = N_Tile.initialize();
          reader.readMessage(m, N_Tile._readMessage);
          msg.tiles.push(m);
          break;
        }
        case 3: {
          msg.from = N_ClaimedFrom._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_ClosedPart = {
  /**
   * Serializes N_ClosedPart to protobuf.
   */
  encode: function (msg: Partial<N_ClosedPart>): Uint8Array {
    return N_ClosedPart._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes N_ClosedPart from protobuf.
   */
  decode: function (bytes: ByteSource): N_ClosedPart {
    return N_ClosedPart._readMessage(
      N_ClosedPart.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_ClosedPart with all fields set to their default value.
   */
  initialize: function (): N_ClosedPart {
    return {
      closedPart: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_ClosedPart>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.closedPart?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.closedPart as any,
        N_Tile._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: N_ClosedPart,
    reader: BinaryReader
  ): N_ClosedPart {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = N_Tile.initialize();
          reader.readMessage(m, N_Tile._readMessage);
          msg.closedPart.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_Hand = {
  /**
   * Serializes N_Hand to protobuf.
   */
  encode: function (msg: Partial<N_Hand>): Uint8Array {
    return N_Hand._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_Hand from protobuf.
   */
  decode: function (bytes: ByteSource): N_Hand {
    return N_Hand._readMessage(N_Hand.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes N_Hand with all fields set to their default value.
   */
  initialize: function (): N_Hand {
    return {
      closedPart: undefined,
      openedPart: [],
      closedPartLength: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_Hand>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.closedPart != undefined) {
      writer.writeMessage(1, msg.closedPart, N_ClosedPart._writeMessage);
    }
    if (msg.openedPart?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.openedPart as any,
        N_OpenSet._writeMessage
      );
    }
    if (msg.closedPartLength) {
      writer.writeInt32(3, msg.closedPartLength);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Hand, reader: BinaryReader): N_Hand {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.closedPart = N_ClosedPart.initialize();
          reader.readMessage(msg.closedPart, N_ClosedPart._readMessage);
          break;
        }
        case 2: {
          const m = N_OpenSet.initialize();
          reader.readMessage(m, N_OpenSet._readMessage);
          msg.openedPart.push(m);
          break;
        }
        case 3: {
          msg.closedPartLength = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_Move = {
  /**
   * Serializes N_Move to protobuf.
   */
  encode: function (msg: Partial<N_Move>): Uint8Array {
    return N_Move._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_Move from protobuf.
   */
  decode: function (bytes: ByteSource): N_Move {
    return N_Move._readMessage(N_Move.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes N_Move with all fields set to their default value.
   */
  initialize: function (): N_Move {
    return {
      moveState: N_MoveState._fromInt(0),
      lastDiscard: N_Tile.initialize(),
      lastDiscardFrom: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_Move>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.moveState && N_MoveState._toInt(msg.moveState)) {
      writer.writeEnum(11, N_MoveState._toInt(msg.moveState));
    }
    if (msg.lastDiscard) {
      writer.writeMessage(12, msg.lastDiscard, N_Tile._writeMessage);
    }
    if (msg.lastDiscardFrom) {
      writer.writeInt32(13, msg.lastDiscardFrom);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Move, reader: BinaryReader): N_Move {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.moveState = N_MoveState._fromInt(reader.readEnum());
          break;
        }
        case 12: {
          reader.readMessage(msg.lastDiscard, N_Tile._readMessage);
          break;
        }
        case 13: {
          msg.lastDiscardFrom = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_CurrentRound = {
  /**
   * Serializes N_CurrentRound to protobuf.
   */
  encode: function (msg: Partial<N_CurrentRound>): Uint8Array {
    return N_CurrentRound._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes N_CurrentRound from protobuf.
   */
  decode: function (bytes: ByteSource): N_CurrentRound {
    return N_CurrentRound._readMessage(
      N_CurrentRound.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_CurrentRound with all fields set to their default value.
   */
  initialize: function (): N_CurrentRound {
    return {
      discards: [],
      tilesInWallCount: 0,
      doraIndicators: [],
      currentRiichi: [],
      moveState: N_Move.initialize(),
      diceValue: 0,
      hands: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_CurrentRound>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.discards?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.discards as any,
        N_Discard._writeMessage
      );
    }
    if (msg.tilesInWallCount) {
      writer.writeInt32(2, msg.tilesInWallCount);
    }
    if (msg.doraIndicators?.length) {
      writer.writePackedEnum(3, msg.doraIndicators.map(N_TileValue._toInt));
    }
    if (msg.currentRiichi?.length) {
      writer.writePackedBool(4, msg.currentRiichi);
    }
    if (msg.moveState) {
      writer.writeMessage(5, msg.moveState, N_Move._writeMessage);
    }
    if (msg.diceValue) {
      writer.writeInt32(6, msg.diceValue);
    }
    if (msg.hands?.length) {
      writer.writeRepeatedMessage(7, msg.hands as any, N_Hand._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: N_CurrentRound,
    reader: BinaryReader
  ): N_CurrentRound {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = N_Discard.initialize();
          reader.readMessage(m, N_Discard._readMessage);
          msg.discards.push(m);
          break;
        }
        case 2: {
          msg.tilesInWallCount = reader.readInt32();
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.doraIndicators.push(
              ...reader.readPackedEnum().map(N_TileValue._fromInt)
            );
          } else {
            msg.doraIndicators.push(N_TileValue._fromInt(reader.readEnum()));
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.currentRiichi.push(...reader.readPackedBool());
          } else {
            msg.currentRiichi.push(reader.readBool());
          }
          break;
        }
        case 5: {
          reader.readMessage(msg.moveState, N_Move._readMessage);
          break;
        }
        case 6: {
          msg.diceValue = reader.readInt32();
          break;
        }
        case 7: {
          const m = N_Hand.initialize();
          reader.readMessage(m, N_Hand._readMessage);
          msg.hands.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_GameState = {
  /**
   * Serializes N_GameState to protobuf.
   */
  encode: function (msg: Partial<N_GameState>): Uint8Array {
    return N_GameState._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes N_GameState from protobuf.
   */
  decode: function (bytes: ByteSource): N_GameState {
    return N_GameState._readMessage(
      N_GameState.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_GameState with all fields set to their default value.
   */
  initialize: function (): N_GameState {
    return {
      players: [],
      currentScores: [],
      currentRound: 0,
      currentRenchan: 0,
      roundStatus: N_RoundStatus._fromInt(0),
      riichiOnTable: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_GameState>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.players?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.players as any,
        N_Player._writeMessage
      );
    }
    if (msg.currentScores?.length) {
      writer.writePackedInt32(2, msg.currentScores);
    }
    if (msg.currentRound) {
      writer.writeInt32(3, msg.currentRound);
    }
    if (msg.currentRenchan) {
      writer.writeInt32(4, msg.currentRenchan);
    }
    if (msg.roundStatus && N_RoundStatus._toInt(msg.roundStatus)) {
      writer.writeEnum(5, N_RoundStatus._toInt(msg.roundStatus));
    }
    if (msg.riichiOnTable) {
      writer.writeInt32(6, msg.riichiOnTable);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_GameState, reader: BinaryReader): N_GameState {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = N_Player.initialize();
          reader.readMessage(m, N_Player._readMessage);
          msg.players.push(m);
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.currentScores.push(...reader.readPackedInt32());
          } else {
            msg.currentScores.push(reader.readInt32());
          }
          break;
        }
        case 3: {
          msg.currentRound = reader.readInt32();
          break;
        }
        case 4: {
          msg.currentRenchan = reader.readInt32();
          break;
        }
        case 5: {
          msg.roundStatus = N_RoundStatus._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.riichiOnTable = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const N_TableState = {
  /**
   * Serializes N_TableState to protobuf.
   */
  encode: function (msg: Partial<N_TableState>): Uint8Array {
    return N_TableState._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes N_TableState from protobuf.
   */
  decode: function (bytes: ByteSource): N_TableState {
    return N_TableState._readMessage(
      N_TableState.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes N_TableState with all fields set to their default value.
   */
  initialize: function (): N_TableState {
    return {
      game: N_GameState.initialize(),
      currentRound: N_CurrentRound.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_TableState>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.game) {
      writer.writeMessage(1, msg.game, N_GameState._writeMessage);
    }
    if (msg.currentRound) {
      writer.writeMessage(2, msg.currentRound, N_CurrentRound._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: N_TableState,
    reader: BinaryReader
  ): N_TableState {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.game, N_GameState._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.currentRound, N_CurrentRound._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const N_RoundStatusJSON = {
  NOT_STARTED: "NOT_STARTED",
  SEEDING: "SEEDING",
  PLAYING: "PLAYING",
  ENDED: "ENDED",
  /**
   * @private
   */
  _fromInt: function (i: number): N_RoundStatus {
    switch (i) {
      case 0: {
        return "NOT_STARTED";
      }
      case 1: {
        return "SEEDING";
      }
      case 2: {
        return "PLAYING";
      }
      case 3: {
        return "ENDED";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_RoundStatus;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_RoundStatus): number {
    switch (i) {
      case "NOT_STARTED": {
        return 0;
      }
      case "SEEDING": {
        return 1;
      }
      case "PLAYING": {
        return 2;
      }
      case "ENDED": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_TileValueJSON = {
  NIL: "NIL",
  PIN_1: "PIN_1",
  PIN_2: "PIN_2",
  PIN_3: "PIN_3",
  PIN_4: "PIN_4",
  PIN_5: "PIN_5",
  PIN_6: "PIN_6",
  PIN_7: "PIN_7",
  PIN_8: "PIN_8",
  PIN_9: "PIN_9",
  SOU_1: "SOU_1",
  SOU_2: "SOU_2",
  SOU_3: "SOU_3",
  SOU_4: "SOU_4",
  SOU_5: "SOU_5",
  SOU_6: "SOU_6",
  SOU_7: "SOU_7",
  SOU_8: "SOU_8",
  SOU_9: "SOU_9",
  MAN_1: "MAN_1",
  MAN_2: "MAN_2",
  MAN_3: "MAN_3",
  MAN_4: "MAN_4",
  MAN_5: "MAN_5",
  MAN_6: "MAN_6",
  MAN_7: "MAN_7",
  MAN_8: "MAN_8",
  MAN_9: "MAN_9",
  HAKU: "HAKU",
  HATSU: "HATSU",
  CHUN: "CHUN",
  TON: "TON",
  NAN: "NAN",
  SHA: "SHA",
  PEI: "PEI",
  /**
   * @private
   */
  _fromInt: function (i: number): N_TileValue {
    switch (i) {
      case 0: {
        return "NIL";
      }
      case 17: {
        return "PIN_1";
      }
      case 18: {
        return "PIN_2";
      }
      case 19: {
        return "PIN_3";
      }
      case 20: {
        return "PIN_4";
      }
      case 21: {
        return "PIN_5";
      }
      case 22: {
        return "PIN_6";
      }
      case 23: {
        return "PIN_7";
      }
      case 24: {
        return "PIN_8";
      }
      case 25: {
        return "PIN_9";
      }
      case 33: {
        return "SOU_1";
      }
      case 34: {
        return "SOU_2";
      }
      case 35: {
        return "SOU_3";
      }
      case 36: {
        return "SOU_4";
      }
      case 37: {
        return "SOU_5";
      }
      case 38: {
        return "SOU_6";
      }
      case 39: {
        return "SOU_7";
      }
      case 40: {
        return "SOU_8";
      }
      case 41: {
        return "SOU_9";
      }
      case 49: {
        return "MAN_1";
      }
      case 50: {
        return "MAN_2";
      }
      case 51: {
        return "MAN_3";
      }
      case 52: {
        return "MAN_4";
      }
      case 53: {
        return "MAN_5";
      }
      case 54: {
        return "MAN_6";
      }
      case 55: {
        return "MAN_7";
      }
      case 56: {
        return "MAN_8";
      }
      case 57: {
        return "MAN_9";
      }
      case 65: {
        return "HAKU";
      }
      case 66: {
        return "HATSU";
      }
      case 67: {
        return "CHUN";
      }
      case 68: {
        return "TON";
      }
      case 69: {
        return "NAN";
      }
      case 70: {
        return "SHA";
      }
      case 71: {
        return "PEI";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_TileValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_TileValue): number {
    switch (i) {
      case "NIL": {
        return 0;
      }
      case "PIN_1": {
        return 17;
      }
      case "PIN_2": {
        return 18;
      }
      case "PIN_3": {
        return 19;
      }
      case "PIN_4": {
        return 20;
      }
      case "PIN_5": {
        return 21;
      }
      case "PIN_6": {
        return 22;
      }
      case "PIN_7": {
        return 23;
      }
      case "PIN_8": {
        return 24;
      }
      case "PIN_9": {
        return 25;
      }
      case "SOU_1": {
        return 33;
      }
      case "SOU_2": {
        return 34;
      }
      case "SOU_3": {
        return 35;
      }
      case "SOU_4": {
        return 36;
      }
      case "SOU_5": {
        return 37;
      }
      case "SOU_6": {
        return 38;
      }
      case "SOU_7": {
        return 39;
      }
      case "SOU_8": {
        return 40;
      }
      case "SOU_9": {
        return 41;
      }
      case "MAN_1": {
        return 49;
      }
      case "MAN_2": {
        return 50;
      }
      case "MAN_3": {
        return 51;
      }
      case "MAN_4": {
        return 52;
      }
      case "MAN_5": {
        return 53;
      }
      case "MAN_6": {
        return 54;
      }
      case "MAN_7": {
        return 55;
      }
      case "MAN_8": {
        return 56;
      }
      case "MAN_9": {
        return 57;
      }
      case "HAKU": {
        return 65;
      }
      case "HATSU": {
        return 66;
      }
      case "CHUN": {
        return 67;
      }
      case "TON": {
        return 68;
      }
      case "NAN": {
        return 69;
      }
      case "SHA": {
        return 70;
      }
      case "PEI": {
        return 71;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_SetKindJSON = {
  PON: "PON",
  CHI: "CHI",
  ANKAN: "ANKAN",
  SHOMINKAN: "SHOMINKAN",
  DAIMINKAN: "DAIMINKAN",
  /**
   * @private
   */
  _fromInt: function (i: number): N_SetKind {
    switch (i) {
      case 0: {
        return "PON";
      }
      case 1: {
        return "CHI";
      }
      case 2: {
        return "ANKAN";
      }
      case 3: {
        return "SHOMINKAN";
      }
      case 4: {
        return "DAIMINKAN";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_SetKind;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_SetKind): number {
    switch (i) {
      case "PON": {
        return 0;
      }
      case "CHI": {
        return 1;
      }
      case "ANKAN": {
        return 2;
      }
      case "SHOMINKAN": {
        return 3;
      }
      case "DAIMINKAN": {
        return 4;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_ClaimedFromJSON = {
  KAMICHA: "KAMICHA",
  TOIMEN: "TOIMEN",
  SHIMOCHA: "SHIMOCHA",
  /**
   * @private
   */
  _fromInt: function (i: number): N_ClaimedFrom {
    switch (i) {
      case 0: {
        return "KAMICHA";
      }
      case 1: {
        return "TOIMEN";
      }
      case 2: {
        return "SHIMOCHA";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_ClaimedFrom;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_ClaimedFrom): number {
    switch (i) {
      case "KAMICHA": {
        return 0;
      }
      case "TOIMEN": {
        return 1;
      }
      case "SHIMOCHA": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_MoveStateJSON = {
  WAITING: "WAITING",
  WAITING_FOR_DISCARD: "WAITING_FOR_DISCARD",
  WAITING_FOR_CLAIM: "WAITING_FOR_CLAIM",
  /**
   * @private
   */
  _fromInt: function (i: number): N_MoveState {
    switch (i) {
      case 0: {
        return "WAITING";
      }
      case 1: {
        return "WAITING_FOR_DISCARD";
      }
      case 2: {
        return "WAITING_FOR_CLAIM";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as N_MoveState;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: N_MoveState): number {
    switch (i) {
      case "WAITING": {
        return 0;
      }
      case "WAITING_FOR_DISCARD": {
        return 1;
      }
      case "WAITING_FOR_CLAIM": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const N_PlayerJSON = {
  /**
   * Serializes N_Player to JSON.
   */
  encode: function (msg: Partial<N_Player>): string {
    return JSON.stringify(N_PlayerJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_Player from JSON.
   */
  decode: function (json: string): N_Player {
    return N_PlayerJSON._readMessage(
      N_PlayerJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_Player with all fields set to their default value.
   */
  initialize: function (): N_Player {
    return {
      id: 0,
      title: "",
      rating: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_Player>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.rating) {
      json["rating"] = msg.rating;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Player, json: any): N_Player {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _rating_ = json["rating"];
    if (_rating_) {
      msg.rating = _rating_;
    }
    return msg;
  },
};

export const N_TileJSON = {
  /**
   * Serializes N_Tile to JSON.
   */
  encode: function (msg: Partial<N_Tile>): string {
    return JSON.stringify(N_TileJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_Tile from JSON.
   */
  decode: function (json: string): N_Tile {
    return N_TileJSON._readMessage(N_TileJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes N_Tile with all fields set to their default value.
   */
  initialize: function (): N_Tile {
    return {
      value: N_TileValue._fromInt(0),
      isAka: false,
      isTsumogiri: false,
      isClaimed: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_Tile>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value && N_TileValueJSON._toInt(msg.value)) {
      json["value"] = msg.value;
    }
    if (msg.isAka) {
      json["isAka"] = msg.isAka;
    }
    if (msg.isTsumogiri) {
      json["isTsumogiri"] = msg.isTsumogiri;
    }
    if (msg.isClaimed) {
      json["isClaimed"] = msg.isClaimed;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Tile, json: any): N_Tile {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = _value_;
    }
    const _isAka_ = json["isAka"];
    if (_isAka_) {
      msg.isAka = _isAka_;
    }
    const _isTsumogiri_ = json["isTsumogiri"];
    if (_isTsumogiri_) {
      msg.isTsumogiri = _isTsumogiri_;
    }
    const _isClaimed_ = json["isClaimed"];
    if (_isClaimed_) {
      msg.isClaimed = _isClaimed_;
    }
    return msg;
  },
};

export const N_DiscardJSON = {
  /**
   * Serializes N_Discard to JSON.
   */
  encode: function (msg: Partial<N_Discard>): string {
    return JSON.stringify(N_DiscardJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_Discard from JSON.
   */
  decode: function (json: string): N_Discard {
    return N_DiscardJSON._readMessage(
      N_DiscardJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_Discard with all fields set to their default value.
   */
  initialize: function (): N_Discard {
    return {
      tiles: [],
      riichi: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_Discard>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tiles?.length) {
      json["tiles"] = msg.tiles.map(N_TileJSON._writeMessage);
    }
    if (msg.riichi) {
      json["riichi"] = msg.riichi;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Discard, json: any): N_Discard {
    const _tiles_ = json["tiles"];
    if (_tiles_) {
      for (const item of _tiles_) {
        const m = N_Tile.initialize();
        N_TileJSON._readMessage(m, item);
        msg.tiles.push(m);
      }
    }
    const _riichi_ = json["riichi"];
    if (_riichi_) {
      msg.riichi = _riichi_;
    }
    return msg;
  },
};

export const N_OpenSetJSON = {
  /**
   * Serializes N_OpenSet to JSON.
   */
  encode: function (msg: Partial<N_OpenSet>): string {
    return JSON.stringify(N_OpenSetJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_OpenSet from JSON.
   */
  decode: function (json: string): N_OpenSet {
    return N_OpenSetJSON._readMessage(
      N_OpenSetJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_OpenSet with all fields set to their default value.
   */
  initialize: function (): N_OpenSet {
    return {
      kind: N_SetKind._fromInt(0),
      tiles: [],
      from: N_ClaimedFrom._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_OpenSet>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.kind && N_SetKindJSON._toInt(msg.kind)) {
      json["kind"] = msg.kind;
    }
    if (msg.tiles?.length) {
      json["tiles"] = msg.tiles.map(N_TileJSON._writeMessage);
    }
    if (msg.from && N_ClaimedFromJSON._toInt(msg.from)) {
      json["from"] = msg.from;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_OpenSet, json: any): N_OpenSet {
    const _kind_ = json["kind"];
    if (_kind_) {
      msg.kind = _kind_;
    }
    const _tiles_ = json["tiles"];
    if (_tiles_) {
      for (const item of _tiles_) {
        const m = N_Tile.initialize();
        N_TileJSON._readMessage(m, item);
        msg.tiles.push(m);
      }
    }
    const _from_ = json["from"];
    if (_from_) {
      msg.from = _from_;
    }
    return msg;
  },
};

export const N_ClosedPartJSON = {
  /**
   * Serializes N_ClosedPart to JSON.
   */
  encode: function (msg: Partial<N_ClosedPart>): string {
    return JSON.stringify(N_ClosedPartJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_ClosedPart from JSON.
   */
  decode: function (json: string): N_ClosedPart {
    return N_ClosedPartJSON._readMessage(
      N_ClosedPartJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_ClosedPart with all fields set to their default value.
   */
  initialize: function (): N_ClosedPart {
    return {
      closedPart: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_ClosedPart>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.closedPart?.length) {
      json["closedPart"] = msg.closedPart.map(N_TileJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_ClosedPart, json: any): N_ClosedPart {
    const _closedPart_ = json["closedPart"];
    if (_closedPart_) {
      for (const item of _closedPart_) {
        const m = N_Tile.initialize();
        N_TileJSON._readMessage(m, item);
        msg.closedPart.push(m);
      }
    }
    return msg;
  },
};

export const N_HandJSON = {
  /**
   * Serializes N_Hand to JSON.
   */
  encode: function (msg: Partial<N_Hand>): string {
    return JSON.stringify(N_HandJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_Hand from JSON.
   */
  decode: function (json: string): N_Hand {
    return N_HandJSON._readMessage(N_HandJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes N_Hand with all fields set to their default value.
   */
  initialize: function (): N_Hand {
    return {
      closedPart: undefined,
      openedPart: [],
      closedPartLength: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_Hand>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.closedPart != undefined) {
      const _closedPart_ = N_ClosedPartJSON._writeMessage(msg.closedPart);
      json["closedPart"] = _closedPart_;
    }
    if (msg.openedPart?.length) {
      json["openedPart"] = msg.openedPart.map(N_OpenSetJSON._writeMessage);
    }
    if (msg.closedPartLength) {
      json["closedPartLength"] = msg.closedPartLength;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Hand, json: any): N_Hand {
    const _closedPart_ = json["closedPart"];
    if (_closedPart_) {
      const m = N_ClosedPart.initialize();
      N_ClosedPartJSON._readMessage(m, _closedPart_);
      msg.closedPart = m;
    }
    const _openedPart_ = json["openedPart"];
    if (_openedPart_) {
      for (const item of _openedPart_) {
        const m = N_OpenSet.initialize();
        N_OpenSetJSON._readMessage(m, item);
        msg.openedPart.push(m);
      }
    }
    const _closedPartLength_ = json["closedPartLength"];
    if (_closedPartLength_) {
      msg.closedPartLength = _closedPartLength_;
    }
    return msg;
  },
};

export const N_MoveJSON = {
  /**
   * Serializes N_Move to JSON.
   */
  encode: function (msg: Partial<N_Move>): string {
    return JSON.stringify(N_MoveJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_Move from JSON.
   */
  decode: function (json: string): N_Move {
    return N_MoveJSON._readMessage(N_MoveJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes N_Move with all fields set to their default value.
   */
  initialize: function (): N_Move {
    return {
      moveState: N_MoveState._fromInt(0),
      lastDiscard: N_TileJSON.initialize(),
      lastDiscardFrom: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_Move>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.moveState && N_MoveStateJSON._toInt(msg.moveState)) {
      json["moveState"] = msg.moveState;
    }
    if (msg.lastDiscard) {
      const _lastDiscard_ = N_TileJSON._writeMessage(msg.lastDiscard);
      if (Object.keys(_lastDiscard_).length > 0) {
        json["lastDiscard"] = _lastDiscard_;
      }
    }
    if (msg.lastDiscardFrom) {
      json["lastDiscardFrom"] = msg.lastDiscardFrom;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_Move, json: any): N_Move {
    const _moveState_ = json["moveState"];
    if (_moveState_) {
      msg.moveState = _moveState_;
    }
    const _lastDiscard_ = json["lastDiscard"];
    if (_lastDiscard_) {
      const m = N_Tile.initialize();
      N_TileJSON._readMessage(m, _lastDiscard_);
      msg.lastDiscard = m;
    }
    const _lastDiscardFrom_ = json["lastDiscardFrom"];
    if (_lastDiscardFrom_) {
      msg.lastDiscardFrom = _lastDiscardFrom_;
    }
    return msg;
  },
};

export const N_CurrentRoundJSON = {
  /**
   * Serializes N_CurrentRound to JSON.
   */
  encode: function (msg: Partial<N_CurrentRound>): string {
    return JSON.stringify(N_CurrentRoundJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_CurrentRound from JSON.
   */
  decode: function (json: string): N_CurrentRound {
    return N_CurrentRoundJSON._readMessage(
      N_CurrentRoundJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_CurrentRound with all fields set to their default value.
   */
  initialize: function (): N_CurrentRound {
    return {
      discards: [],
      tilesInWallCount: 0,
      doraIndicators: [],
      currentRiichi: [],
      moveState: N_MoveJSON.initialize(),
      diceValue: 0,
      hands: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_CurrentRound>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.discards?.length) {
      json["discards"] = msg.discards.map(N_DiscardJSON._writeMessage);
    }
    if (msg.tilesInWallCount) {
      json["tilesInWallCount"] = msg.tilesInWallCount;
    }
    if (msg.doraIndicators?.length) {
      json["doraIndicators"] = msg.doraIndicators;
    }
    if (msg.currentRiichi?.length) {
      json["currentRiichi"] = msg.currentRiichi;
    }
    if (msg.moveState) {
      const _moveState_ = N_MoveJSON._writeMessage(msg.moveState);
      if (Object.keys(_moveState_).length > 0) {
        json["moveState"] = _moveState_;
      }
    }
    if (msg.diceValue) {
      json["diceValue"] = msg.diceValue;
    }
    if (msg.hands?.length) {
      json["hands"] = msg.hands.map(N_HandJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_CurrentRound, json: any): N_CurrentRound {
    const _discards_ = json["discards"];
    if (_discards_) {
      for (const item of _discards_) {
        const m = N_Discard.initialize();
        N_DiscardJSON._readMessage(m, item);
        msg.discards.push(m);
      }
    }
    const _tilesInWallCount_ = json["tilesInWallCount"];
    if (_tilesInWallCount_) {
      msg.tilesInWallCount = _tilesInWallCount_;
    }
    const _doraIndicators_ = json["doraIndicators"];
    if (_doraIndicators_) {
      msg.doraIndicators = _doraIndicators_;
    }
    const _currentRiichi_ = json["currentRiichi"];
    if (_currentRiichi_) {
      msg.currentRiichi = _currentRiichi_;
    }
    const _moveState_ = json["moveState"];
    if (_moveState_) {
      const m = N_Move.initialize();
      N_MoveJSON._readMessage(m, _moveState_);
      msg.moveState = m;
    }
    const _diceValue_ = json["diceValue"];
    if (_diceValue_) {
      msg.diceValue = _diceValue_;
    }
    const _hands_ = json["hands"];
    if (_hands_) {
      for (const item of _hands_) {
        const m = N_Hand.initialize();
        N_HandJSON._readMessage(m, item);
        msg.hands.push(m);
      }
    }
    return msg;
  },
};

export const N_GameStateJSON = {
  /**
   * Serializes N_GameState to JSON.
   */
  encode: function (msg: Partial<N_GameState>): string {
    return JSON.stringify(N_GameStateJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_GameState from JSON.
   */
  decode: function (json: string): N_GameState {
    return N_GameStateJSON._readMessage(
      N_GameStateJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_GameState with all fields set to their default value.
   */
  initialize: function (): N_GameState {
    return {
      players: [],
      currentScores: [],
      currentRound: 0,
      currentRenchan: 0,
      roundStatus: N_RoundStatus._fromInt(0),
      riichiOnTable: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<N_GameState>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.players?.length) {
      json["players"] = msg.players.map(N_PlayerJSON._writeMessage);
    }
    if (msg.currentScores?.length) {
      json["currentScores"] = msg.currentScores;
    }
    if (msg.currentRound) {
      json["currentRound"] = msg.currentRound;
    }
    if (msg.currentRenchan) {
      json["currentRenchan"] = msg.currentRenchan;
    }
    if (msg.roundStatus && N_RoundStatusJSON._toInt(msg.roundStatus)) {
      json["roundStatus"] = msg.roundStatus;
    }
    if (msg.riichiOnTable) {
      json["riichiOnTable"] = msg.riichiOnTable;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_GameState, json: any): N_GameState {
    const _players_ = json["players"];
    if (_players_) {
      for (const item of _players_) {
        const m = N_Player.initialize();
        N_PlayerJSON._readMessage(m, item);
        msg.players.push(m);
      }
    }
    const _currentScores_ = json["currentScores"];
    if (_currentScores_) {
      msg.currentScores = _currentScores_;
    }
    const _currentRound_ = json["currentRound"];
    if (_currentRound_) {
      msg.currentRound = _currentRound_;
    }
    const _currentRenchan_ = json["currentRenchan"];
    if (_currentRenchan_) {
      msg.currentRenchan = _currentRenchan_;
    }
    const _roundStatus_ = json["roundStatus"];
    if (_roundStatus_) {
      msg.roundStatus = _roundStatus_;
    }
    const _riichiOnTable_ = json["riichiOnTable"];
    if (_riichiOnTable_) {
      msg.riichiOnTable = _riichiOnTable_;
    }
    return msg;
  },
};

export const N_TableStateJSON = {
  /**
   * Serializes N_TableState to JSON.
   */
  encode: function (msg: Partial<N_TableState>): string {
    return JSON.stringify(N_TableStateJSON._writeMessage(msg));
  },

  /**
   * Deserializes N_TableState from JSON.
   */
  decode: function (json: string): N_TableState {
    return N_TableStateJSON._readMessage(
      N_TableStateJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes N_TableState with all fields set to their default value.
   */
  initialize: function (): N_TableState {
    return {
      game: N_GameStateJSON.initialize(),
      currentRound: N_CurrentRoundJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<N_TableState>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.game) {
      const _game_ = N_GameStateJSON._writeMessage(msg.game);
      if (Object.keys(_game_).length > 0) {
        json["game"] = _game_;
      }
    }
    if (msg.currentRound) {
      const _currentRound_ = N_CurrentRoundJSON._writeMessage(msg.currentRound);
      if (Object.keys(_currentRound_).length > 0) {
        json["currentRound"] = _currentRound_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: N_TableState, json: any): N_TableState {
    const _game_ = json["game"];
    if (_game_) {
      const m = N_GameState.initialize();
      N_GameStateJSON._readMessage(m, _game_);
      msg.game = m;
    }
    const _currentRound_ = json["currentRound"];
    if (_currentRound_) {
      const m = N_CurrentRound.initialize();
      N_CurrentRoundJSON._readMessage(m, _currentRound_);
      msg.currentRound = m;
    }
    return msg;
  },
};
